<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={853:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return XC},load:function(){return qC}});var r={};n.r(r),n.d(r,{add:function(){return J},adjoint:function(){return T},clone:function(){return d},copy:function(){return p},create:function(){return u},determinant:function(){return y},equals:function(){return oe},exactEquals:function(){return re},frob:function(){return Q},fromQuat:function(){return G},fromQuat2:function(){return L},fromRotation:function(){return R},fromRotationTranslation:function(){return D},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return k},fromScaling:function(){return P},fromTranslation:function(){return O},fromValues:function(){return f},fromXRotation:function(){return M},fromYRotation:function(){return E},fromZRotation:function(){return V},frustum:function(){return U},getRotation:function(){return F},getScaling:function(){return N},getTranslation:function(){return B},identity:function(){return m},invert:function(){return v},lookAt:function(){return X},mul:function(){return ae},multiply:function(){return b},multiplyScalar:function(){return te},multiplyScalarAndAdd:function(){return ne},ortho:function(){return $},orthoNO:function(){return K},orthoZO:function(){return q},perspective:function(){return W},perspectiveFromFieldOfView:function(){return j},perspectiveNO:function(){return z},perspectiveZO:function(){return H},rotate:function(){return S},rotateX:function(){return A},rotateY:function(){return I},rotateZ:function(){return w},scale:function(){return C},set:function(){return g},str:function(){return Z},sub:function(){return ie},subtract:function(){return ee},targetTo:function(){return Y},translate:function(){return x},transpose:function(){return h}});var o={};n.r(o),n.d(o,{add:function(){return Ee},adjoint:function(){return he},clone:function(){return ce},copy:function(){return ue},create:function(){return se},determinant:function(){return ve},equals:function(){return Ne},exactEquals:function(){return Be},frob:function(){return Me},fromMat2d:function(){return Ie},fromMat4:function(){return le},fromQuat:function(){return we},fromRotation:function(){return Se},fromScaling:function(){return Ae},fromTranslation:function(){return Ce},fromValues:function(){return de},identity:function(){return fe},invert:function(){return me},mul:function(){return Fe},multiply:function(){return Te},multiplyScalar:function(){return De},multiplyScalarAndAdd:function(){return Le},normalFromMat4:function(){return Oe},projection:function(){return Pe},rotate:function(){return be},scale:function(){return xe},set:function(){return pe},str:function(){return Re},sub:function(){return _e},subtract:function(){return Ve},translate:function(){return ye},transpose:function(){return ge}});const a=document.querySelector("head");a&&[16,32,96,160,196].forEach((e=>{const t=document.createElement("link");t.setAttribute("rel","icon"),t.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${e}x${e}.png`),t.setAttribute("sizes",`${e}x${e}`),t.setAttribute("type","image/png"),a.appendChild(t)}));var i=1e-6,s="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var l=Math.PI/180;function c(e){return e*l}function u(){var e=new s(16);return s!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function d(e){var t=new s(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function p(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function f(e,t,n,r,o,a,i,l,c,u,d,p,f,g,m,h){var v=new s(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=i,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function g(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function m(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function h(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(o*P-r*R-a*O)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*y)*M,e[7]=(u*S-p*b+f*y)*M,e[8]=(i*P-s*w+c*A)*M,e[9]=(r*w-n*P-a*A)*M,e[10]=(g*C-m*b+v*T)*M,e[11]=(d*b-u*C-f*T)*M,e[12]=(s*I-i*O-l*A)*M,e[13]=(n*O-r*I+o*A)*M,e[14]=(m*y-g*x-h*T)*M,e[15]=(u*x-d*y+p*T)*M,e):null}function T(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function b(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],T=t[15],y=n[0],b=n[1],x=n[2],C=n[3];return e[0]=y*r+b*s+x*d+C*m,e[1]=y*o+b*l+x*p+C*h,e[2]=y*a+b*c+x*f+C*v,e[3]=y*i+b*u+x*g+C*T,y=n[4],b=n[5],x=n[6],C=n[7],e[4]=y*r+b*s+x*d+C*m,e[5]=y*o+b*l+x*p+C*h,e[6]=y*a+b*c+x*f+C*v,e[7]=y*i+b*u+x*g+C*T,y=n[8],b=n[9],x=n[10],C=n[11],e[8]=y*r+b*s+x*d+C*m,e[9]=y*o+b*l+x*p+C*h,e[10]=y*a+b*c+x*f+C*v,e[11]=y*i+b*u+x*g+C*T,y=n[12],b=n[13],x=n[14],C=n[15],e[12]=y*r+b*s+x*d+C*m,e[13]=y*o+b*l+x*p+C*h,e[14]=y*a+b*c+x*f+C*v,e[15]=y*i+b*u+x*g+C*T,e}function x(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function C(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function S(e,t,n,r){var o,a,s,l,c,u,d,p,f,g,m,h,v,T,y,b,x,C,S,A,I,w,O,P,R=r[0],M=r[1],E=r[2],V=Math.hypot(R,M,E);return V<i?null:(R*=V=1/V,M*=V,E*=V,o=Math.sin(n),s=1-(a=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],T=t[10],y=t[11],b=R*R*s+a,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+a,I=E*M*s+R*o,w=R*E*s+M*o,O=M*E*s-R*o,P=E*E*s+a,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+T*C,e[3]=d*b+m*x+y*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+T*I,e[7]=d*S+m*A+y*I,e[8]=l*w+p*O+h*P,e[9]=c*w+f*O+v*P,e[10]=u*w+g*O+T*P,e[11]=d*w+m*O+y*P,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function w(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function O(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function R(e,t,n){var r,o,a,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<i?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),a=1-(o=Math.cos(t)),e[0]=s*s*a+o,e[1]=l*s*a+c*r,e[2]=c*s*a-l*r,e[3]=0,e[4]=s*l*a-c*r,e[5]=l*l*a+o,e[6]=c*l*a+s*r,e[7]=0,e[8]=s*c*a+l*r,e[9]=l*c*a-s*r,e[10]=c*c*a+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function V(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,T=i*c;return e[0]=1-(f+m),e[1]=d+T,e[2]=p-v,e[3]=0,e[4]=d-T,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function L(e,t){var n=new s(3),r=-t[0],o=-t[1],a=-t[2],i=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+i*i;return p>0?(n[0]=2*(l*i+d*r+c*a-u*o)/p,n[1]=2*(c*i+d*o+u*r-l*a)/p,n[2]=2*(u*i+d*a+l*o-c*r)/p):(n[0]=2*(l*i+d*r+c*a-u*o),n[1]=2*(c*i+d*o+u*r-l*a),n[2]=2*(u*i+d*a+l*o-c*r)),D(e,t,n),e}function B(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function N(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function F(e,t){var n=new s(3);N(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],i=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=i+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):i>d&&i>m?(v=2*Math.sqrt(1+i-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-i-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-i-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,T=s*c,y=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+y)*b,e[2]=(f-T)*b,e[3]=0,e[4]=(p-y)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+T)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function k(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,T=l*c,y=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],O=(1-(m+v))*x,P=(f+b)*x,R=(g-y)*x,M=(f-b)*C,E=(1-(p+v))*C,V=(h+T)*C,D=(g+y)*S,L=(h-T)*S,B=(1-(p+m))*S;return e[0]=O,e[1]=P,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=V,e[7]=0,e[8]=D,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(O*A+M*I+D*w),e[13]=n[1]+I-(P*A+E*I+L*w),e[14]=n[2]+w-(R*A+V*I+B*w),e[15]=1,e}function G(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function U(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function z(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var W=z;function H(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function j(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function K(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var $=K;function q(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function X(e,t,n,r){var o,a,s,l,c,u,d,p,f,g,h=t[0],v=t[1],T=t[2],y=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<i&&Math.abs(v-S)<i&&Math.abs(T-A)<i?m(e):(d=h-C,p=v-S,f=T-A,o=b*(f*=g=1/Math.hypot(d,p,f))-x*(p*=g),a=x*(d*=g)-y*f,s=y*p-b*d,(g=Math.hypot(o,a,s))?(o*=g=1/g,a*=g,s*=g):(o=0,a=0,s=0),l=p*s-f*a,c=f*o-d*s,u=d*a-p*o,(g=Math.hypot(l,c,u))?(l*=g=1/g,c*=g,u*=g):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=a,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+a*v+s*T),e[13]=-(l*h+c*v+u*T),e[14]=-(d*h+p*v+f*T),e[15]=1,e)}function Y(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Z(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Q(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function J(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function te(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function ne(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function re(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function oe(e,t){var n=e[0],r=e[1],o=e[2],a=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],T=e[15],y=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],O=t[8],P=t[9],R=t[10],M=t[11],E=t[12],V=t[13],D=t[14],L=t[15];return Math.abs(n-y)<=i*Math.max(1,Math.abs(n),Math.abs(y))&&Math.abs(r-b)<=i*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=i*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(a-C)<=i*Math.max(1,Math.abs(a),Math.abs(C))&&Math.abs(s-S)<=i*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=i*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=i*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=i*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-O)<=i*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(p-P)<=i*Math.max(1,Math.abs(p),Math.abs(P))&&Math.abs(f-R)<=i*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=i*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=i*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-V)<=i*Math.max(1,Math.abs(h),Math.abs(V))&&Math.abs(v-D)<=i*Math.max(1,Math.abs(v),Math.abs(D))&&Math.abs(T-L)<=i*Math.max(1,Math.abs(T),Math.abs(L))}var ae=b,ie=ee;function se(){var e=new s(9);return s!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function le(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function ce(e){var t=new s(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ue(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function de(e,t,n,r,o,a,i,l,c){var u=new s(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=i,u[7]=l,u[8]=c,u}function pe(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function fe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function ge(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function he(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function ve(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],T=n[6],y=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=T*r+y*i+b*c,e[7]=T*o+y*s+b*u,e[8]=T*a+y*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function be(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function xe(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function Ce(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Se(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ie(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function Oe(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*P-s*w+c*A)*M,e[3]=(o*P-r*R-a*O)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*P-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*y)*M,e[8]=(g*C-m*b+v*T)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Re(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Me(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Ee(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ve(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function De(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Le(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Be(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Ne(e,t){var n=e[0],r=e[1],o=e[2],a=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],T=t[6],y=t[7],b=t[8];return Math.abs(n-p)<=i*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=i*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=i*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(a-m)<=i*Math.max(1,Math.abs(a),Math.abs(m))&&Math.abs(s-h)<=i*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=i*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-T)<=i*Math.max(1,Math.abs(c),Math.abs(T))&&Math.abs(u-y)<=i*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(d-b)<=i*Math.max(1,Math.abs(d),Math.abs(b))}var Fe=Te,_e=Ve,ke=n(730);const Ge=n(59)(),Ue={vtkObject:()=>null};function ze(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ge.console&&Ge.console.error&&Ge.console.error("Invalid VTK object"),null;const t=Ue[e.vtkClass];if(!t)return Ge.console&&Ge.console.error&&Ge.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=ze(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}ze.register=function(e,t){Ue[e]=t};class We extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let He=0;const je=e=>{throw new Error(`Named parameter '${e}' is missing`)},Ke=Symbol("void"),$e={};function qe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{$e[e]=qe})),Ge.console=console.hasOwnProperty("log")?console:$e;const Xe={debug:qe,error:Ge.console.error||qe,info:Ge.console.info||qe,log:Ge.console.log||qe,warn:Ge.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st("_"===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return e&&e.isA?e.getState():e}function gt(e){setTimeout(e,0)}function mt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function ht(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++He),"classHierarchy"in t){if(!(t.classHierarchy instanceof We)){const e=new We;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new We("vtkObject");function r(e){n[e]=null}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++He,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et("instance deleted - cannot call any method"),null;const o=n.length;return n.push(e),function(e){return Object.freeze({unsubscribe:function(){r(e)}})}(o)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(ft):function(e){return Object.values(ot).some((t=>e instanceof t))}(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort();Object.keys(o).sort().forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const vt={object(e,t,n){return function(){return{...t[n.name]}}}};function Tt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=vt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const yt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&tt('Setter of type "object" with a single "param" field is not supported');const r=`_on${lt(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function bt(e){if("object"==typeof e){const t=yt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function xt(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${lt(n.name)}`]=bt(n)(e,t):e[`set${lt(n)}`]=bt(n)(e,t)}))}function Ct(e,t,n){Tt(e,t,n),xt(e,t,n)}function St(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function At(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function It(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;St(e,t,n),At(e,t,n,r,o)}function wt(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Ot(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et("instance deleted - cannot call any method"):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(ze):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(ze):t.inputConnection=[],t.output?t.output=t.output.map(ze):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(ze):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?et("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.requestData&&!e.isDeleted()&&e.shouldUpdate()&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Pt=Symbol("Event abort");function Rt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Pt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et("instance deleted - cannot call any method"),null;const s=a++;return r.push([s,e,o]),r.sort(((e,t)=>t[2]-e[2])),function(e){return Object.freeze({unsubscribe:function(){i(e)}})}(s)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Mt(e,t){const n=function(){const t={};return e(t,{},arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}),Object.freeze(t)};return t&&ze.register(t,n),n}function Et(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Vt(e){return e&&e.isA&&e.isA("vtkObject")}function Dt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Vt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Dt(e,t,n,r)})):Dt(o,t,n,r)}))}return n}function Lt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=n&&!o;clearTimeout(o),o=setTimeout((()=>{o=null,n||e.apply(l,i)}),t),c&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function Bt(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Nt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let Ft=1;const _t="__root__";function kt(e,t){Nt(e,t);const n=e.delete;t.proxyId=""+Ft++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),Tt(e,t,["proxyId","proxyGroup","proxyName"]),Ct(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:_t;const r=[],a=t.proxyId,s=function(){return o[arguments.length>0&&void 0!==arguments[0]?arguments[0]:_t]}(n)||[];for(let t=0;t<s.length;t++){const n=s[t],o=e[`get${lt(n)}`],l={id:a,name:n,value:o?o():void 0},c=i(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,_t),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,_t),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!function(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}const c={bind:function(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}},unbind:l,unsubscribe:function(){for(;o.length;)o.pop().subscription.unsubscribe()},persistent:n};return t.propertyLinkMap[e]=c,c},e.listPropertyNames=()=>i().map((e=>e.name)),e.getPropertyByName=e=>i().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:i()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,gt((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function Gt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Ut(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&Tt(e,t,a)}function zt(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var Wt={algo:Ot,capitalize:st,chain:Et,debounce:Lt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Rt,EVENT_ABORT:Pt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:Tt,getArray:St,getCurrentGlobalMTime:function(){return He},getStateArrayMapFunc:ft,isVtkObject:Vt,keystore:Nt,measurePromiseExecution:mt,moveToProtected:wt,newInstance:Mt,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:zt,obj:ht,proxy:kt,proxyPropertyMapping:Gt,proxyPropertyState:Ut,safeArrays:pt,set:xt,setArray:At,setGet:Ct,setGetArray:It,setImmediate:gt,setLoggerFunction:Ye,throttle:Bt,traverseInstanceTree:Dt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt,objectSetterMap:yt,requiredParam:je},Ht=Object.freeze({__proto__:null,requiredParam:je,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:gt,measurePromiseExecution:mt,obj:ht,get:Tt,set:xt,setGet:Ct,getArray:St,setArray:At,setGetArray:It,moveToProtected:wt,algo:Ot,EVENT_ABORT:Pt,event:Rt,newInstance:Mt,chain:Et,isVtkObject:Vt,traverseInstanceTree:Dt,debounce:Lt,throttle:Bt,keystore:Nt,proxy:kt,proxyPropertyMapping:Gt,proxyPropertyState:Ut,normalizeWheel:zt,default:Wt});const{vtkErrorMacro:jt}=Wt,Kt={renderable:null,myFactory:null,children:[],visited:!1};function $t(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kt,n),Wt.obj(e,t),Wt.event(e,t,"event"),t._renderableChildMap=new Map,Wt.get(e,t,["visited"]),Wt.setGet(e,t,["_parent","renderable","myFactory"]),Wt.getArray(e,t,["children"]),Wt.moveToProtected(e,t,["parent"]),function(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>t._parent?t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n&&n.length)for(let o=0;o<n.length;++o){const a=n[o],i=e.addMissingNode(a);if(r&&void 0!==i&&t.children[o]!==i)for(let e=o+1;e<t.children.length;++e)if(t.children[e]===i){t.children.splice(e,1),t.children.splice(o,0,i);break}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return jt("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}(e,t)}var qt={newInstance:Wt.newInstance($t,"vtkViewNode"),extend:$t,PASS_TYPES:["Build","Render"]};const Xt={};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),Wt.obj(e,t),function(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}(e,t)}var Zt={newInstance:Wt.newInstance(Yt,"vtkViewNodeFactory"),extend:Yt};const Qt=Object.create(null);function Jt(e,t){Qt[e]=t}const en={};function tn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,en,n),t.overrides=Qt,Zt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}(0,t)}var nn={newInstance:Wt.newInstance(tn,"vtkOpenGLViewNodeFactory"),extend:tn};const rn={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const on=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rn,n),qt.extend(e,t,n),t.keyMatrixTime={},ht(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},Ct(e,t,["context","keyMatrixTime"]),function(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){p(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),le(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),me(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),h(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();p(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),h(t.keyMatrices.vcpc,t.keyMatrices.vcpc),b(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}(e,t)}));Jt("vtkCamera",on);const{vtkDebugMacro:an}=Ht,sn={context:null,_openGLRenderWindow:null,selector:null};const ln=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sn,n),qt.extend(e,t,n),Tt(e,t,["shaderCache"]),Ct(e,t,["selector"]),wt(0,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps(),!0),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(an("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}),"vtkOpenGLRenderer");Jt("vtkRenderer",ln);const cn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const un=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cn,n),qt.extend(e,t,n),t.keyMatrixTime={},ht(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:fe(new Float64Array(9)),mcwc:m(new Float64Array(16))},Ct(e,t,["context"]),Tt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),p(t.keyMatrices.mcwc,t.renderable.getMatrix()),h(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?fe(t.keyMatrices.normalMatrix):(le(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),me(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}));Jt("vtkActor",un);const dn={context:null,activeTextures:null};const pn=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dn,n),qt.extend(e,t,n),Ct(e,t,["context"]),Tt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}(e,t)}));function fn(){var e=new s(3);return s!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function gn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function mn(e,t,n){var r=new s(3);return r[0]=e,r[1]=t,r[2]=n,r}function hn(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function vn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Tn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function yn(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function bn(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function xn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Cn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function Sn(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function An(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function In(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function wn(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function On(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Pn(e,t){var n=e[0],r=e[1],o=e[2],a=t[0],s=t[1],l=t[2];return Math.abs(n-a)<=i*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(r-s)<=i*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=i*Math.max(1,Math.abs(o),Math.abs(l))}Jt("vtkActor2D",pn);var Rn=Tn,Mn=yn,En=(fn(),Math.sqrt(50)),Vn=Math.sqrt(10),Dn=Math.sqrt(2);function Ln(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=En?10:a>=Vn?5:a>=Dn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=En?10:a>=Vn?5:a>=Dn?2:1)}function Bn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Nn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=Bn,r=(t,n)=>Bn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Fn=Nn(Bn),_n=Fn.right;Fn.left,Nn((function(e){return null===e?NaN:+e})).center;var kn=_n;function Gn(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function Un(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function zn(){}var Wn=.7,Hn=1/Wn,jn="\\s*([+-]?\\d+)\\s*",Kn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",$n="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",qn=/^#([0-9a-f]{3,8})$/,Xn=new RegExp(`^rgb\\(${jn},${jn},${jn}\\)$`),Yn=new RegExp(`^rgb\\(${$n},${$n},${$n}\\)$`),Zn=new RegExp(`^rgba\\(${jn},${jn},${jn},${Kn}\\)$`),Qn=new RegExp(`^rgba\\(${$n},${$n},${$n},${Kn}\\)$`),Jn=new RegExp(`^hsl\\(${Kn},${$n},${$n}\\)$`),er=new RegExp(`^hsla\\(${Kn},${$n},${$n},${Kn}\\)$`),tr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function nr(){return this.rgb().formatHex()}function rr(){return this.rgb().formatRgb()}function or(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=qn.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?ar(t):3===n?new lr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?ir(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?ir(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=Xn.exec(e))?new lr(t[1],t[2],t[3],1):(t=Yn.exec(e))?new lr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=Zn.exec(e))?ir(t[1],t[2],t[3],t[4]):(t=Qn.exec(e))?ir(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=Jn.exec(e))?gr(t[1],t[2]/100,t[3]/100,1):(t=er.exec(e))?gr(t[1],t[2]/100,t[3]/100,t[4]):tr.hasOwnProperty(e)?ar(tr[e]):"transparent"===e?new lr(NaN,NaN,NaN,0):null}function ar(e){return new lr(e>>16&255,e>>8&255,255&e,1)}function ir(e,t,n,r){return r<=0&&(e=t=n=NaN),new lr(e,t,n,r)}function sr(e,t,n,r){return 1===arguments.length?((o=e)instanceof zn||(o=or(o)),o?new lr((o=o.rgb()).r,o.g,o.b,o.opacity):new lr):new lr(e,t,n,null==r?1:r);var o}function lr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function cr(){return`#${fr(this.r)}${fr(this.g)}${fr(this.b)}`}function ur(){const e=dr(this.opacity);return`${1===e?"rgb(":"rgba("}${pr(this.r)}, ${pr(this.g)}, ${pr(this.b)}${1===e?")":`, ${e})`}`}function dr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function pr(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function fr(e){return((e=pr(e))<16?"0":"")+e.toString(16)}function gr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new hr(e,t,n,r)}function mr(e){if(e instanceof hr)return new hr(e.h,e.s,e.l,e.opacity);if(e instanceof zn||(e=or(e)),!e)return new hr;if(e instanceof hr)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new hr(i,s,l,e.opacity)}function hr(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function vr(e){return(e=(e||0)%360)<0?e+360:e}function Tr(e){return Math.max(0,Math.min(1,e||0))}function yr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function br(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}Gn(zn,or,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:nr,formatHex:nr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return mr(this).formatHsl()},formatRgb:rr,toString:rr}),Gn(lr,sr,Un(zn,{brighter(e){return e=null==e?Hn:Math.pow(Hn,e),new lr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Wn:Math.pow(Wn,e),new lr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new lr(pr(this.r),pr(this.g),pr(this.b),dr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:cr,formatHex:cr,formatHex8:function(){return`#${fr(this.r)}${fr(this.g)}${fr(this.b)}${fr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:ur,toString:ur})),Gn(hr,(function(e,t,n,r){return 1===arguments.length?mr(e):new hr(e,t,n,null==r?1:r)}),Un(zn,{brighter(e){return e=null==e?Hn:Math.pow(Hn,e),new hr(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Wn:Math.pow(Wn,e),new hr(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new lr(yr(e>=240?e-240:e+120,o,r),yr(e,o,r),yr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new hr(vr(this.h),Tr(this.s),Tr(this.l),dr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=dr(this.opacity);return`${1===e?"hsl(":"hsla("}${vr(this.h)}, ${100*Tr(this.s)}%, ${100*Tr(this.l)}%${1===e?")":`, ${e})`}`}}));var xr=e=>()=>e;function Cr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):xr(isNaN(e)?t:e)}var Sr=function e(t){var n=function(e){return 1==(e=+e)?Cr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):xr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=sr(e)).r,(t=sr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Cr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Ar(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=sr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function Ir(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Dr(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function wr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Or(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Pr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Dr(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Ar((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return br((n-r/t)*t,i,o,a,s)}})),Ar((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return br((n-r/t)*t,o,a,i,s)}}));var Rr=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Mr=new RegExp(Rr.source,"g");function Er(e,t){var n,r,o,a=Rr.lastIndex=Mr.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=Rr.exec(e))&&(r=Mr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Or(n,r)})),a=Mr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Vr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Dr(e,t){var n,r=typeof t;return null==t||"boolean"===r?xr(t):("number"===r?Or:"string"===r?(n=or(t))?(t=n,Sr):Er:t instanceof or?Sr:t instanceof Date?wr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Vr:Array.isArray(t)?Ir:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Pr:Or)(e,t)}function Lr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Br(e){return+e}var Nr=[0,1];function Fr(e){return e}function _r(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function kr(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=_r(o,r),a=n(i,a)):(r=_r(r,o),a=n(a,i)),function(e){return a(r(e))}}function Gr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=_r(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=kn(e,t,1,r)-1;return a[n](o[n](t))}}function Ur(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var zr,Wr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function Hr(e){if(!(t=Wr.exec(e)))throw new Error("invalid format: "+e);var t;return new jr({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function jr(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function Kr(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function $r(e){return(e=Kr(Math.abs(e)))?e[1]:NaN}function qr(e,t){var n=Kr(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}Hr.prototype=jr.prototype,jr.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var Xr={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>qr(100*e,t),r:qr,s:function(e,t){var n=Kr(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(zr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+Kr(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function Yr(e){return e}var Zr,Qr,Jr,eo=Array.prototype.map,to=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function no(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Ln(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=En?o*=10:a>=Vn?o*=5:a>=Dn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=Hr(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor($r(t)/3)))-$r(Math.abs(e)))}(a,i))||(r.precision=o),Jr(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,$r(t)-$r(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-$r(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return Qr(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Ln(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function ro(){var e=function(){var e,t,n,r,o,a,i=Nr,s=Nr,l=Dr,c=Fr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==Fr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?Gr:kr,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Or)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Br),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=Lr,u()},d.clamp=function(e){return arguments.length?(c=!!e||Fr,u()):c!==Fr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(Fr,Fr);return e.copy=function(){return t=e,ro().domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());var t},Ur.apply(e,arguments),no(e)}Zr=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?Yr:(t=eo.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?Yr:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(eo.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=Hr(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,T=e.type;"n"===T?(m=!0,T="g"):Xr[T]||(void 0===h&&(h=12),v=!0,T="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var y="$"===p?o:"#"===p&&/[boxX]/.test(T)?"0"+T.toLowerCase():"",b="$"===p?a:/[%p]/.test(T)?l:"",x=Xr[T],C=/[defgprs%]/.test(T);function S(e){var o,a,l,p=y,S=b;if("c"===T)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===T?to[8+zr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(T)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=Hr(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor($r(t)/3))),o=Math.pow(10,-r),a=to[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),Qr=Zr.format,Jr=Zr.formatPrefix;var oo=n(318);const ao=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],io=[1,0,0,0,1,0,0,0,1],so=1e-6,lo=1e-12,{vtkErrorMacro:co,vtkWarningMacro:uo}=Wt;let po=0;function fo(e){return()=>co(`vtkMath::${e} - NOT IMPLEMENTED`)}function go(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function mo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function ho(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function vo(e){return e/180*Math.PI}function To(e){return 180*e/Math.PI}const{round:yo,floor:bo,ceil:xo,min:Co,max:So}=Math;const Ao=fo("ceilLog2"),Io=fo("factorial");function wo(e){let t=1;for(;t<e;)t*=2;return t}function Oo(e){return e===wo(e)}const Po=fo("gaussian");function Ro(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Mo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function Eo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Vo(e,t){return e[0]*=t,e[1]*=t,e}function Do(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function Lo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Bo(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function No(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function Fo(e){const t=No(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function _o(e){const t=No(e,3);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t,e[3]/=t),t}function ko(e,t){return e[0]*t[0]+e[1]*t[1]}function Go(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Uo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function zo(e){const t=Uo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Wo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function Ho(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function jo(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function Ko(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function $o(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function qo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:so;return e.length===t.length&&e.every((function(e,r){return Math.abs(e-t[r])<=n}))}const Xo=qo;function Yo(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function Zo(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function Qo(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function Jo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ea(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=Jo(e[0],n),t[1]=Jo(e[1],n),t[2]=Jo(e[2],n),t}function ta(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,T,y;const b=ho(t),x=ho(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(Zo(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),T=1/Math.sqrt(1+p*p),m=p*T,f=m/(1+T),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return uo("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,y=n[i],o=a+1;o<t;o++)(n[o]>=y||Math.abs(n[o]-y)<lo)&&(i=o,y=n[i]);i!==a&&(n[i]=n[a],n[a]=y,mo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function na(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];ta([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function ra(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=ho(3),r=ho(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(mo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,mo(t,3,1,2)),r[2]=2;let u=0;if($o(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=ho(4);if(na(t,d),Qo(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&mo(t,3,r[1],1),0!==r[0]&&mo(t,3,r[0],0)}function oa(e,t,n){let r,o,a,i,s,l;if(ta([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(Ko(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,go(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Bo([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);Fo(e);const c=Bo(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void Ko(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,go(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,go(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);$o(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),Ko(n,n)}else Yo(n)}function aa(e,t,n){let r,o,a,i,s,l,c,u=0;const d=ho(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return uo("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=lo)return uo("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ia(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function sa(e,t,n){if(2===n){const n=ho(2),r=Wo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=ho(n);return 0===aa(e,r,n)?0:(ia(e,r,t,n),1)}function la(e,t,n){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const o=(arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)||ho(n),a=r||ho(n);if(0===aa(e,o,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)a[e]=0;a[r]=1,ia(e,o,a,n);for(let e=0;e<n;e++)t[e*n+r]=a[e]}return t}function ca(e,t,n,r){if(e<n)return uo("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=ho(n*n),l=ho(n),c=ho(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(ta(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ua(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?1/3+s*(i-o)/(l-c):2/3+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function da(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function pa(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function fa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function ga(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function ma(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function ha(e,t){const n=[0,0,0];ma(e,n),fa(n,t)}function va(e,t){const n=[0,0,0];pa(e,n),ga(n,t)}function Ta(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function ya(e){return!(e[1]-e[0]<0)}function ba(e,t,n){return e<t?t:e>n?n:e}function xa(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=ba(e[0],t[0],n[0]),r[1]=ba(e[1],t[1],n[1]),r[2]=ba(e[2],t[2],n[2]),r}const Ca=fo("GetScalarTypeFittingRange"),Sa=fo("GetAdjustedScalarRange");const Aa=e=>!Number.isFinite(e),{isFinite:Ia,isNaN:wa}=Number,Oa=wa;function Pa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function Ra(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ma(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ea(e){return Math.round(255*e)}var Va,Da={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:vo,degreesFromRadians:To,round:yo,floor:bo,ceil:xo,ceilLog2:Ao,min:Co,max:So,arrayMin:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)e[r]<n&&(n=e[r]);return n},arrayMax:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=-1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)n<e[r]&&(n=e[r]);return n},arrayRange:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0,r=-1/0;for(let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=e.length;o<a;o+=t)e[o]<n&&(n=e[o]),r<e[o]&&(r=e[o]);return[n,r]},isPowerOfTwo:Oo,nearestPowerOfTwo:wo,factorial:Io,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=ho(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){oo(`${e}`,{global:!0}),po=e},getSeed:function(){return po},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e+((arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)-e)*Math.random()},gaussian:Po,add:Ro,subtract:Mo,multiplyScalar:Eo,multiplyScalar2D:Vo,multiplyAccumulate:Do,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:Lo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Bo,norm:No,normalize:Fo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=Lo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=Lo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return Eo(n,o),!0},projectVector2D:function(e,t,n){const r=ko(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=ko(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Vo(n,o),!0},distance2BetweenPoints:Go,angleBetweenVectors:function(e,t){const n=[0,0,0];return Bo(e,t,n),Math.atan2(No(n),Lo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:ko,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Uo,normalize2D:zo,determinant2x2:Wo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(go(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,go(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Wo(s,u,l,d),f=-Wo(i,c,l,d),g=+Wo(i,c,s,u),m=-Wo(o,u,a,d),h=+Wo(r,c,a,d),v=-Wo(r,c,o,u),T=+Wo(o,s,a,l),y=-Wo(r,i,a,l),b=+Wo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+T*t[2],S=f*t[0]+h*t[1]+y*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:Ho,multiply3x3_mat3:jo,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&co("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:Ko,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Wo(i,c,s,u),p=-Wo(a,l,s,u),f=+Wo(a,l,i,c),g=-Wo(r,c,o,u),m=+Wo(n,l,o,u),h=-Wo(n,l,r,c),v=+Wo(r,i,o,s),T=-Wo(n,a,o,s),y=+Wo(n,a,r,i),b=n*d+r*p+o*f;0===b&&uo("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=T/b,t[8]=y/b},identity3x3:Yo,identity:Zo,isIdentity:function(e){return Xo(e,ao,arguments.length>1&&void 0!==arguments[1]?arguments[1]:so)},isIdentity3x3:function(e){return Xo(e,io,arguments.length>1&&void 0!==arguments[1]?arguments[1]:so)},determinant3x3:$o,quaternionToMatrix3x3:Qo,areEquals:qo,areMatricesEqual:Xo,roundNumber:Jo,roundVector:ea,matrix3x3ToQuaternion:na,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],T=e[3]*t[3];n[0]=r-l-f-T,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:ra,diagonalize3x3:oa,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=$o(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];ra(a,t),Ko(a,a),jo(a,t,r),oa(r,n,r),jo(t,r,t),Ko(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:sa,invertMatrix:la,luFactorLinearSystem:aa,luSolveLinearSystem:ia,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return ta(e,3,t,n)},jacobiN:ta,solveHomogeneousLeastSquares:ca,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return uo("Insufficient number of samples. Underdetermined."),0;const s=ho(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>lo&&(p=0,s[u]=0);if(p&&1===o)return uo("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),ca(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=ho(n),f=ca(e,t,n,l));const m=ho(n*n),h=ho(n*n),v=ho(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const T=la(m,h,n);if(T)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&T:T},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ua,hsv2rgb:da,lab2xyz:pa,xyz2lab:fa,xyz2rgb:ga,rgb2xyz:ma,rgb2lab:ha,lab2rgb:va,uninitializeBounds:Ta,areBoundsInitialized:ya,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:ba,clampVector:xa,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Ca,getAdjustedScalarRange:Sa,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=ho(3),a=ho(3),i=ho(3),s=ho(3),l=ho(3),c=ho(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=No(s),d=No(l),p=No(i),f=ho(3);Bo(o,a,f);const g=No(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*Lo(o,c)/h,T=p*p*Lo(s,a)/h,y=u*u*Lo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+T*t[o]+y*n[o];return m},inf:1/0,negInf:-1/0,isInf:Aa,isNan:wa,isNaN:wa,isFinite:Ia,createUninitializedBounds:Pa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:Ra,floatToHex2:Ma,floatRGB2HexCode:function(e){return`${arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#"}${e.map(Ma).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ea).join(", ")})`:`rgba(${Ea(e[0]||0)}, ${Ea(e[1]||0)}, ${Ea(e[2]||0)}, ${e[3]||0})`}};function La(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Ba(){var e=new s(4);return s!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Na(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function Fa(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Va=new s(4),s!=Float32Array&&(Va[0]=0,Va[1]=0,Va[2]=0,Va[3]=0);var _a=function(e,t,n,r){var o=new s(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};fn(),mn(1,0,0),mn(0,1,0),Ba(),Ba(),se();const ka={};function Ga(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ka,n),Wt.obj(e,t),Wt.setGet(e,t,["transform"]),function(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{Wt.vtkErrorMacro("not implemented")}}(e,t)}var Ua={newInstance:Wt.newInstance(Ga,"vtkImplicitFunction"),extend:Ga};const za=1e-6,Wa="coincide",Ha="disjoint";function ja(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function Ka(e,t,n,r){const o=[];Mo(e,t,o);const a=Lo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function $a(e,t,n){const r=Lo(e,t);let o=Lo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function qa(e,t,n,r){const o=[];Mo(e,t,o);const a=Lo(n,o),i=Lo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Xa(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Mo(t,e,a),Mo(n,e,i);const s=Lo(r,i),l=Lo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*za:s*za,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Ya(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Bo(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<za){const r=[];return Mo(e,n,r),0===Lo(t,r)?o.error=Wa:o.error=Ha,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-Lo(t,e),u=-Lo(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Ro(l,a,o.l1),o.intersection=!0,o}const Za={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:ja,projectPoint:Ka,projectVector:$a,generalizedProjectPoint:qa,intersectWithLine:Xa,intersectWithPlane:Ya,DISJOINT:Ha,COINCIDE:Wa},Qa={normal:[0,0,1],origin:[0,0,0]};function Ja(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qa,n),Ua.extend(e,t,n),Wt.setGetArray(e,t,["normal","origin"],3),function(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>ja(e,t.origin,t.normal),e.projectPoint=(e,n)=>{Ka(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>$a(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{qa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Xa(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Ya(e,n,t.origin,t.normal)}(e,t)}var ei={newInstance:Wt.newInstance(Ja,"vtkPlane"),extend:Ja,...Za};const ti=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function ni(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ri(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function oi(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function ai(e){return oi(e,ti)}function ii(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function si(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)ii(e,...t[n]);else for(let n=0;n<t.length;n+=3)ii(e,...t.slice(n,n+3));return e}function li(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function ci(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function ui(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function di(e,t){return null==t?function(e){const t=[0,0,0];let n=-1,r=0,o=0;for(let a=0;a<3;++a)o=e[2*a+1]-e[2*a],o>r&&(r=o,n=a),t[a]=o>0?1:0;if(n<0)return di(e,.5);for(let n=0;n<3;++n)if(!t[n]){const t=.005*r;e[2*n]-=t,e[2*n+1]+=t}return e}(e):(e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e)}function pi(e,t,n,r){return!!ri(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function fi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function gi(e,t){return e[2*t+1]-e[2*t]}function mi(e){return[gi(e,0),gi(e,1),gi(e,2)]}function hi(e){return e.slice(0,2)}function vi(e){return e.slice(2,4)}function Ti(e){return e.slice(4,6)}function yi(e){const t=mi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function bi(e){if(ri(e)){const t=mi(e);return t[0]*t[0]+t[1]*t[1]+t[2]*t[2]}return null}function xi(e){const t=bi(e);return null!==t?Math.sqrt(t):null}function Ci(e){return[e[0],e[2],e[4]]}function Si(e){return[e[1],e[3],e[5]]}function Ai(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Ii(e,t){return t[0]=[e[0],e[2],e[4]],t[1]=[e[0],e[2],e[5]],t[2]=[e[0],e[3],e[4]],t[3]=[e[0],e[3],e[5]],t[4]=[e[1],e[2],e[4]],t[5]=[e[1],e[2],e[5]],t[6]=[e[1],e[3],e[4]],t[7]=[e[1],e[3],e[5]],t}function wi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Ii(e,[]);for(let e=0;e<r.length;++e)In(r[e],r[e],t);return ai(n),si(n,r)}function Pi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Ri(e,t,n,r){const o=[].concat(ti),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=Lo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=Lo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=Lo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Mi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ei.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!ri(e)||!ri(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Di(e,t){if(!ri(e)||!ri(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Li(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Bi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ei.evaluate(n,t,l)}let i=2;for(;i--&&!(Ai(o[r[i][0]],o[r[i][4]])&&Ai(o[r[i][1]],o[r[i][5]])&&Ai(o[r[i][2]],o[r[i][6]])&&Ai(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}function Ni(e,t){for(let e=0;e<3;++e)t[e]=t[e]<1?1:t[e];let n=t[0]*t[1]*t[2];for(;n>e;){for(let e=0;e<3;++e)t[e]=t[e]>1?t[e]-1:1;n=t[0]*t[1]*t[2]}}function Fi(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];t=t<=0?1:t;let o=0;const a=[0,0,0];let i=-1,s=0;const l=mi(e),c=l[0]+l[1]+l[2],u=c*(.001/3);for(let e=0;e<3;++e)l[e]>s&&(i=e,s=l[e]),l[e]>u?(a[e]=1,o++):a[e]=0;const d=Ci(e),p=Si(e);if(o<1)return n[0]=1,n[1]=1,n[2]=1,r[0]=d[0]-.5,r[1]=p[0]+.5,r[2]=d[1]-.5,r[3]=p[1]+.5,r[4]=d[2]-.5,r[5]=p[2]+.5,1;let f=t;f/=a[0]?l[0]/c:1,f/=a[1]?l[1]/c:1,f/=a[2]?l[2]/c:1,f**=1/o;for(let e=0;e<3;++e)n[e]=a[e]?Math.floor(f*l[e]/c):1,n[e]=n[e]<1?1:n[e];Ni(t,n);const g=.5*l[i]/n[i];for(let e=0;e<3;++e)a[e]?(r[2*e]=d[e],r[2*e+1]=p[e]):(r[2*e]=d[e]-g,r[2*e+1]=p[e]+g);return n[0]*n[1]*n[2]}function _i(e,t){if(e[0]>=t[0]&&e[0]<=t[1]&&e[1]>=t[2]&&e[1]<=t[3]&&e[2]>=t[4]&&e[2]<=t[5])return 0;const n=[0,0,0];return e[0]<t[0]?n[0]=t[0]-e[0]:e[0]>t[1]&&(n[0]=e[0]-t[1]),e[1]<t[2]?n[1]=t[2]-e[1]:e[1]>t[3]&&(n[1]=e[1]-t[3]),e[2]<t[4]?n[2]=t[4]-e[2]:e[2]>t[5]&&(n[2]=e[2]-t[5]),Lo(n,n)}class ki{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ti))}getBounds(){return this.bounds}equals(e){return ni(this.bounds,e)}isValid(){return ri(this.bounds)}setBounds(e){return oi(this.bounds,e)}reset(){return ai(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return ii(this.bounds,...t)}addPoints(e){return si(this.bounds,e)}addBounds(e,t,n,r,o,a){return li(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return ci(this.bounds,e,t,n)}setMaxPoint(e,t,n){return ui(this.bounds,e,t,n)}inflate(e){return di(this.bounds,e)}scale(e,t,n){return pi(this.bounds,e,t,n)}getCenter(){return fi(this.bounds)}getLength(e){return gi(this.bounds,e)}getLengths(){return mi(this.bounds)}getMaxLength(){return yi(this.bounds)}getDiagonalLength(){return xi(this.bounds)}getDiagonalLength2(){return bi(this.bounds)}getMinPoint(){return Ci(this.bounds)}getMaxPoint(){return Si(this.bounds)}getXRange(){return hi(this.bounds)}getYRange(){return vi(this.bounds)}getZRange(){return Ti(this.bounds)}getCorners(e){return Ii(this.bounds,e)}computeCornerPoints(e,t){return wi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Ri(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Pi(this.bounds,e)}cutWithPlane(e,t){return Bi(this.bounds,e,t)}intersectBox(e,t,n,r){return Mi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Di(this.bounds,e)}containsPoint(e,t,n){return Li(this.bounds,e,t,n)}contains(e){return Di(this.bounds,e)}computeDivisions(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return Fi(this.bounds,e,t,n)}distance2ToBounds(e){return _i(e,this.bounds)}}var Gi={newInstance:function(e){const t=e&&e.bounds;return new ki(t)},equals:ni,isValid:ri,setBounds:oi,reset:ai,addPoint:ii,addPoints:si,addBounds:li,setMinPoint:ci,setMaxPoint:ui,inflate:di,scale:pi,scaleAboutCenter:function(e,t,n,r){if(!ri(e))return!1;const o=fi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],pi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:fi,getLength:gi,getLengths:mi,getMaxLength:yi,getDiagonalLength:xi,getDiagonalLength2:bi,getMinPoint:Ci,getMaxPoint:Si,getXRange:hi,getYRange:vi,getZRange:Ti,getCorners:Ii,computeCornerPoints:wi,computeLocalBounds:Ri,transformBounds:Oi,computeScale3:Pi,cutWithPlane:Bi,intersectBox:Mi,intersectPlane:Ei,intersect:Vi,intersects:Di,containsPoint:Li,contains:function(e,t){return!!Di(e,t)&&!!Li(e,...Ci(t))&&!!Li(e,...Si(t))},computeDivisions:Fi,clampDivisions:Ni,distance2ToBounds:_i,INIT_BOUNDS:ti},Ui={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:zi}=Ui;function Wi(e){return()=>Wt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}const Hi={allocatedRenderTime:10,coordinateSystem:zi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function ji(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hi,n),Wt.obj(e,t),Wt.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),Wt.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),Wt.moveToProtected(e,t,["parentProp"]),function(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Wi("pick"),e.hasKey=Wi("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(zi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(zi.DISPLAY)}(e,t)}var Ki={newInstance:Wt.newInstance(ji,"vtkProp"),extend:ji,...Ui};const $i={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[...Gi.INIT_BOUNDS],properties:[],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function qi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$i,n),Ki.extend(e,t,n),t.matrixMTime={},Wt.obj(t.matrixMTime),Wt.get(e,t,["isIdentity"]),Wt.getArray(e,t,["orientation"]),Wt.setGetArray(e,t,["origin","position","scale"],3),Wt.setGet(e,t,["properties"]),t.matrix=m(new Float64Array(16)),t.rotation=m(new Float64Array(16)),t.userMatrix=m(new Float64Array(16)),t.transform=null,function(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Ba();F(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>i?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[To(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){return F(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t.rotation)},e.rotateX=n=>{0!==n&&(A(t.rotation,t.rotation,vo(n)),e.modified())},e.rotateY=n=>{0!==n&&(I(t.rotation,t.rotation,vo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(w(t.rotation,t.rotation,vo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=vo(n),s=Ba();Na(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),b(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=G(new Float64Array(16),n);b(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],m(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setOrientationFromQuaternion=n=>{const r=u();return G(r,n),!Xo(r,t.rotation)&&(t.rotation=r,e.modified(),!0)},e.setUserMatrix=n=>!Xo(t.userMatrix,n)&&(p(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){m(t.matrix),t.userMatrix&&b(t.matrix,t.matrix,t.userMatrix),x(t.matrix,t.matrix,t.origin),x(t.matrix,t.matrix,t.position),b(t.matrix,t.matrix,t.rotation),C(t.matrix,t.matrix,t.scale),x(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),h(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getBoundsByReference=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n,t.bounds=[...Gi.INIT_BOUNDS],t.boundsMTime.modified(),n;if(!t.mapperBounds||!n.every(((e,r)=>n[r]===t.mapperBounds[r]))||e.getMTime()>t.boundsMTime.getMTime()){Wt.vtkDebugMacro("Recomputing bounds..."),t.mapperBounds=n,e.computeMatrix();const r=new Float64Array(16);h(r,t.matrix),Gi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}return t.bounds},e.getBounds=()=>{const t=e.getBoundsByReference();try{return[...t]}catch{return t}},e.getCenter=()=>Gi.getCenter(t.bounds),e.getLength=()=>Gi.getLength(t.bounds),e.getXRange=()=>Gi.getXRange(t.bounds),e.getYRange=()=>Gi.getYRange(t.bounds),e.getZRange=()=>Gi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()})),e.getProperty=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null==t.properties[n]&&(t.properties[n]=e.makeProperty?.()),t.properties[n]},e.getProperties=()=>(0===t.properties.length&&(t.properties[0]=e.makeProperty?.()),t.properties),e.setProperty=(e,n)=>{const r=Number.isInteger(e),[o,a]=r?[e,n]:[0,e];return t.properties[o]!==a&&(t.properties[o]=a,!0)},e.getMTime=()=>{let e=t.mtime;return t.properties.forEach((t=>{if(null!==t){const n=t.getMTime();e=n>e?n:e}})),e}}(e,t)}var Xi={newInstance:Wt.newInstance(qi,"vtkProp3D"),extend:qi};const Yi={FLAT:0,GOURAUD:1,PHONG:2},Zi={POINTS:0,WIREFRAME:1,SURFACE:2};var Qi={Shading:Yi,Representation:Zi,Interpolation:Yi};const{Representation:Ji,Interpolation:es}=Qi;function ts(e){return()=>Wt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}const ns={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:es.GOURAUD,representation:Ji.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null,ORMTexture:null,RMTexture:null};function rs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ns,n),Wt.obj(e,t),Wt.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture","ORMTexture","RMTexture"]),Wt.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),function(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ts("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ts("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(es.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(es.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(es.PHONG),e.getInterpolationAsString=()=>Wt.enumToString(es,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(Ji.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(Ji.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(Ji.POINTS),e.getRepresentationAsString=()=>Wt.enumToString(Ji,t.representation)}(e,t)}var os={newInstance:Wt.newInstance(rs,"vtkProperty"),extend:rs,...Qi};const as={mapper:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1};function is(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,as,n),Xi.extend(e,t,n),t.boundsMTime={},Wt.obj(t.boundsMTime),Wt.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),function(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(t.properties[0]||e.getProperty(),!e.getIsOpaque()),e.makeProperty=os.newInstance,e.getMTime=()=>{let e=n.getMTime();if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}(e,t)}var ss={newInstance:Wt.newInstance(is,"vtkActor"),extend:is};const ls={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},cs={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var us={DefaultDataType:cs.FLOAT,DataTypeByteSize:ls,VtkDataTypes:cs};const{vtkErrorMacro:ds}=Ht,{DefaultDataType:ps}=us;function fs(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function gs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return fs(r,0,1)}return fs(e,t<0?0:t,n)}function ms(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function hs(e){return Object.prototype.toString.call(e).slice(8,-1)}const vs={computeRange:gs,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get(){return{min:e,max:t,count:n,sum:r,mean:r/n}},getRange(){return{min:e,max:t}}}},fastComputeRange:fs,getDataType:hs,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=No(r,t);a>n&&(n=a)}return n}},Ts={name:"",numberOfComponents:1,dataType:ps,rangeTuple:[0,0]};function ys(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Ts,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=hs(t.values)),ht(e,t),xt(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");!function(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.allocate=t=>{n(e.getNumberOfTuples()+t)},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>(e.resize(0),e),e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=ms(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=gs(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=ms(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.getRanges=function(){if(arguments.length>0&&void 0!==arguments[0]&&!arguments[0])return structuredClone(t.ranges);const n=[];for(let r=0;r<t.numberOfComponents;r++){const[t,o]=e.getRange(r),a={min:t,max:o};n.push(a)}if(t.numberOfComponents>1){const[t,r]=e.getRange(-1),o={min:t,max:r};n.push(o)}return n},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-6;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:1)*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>bs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=hs(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),t.ranges=structuredClone(n.getRanges()),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||ds("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}(e,t)}const bs=Mt(ys,"vtkDataArray");var xs={newInstance:bs,extend:ys,...vs,...us};const Cs={clippingPlanes:[]};var Ss=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cs,n),Wt.obj(e,t),Wt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),function(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}Wt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}(e,t)},As=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Gi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e}))(n)),Ss(e,t,n),Wt.setGet(e,t,["viewSpecificProperties"]),function(e,t){e.getBounds=()=>(Wt.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Pa()),e.getCenter=()=>{const n=e.getBounds();return t.center=Gi.isValid(n)?Gi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Gi.getDiagonalLength(t)}}(e,t)};const{vtkErrorMacro:Is,vtkWarningMacro:ws}=Wt,Os={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Ps(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Os,n),Wt.obj(e,t),function(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:ze(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.getArrays().map((e=>({data:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Is("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=xs.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:Wt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),ws("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Is("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=xs.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:Wt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}(e,t)}var Rs={newInstance:Wt.newInstance(Ps,"vtkFieldData"),extend:Ps};const Ms={DEFAULT:0,SINGLE:1,DOUBLE:2};var Es={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Ms,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Vs,AttributeCopyOperations:Ds}=Es,{vtkWarningMacro:Ls}=Wt,Bs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Ns(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bs,n),Rs.extend(e,t,n),Wt.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),function(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Vs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Ls(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Ls(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Ls(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Ls(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ds.PASSDATA][Vs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ds.PASSDATA][Vs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Ds).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Ds[e]]=Object.keys(Vs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Vs[t]]=!0,e)),[])})),t.copyAttributeFlags[Ds.COPYTUPLE][Vs.GLOBALIDS]=!1,t.copyAttributeFlags[Ds.INTERPOLATE][Vs.GLOBALIDS]=!1,t.copyAttributeFlags[Ds.COPYTUPLE][Vs.PEDIGREEIDS]=!1},e.initialize=Wt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(xs.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}(e,t)}var Fs={newInstance:Wt.newInstance(Ns,"vtkDataSetAttributes"),extend:Ns,...Es};const _s=["pointData","cellData","fieldData"],ks={};function Gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ks,n),Wt.obj(e,t),Wt.setGet(e,t,_s),Wt.getArray(e,t,["bounds"],6),function(e,t){t.classHierarchy.push("vtkDataSet"),_s.forEach((e=>{t[e]?t[e]=ze(t[e]):t[e]=Fs.newInstance()})),e.computeBounds=()=>{if(t.modifiedTime&&t.computeTime&&t.modifiedTime>t.computeTime||!t.computeTime){const n=e.getPoints();n?.getNumberOfPoints()?Gi.setBounds(t.bounds,n.getBoundsByReference()):t.bounds=Da.createUninitializedBounds(),t.computeTime=Wt.getCurrentGlobalMTime()}},e.getLength2=()=>{const t=e.getBoundsByReference();return t&&6===t.length?Gi.getDiagonalLength2(t):0},e.getLength=()=>Math.sqrt(e.getLength2()),e.getCenter=()=>{const t=e.getBoundsByReference();return t&&6===t.length?Gi.getCenter(t):[0,0,0]},e.getCellBounds=t=>{const n=e.getCell(t);return n?n.getBounds():Da.createUninitializedBounds()},e.getBounds=Wt.chain((()=>e.computeBounds),e.getBounds),e.getBoundsByReference=Wt.chain((()=>e.computeBounds),e.getBoundsByReference);const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),_s.forEach((n=>{t[n]=Fs.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))};const r=e.getMTime;e.getMTime=()=>_s.reduce(((e,n)=>Math.max(e,t[n]?.getMTime()??e)),r()),e.initialize=()=>(_s.forEach((e=>t[e]?.initialize())),e)}(e,t)}var Us={newInstance:Wt.newInstance(Gs,"vtkDataSet"),extend:Gs,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const zs={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var Ws={StructuredType:zs};const{StructuredType:Hs}=Ws;var js={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?Hs.EMPTY:3===t?Hs.XYZ_GRID:2===t?e[0]===e[1]?Hs.YZ_PLANE:e[2]===e[3]?Hs.XZ_PLANE:Hs.XY_PLANE:1===t?e[0]<e[1]?Hs.X_LINE:e[2]<e[3]?Hs.Y_LINE:Hs.Z_LINE:Hs.SINGLE_POINT},...Ws};const{vtkErrorMacro:Ks}=Wt,$s={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:zs.EMPTY};function qs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$s,n),Us.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=fe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),Wt.get(e,t,["indexToWorld","worldToIndex"]),Wt.setGetArray(e,t,["origin","spacing"],3),Wt.setGetArray(e,t,["direction"],9),Wt.getArray(e,t,["extent"],6),function(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return Ks("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=js.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)Ks("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void Ks("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return Ks("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case zs.EMPTY:return null;case zs.SINGLE_POINT:break;case zs.X_LINE:o[0]=n;break;case zs.Y_LINE:o[1]=n;break;case zs.Z_LINE:o[2]=n;break;case zs.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case zs.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case zs.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case zs.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:Ks("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Gi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Gi.inflate([...t.extent],.5),e.computeTransforms=()=>{O(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],C(t.indexToWorld,t.indexToWorld,t.spacing),v(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return In(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return In(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Gi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Gi.transformBounds(e,t.worldToIndex,n)},t._onOriginChanged=e.computeTransforms,t._onDirectionChanged=e.computeTransforms,t._onSpacingChanged=e.computeTransforms,e.computeTransforms(),e.getCenter=()=>Gi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Gi.computeCornerPoints(r,o,a),ea(o,o),ea(a,a);const i=e.getDimensions();xa(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),xa(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0;return{minimum:d,maximum:u,average:m,variance:h,sigma:Math.sqrt(h),count:g}},e.computeIncrements=function(e){const t=[];let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for(let r=0;r<3;++r)t[r]=n,n*=e[2*r+1]-e[2*r]+1;return t},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return Ks(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return Ks(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)};const n=e.initialize;e.initialize=()=>(e.set({direction:fe(t.direction),spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:zs.EMPTY}),n())}(e,t)}var Xs={newInstance:Wt.newInstance(qs,"vtkImageData"),extend:qs};const Ys={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var Zs={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:Ys,Scale:{LINEAR:0,LOG10:1}},Qs={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:Js,Scale:el,VectorMode:tl}=Zs,{VtkDataTypes:nl}=xs,{ColorMode:rl}=Qs,{vtkErrorMacro:ol}=Wt;function al(e){return e}function il(e){return Math.floor(255*e+.5)}const sl={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:tl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1,scale:el.LINEAR};function ll(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sl,n),Wt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],Wt.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),Wt.setArray(e,t,["mappingRange"],2),Wt.getArray(e,t,["mappingRange"]),function(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(tl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(tl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(tl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)ol("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===rl.DEFAULT&&(t.getDataType()===nl.UNSIGNED_CHAR||t.getDataType()===nl.UNSIGNED_CHAR_CLAMPED)||n===rl.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:nl.UNSIGNED_CHAR},i=Wt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=xs.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,Js.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,Js.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===tl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==tl.MAGNITUDE||1!==c&&1!==s||(i=tl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case tl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case tl.RGBCOLORS:break;case tl.MAGNITUDE:default:{const o=xs.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=il(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===nl.UNSIGNED_CHAR)return n;const i=xs.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:nl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=al;switch(n.getDataType()!==nl.FLOAT&&n.getDataType()!==nl.DOUBLE||(s=il),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return ol("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==rl.DEFAULT||n.getDataType()!==nl.UNSIGNED_CHAR)&&r!==rl.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}(e,t)}var cl={newInstance:Wt.newInstance(ll,"vtkScalarsToColors"),extend:ll,...Zs};const{vtkErrorMacro:ul}=Wt,dl={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function pl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dl,n),cl.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},Wt.obj(t.buildTime),t.opaqueFlagBuildTime={},Wt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},Wt.obj(t.insertTime,{mtime:0}),Wt.get(e,t,["buildTime"]),Wt.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),Wt.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),Wt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Wt.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=Oa(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===Ys.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===Ys.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,da(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return ul("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==cs.UNSIGNED_CHAR)return ul("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}(e,t)}var fl={newInstance:Wt.newInstance(pl,"vtkLookupTable"),extend:pl};const gl={Off:0,PolygonOffset:1};let ml=gl.PolygonOffset,hl=gl.Off;const vl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function Tl(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=hl===e;return hl=e,t}var yl={Resolve:gl,getResolveCoincidentTopologyAsString:function(){return vl[hl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return ml},getResolveCoincidentTopology:function(){return hl},setResolveCoincidentTopology:Tl,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=ml===e;return ml=e,t},setResolveCoincidentTopologyToDefault:function(){return Tl(gl.Off)},setResolveCoincidentTopologyToOff:function(){return Tl(gl.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return Tl(gl.PolygonOffset)}};function bl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=Wt.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const xl=["Polygon","Line","Point"],Cl={modified:()=>{}};bl(Cl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},xl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Sl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),Wt.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(yl).forEach((t=>{e[t]=yl[t]})),Object.keys(Cl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=Cl[t]})),bl(e,t.topologyOffset,xl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=Cl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=Cl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=Cl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:Cl,otherStaticMethods:yl,CATEGORIES:xl,Resolve:gl};const Al={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Il={PassTypes:Al};const{FieldAssociations:wl}=Us,{staticOffsetAPI:Ol,otherStaticMethods:Pl}=Sl,{ColorMode:Rl,ScalarMode:Ml,GetArray:El}=Qs,{VectorMode:Vl}=Zs,{VtkDataTypes:Dl}=xs;function Ll(e){return()=>Wt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Bl(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function Nl(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const Fl=new WeakMap;const _l={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function kl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_l,n),As(e,t,n),Wt.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),Wt.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),Wt.setGetArray(e,t,["scalarRange"],2),Sl.implementCoincidentTopologyMethods(e,t),function(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Pa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=fl.newInstance()},e.getColorModeAsString=()=>Wt.enumToString(Rl,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>Wt.enumToString(Ml,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Ml.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Ml.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Ml.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Ml.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===El.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ml.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===El.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ml.USE_FIELD_DATA){const t=e.getFieldData();i=r===El.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale(),s=t.lookupTable.getAlpha(),l=i?[Math.log10(a[0]),Math.log10(a[1])]:a;if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,a=2,d=r?n**3-3:4094;t.numberOfColorsInRange=Math.min(Math.max(e,a),d);const p=t.numberOfColorsInRange+3,f=t.numberOfColorsInRange+2,g=r?[Math.min(Math.ceil(p/n**0),n),Math.min(Math.ceil(p/n**1),n),Math.min(Math.ceil(p/n**2),n)]:[f,2,1],m=g[0]*g[1]*g[2],h=new Float64Array(m);h.fill(NaN);const v=t.numberOfColorsInRange,T=v+2,y=[0,0,0],b=l[0],x=l[1]-l[0];for(let e=0;e<T;++e){const t=b+x*(e-1)/(v-1),n=i?10**t:t;h[(u=g,(c=y)[0]+u[0]*(c[1]+u[1]*c[2]))]=n,Bl(y,g)}const C=xs.newInstance({numberOfComponents:1,values:h}),S=t.lookupTable.mapScalars(C,t.colorMode,0);t.colorTextureMap=Xs.newInstance(),t.colorTextureMap.setDimensions(g),t.colorTextureMap.getPointData().setScalars(S),t.lookupTable.setAlpha(s)}var c,u;const d=t.lookupTable.getVectorMode()===Vl.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=Fl.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(o-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(o+1)/(p-d),v=e.getData(),T=e.getNumberOfTuples(),y=e.getNumberOfComponents(),b=t<0||t>=y,x=a[2]<=1?2:3,C=xs.newInstance({numberOfComponents:x,values:new Float32Array(T*x)}),S=C.getData(),A=[0,0,0];Nl(A,o+2,a);let I=0,w=0;const O=[.5,.5,.5];for(let e=0;e<T;++e){let e;if(b){let t=0;for(let e=0;e<y;++e){const n=Number(v[I+e]);t+=n*n}e=Math.sqrt(t)}else e=Number(v[I+t]);if(r&&(e=Math.log10(e)),I+=y,Oa(e))O[0]=A[0],O[1]=A[1],O[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>o&&(t=o+1),Nl(O,t,a)}else{O[1]=.49;const t=(e-f)*g;O[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=O[e]}return Fl.set(e,{stringHash:l,textureCoordinates:C}),C}(n,d,l,i,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===Rl.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===Rl.DEFAULT&&e.getDataType()===Dl.UNSIGNED_CHAR||t.colorMode===Rl.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=Ll("AcquireInvertibleLookupTable"),e.valueToColor=Ll("ValueToColor"),e.colorToValue=Ll("ColorToValue"),e.useInvertibleColorFor=Ll("UseInvertibleColorFor"),e.clearInvertibleColor=Ll("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(Al.ID_LOW24),o=e.getRawPixelBuffer(Al.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===wl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===wl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===Al.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(Al.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===Al.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer(Al.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}(e,t)}var Gl={newInstance:Wt.newInstance(kl,"vtkMapper"),extend:kl,...Ol,...Pl,...Qs};const{isVtkObject:Ul}=Wt;function zl(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function Wl(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const Hl={extractCellSizes:zl,getNumberOfCells:Wl};function jl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};xs.extend(e,t,function(e){return{empty:!0,numberOfComponents:1,dataType:cs.UNSIGNED_INT,...e}}(n)),function(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=Wl(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=zl(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{let r;r=Ul(n)?n.getPointsIds():n;const o=e.getNumberOfCells();return e.insertNextTuples([r.length,...r]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(r.length),o},e.getMaxCellSize=()=>e.getCellSizes().reduce(((e,t)=>Math.max(e,t)),0)}(e,t)}var Kl={newInstance:Wt.newInstance(jl,"vtkCellArray"),extend:jl,...Hl};const{vtkErrorMacro:$l}=Wt,ql={empty:!0,numberOfComponents:3,dataType:cs.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Xl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ql,n),xs.extend(e,t,n),Wt.getArray(e,t,["bounds"],6),function(e,t){let n=0;t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=Wt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.insertPoint=(t,n)=>e.insertTuple(t,n);const r=e.getBounds;e.getBounds=()=>(n<t.mtime&&e.computeBounds(),r());const o=e.getBoundsByReference;e.getBoundsByReference=()=>(n<t.mtime&&e.computeBounds(),o()),e.computeBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);t.bounds[4]=o[0],t.bounds[5]=o[1]}else if(2===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0}else $l(`getBounds called on an array with components of ${e.getNumberOfComponents()}`),Ta(t.bounds);n=Wt.getCurrentGlobalMTime()},e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}(e,t)}var Yl={newInstance:Wt.newInstance(Xl,"vtkPoints"),extend:Xl};const Zl={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function Ql(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zl,n),Wt.obj(e,t),t.points||(t.points=Yl.newInstance()),Wt.get(e,t,["points","pointsIds"]),function(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=Wt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>t.points.getBounds(),e.getLength2=()=>{const t=Gi.getLengths(e.getBounds());return t[0]*t[0]+t[1]*t[1]+t[2]*t[2]},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{Wt.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}(e,t)}var Jl={newInstance:Wt.newInstance(Ql,"vtkCell"),extend:Ql};const ec={array:null,maxId:0,extend:0};function tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ec,n),Wt.obj(e,t),function(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Jl.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Jl.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}(e,t)}var nc={newInstance:Wt.newInstance(tc,"vtkCellLinks"),extend:tc};const rc=0,oc=1,ac=2,ic=3,sc=4,lc=5,cc=6,uc=7,dc=9,pc=21,fc=41,gc=42,mc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],hc={getClassNameFromTypeId:function(e){return e<mc.length?mc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return mc.findIndex(e)},isLinear:function(e){return e<pc||e===fc||e===gc},hasSubCells:function(e){return e===cc||e===sc||e===ac}},vc={size:0,maxId:-1,extend:1e3};function Tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vc,n),Wt.obj(e,t),Wt.get(e,t,["size","maxId","extend"]),Wt.getArray(e,t,["typeArray","locationArray"]),function(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=rc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}(e,t)}var yc={newInstance:Wt.newInstance(Tc,"vtkCellTypes"),extend:Tc,...hc};const bc={NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2};var xc={IntersectionState:bc};const{IntersectionState:Cc}=xc;function Sc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=Lo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Go(i,e),o}function Ac(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Mo(t,e,i),Mo(r,n,s),Mo(n,e,l);const c=[Lo(i,i),-Lo(i,s),-Lo(i,s),Lo(s,s)],u=[];if(u[0]=Lo(i,l),u[1]=-Lo(s,l),0===sa(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Sc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance,u.t);return Cc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Cc.YES_INTERSECTION:Cc.NO_INTERSECTION}const Ic={distanceToLine:Sc,intersection:Ac},wc={orientations:null};function Oc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wc,n),Jl.extend(e,t,n),Wt.setGet(e,t,["orientations"]),function(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=Ac(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Cc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Go(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Sc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Sc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Sc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Sc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,a,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(a=u*g+d*m+p*h+f*v)<0&&(a=-a,g=-g,m=-m,h=-h,v=-v),1-a>i?(o=Math.acos(a),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}(e,t)}var Pc={newInstance:Wt.newInstance(Oc,"vtkLine"),extend:Oc,...Ic,...xc};const Rc={};function Mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rc,n),Us.extend(e,t,n),Wt.setGet(e,t,["points"]),function(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=ze(t.points):t.points=Yl.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),t.points=Yl.newInstance(),t.points.shallowCopy(e.getPoints())};const r=e.getMTime;e.getMTime=()=>{const e=r();return Math.max(e,t.points?.getMTime()??e)};const o=e.initialize;e.initialize=()=>(t.points?.initialize(),o())}(e,t)}var Ec={newInstance:Wt.newInstance(Mc,"vtkPointSet"),extend:Mc};const Vc={orientations:null,distanceFunction:function(e,t){var n=t[0]-e[0],r=t[1]-e[1],o=t[2]-e[2];return Math.hypot(n,r,o)}};function Dc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vc,n),Jl.extend(e,t,n),Wt.setGet(e,t,["orientations","distanceFunction"]),t.distancesTime={},Wt.obj(t.distancesTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkPolyLine");const n=Pc.newInstance();n.getPoints().setNumberOfPoints(2),e.getCellDimension=()=>1,e.intersectWithLine=(r,o,a,i,s,l,c)=>{const u={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null},d=e.getNumberOfPoints()-1;let p=Number.MAX_VALUE;for(let e=0;e<d;e++){const d=[0,0,0];n.getPoints().getData().set(t.points.getData().subarray(3*e,3*(e+2)));const f=n.intersectWithLine(a,i,s,l,c);if(1===f.intersect&&f.t<=u.t+s&&f.t>=r&&f.t<=o){u.intersect=1;const t=n.getParametricDistance(d);if(t<p||t===p&&f.t<u.t){u.subId=e,u.t=f.t,p=t;for(let e=0;e<3;e++)l[e],d[e]}}}return u},e.evaluateLocation=(e,r,o,a)=>(n.getPoints().getData().set(t.points.getData().subarray(3*e,3*(e+2))),n.evaluateLocation(r,o,a)),e.evaluateOrientation=(e,r,o,a)=>(t.orientations?n.setOrientations([t.orientations[e],t.orientations[e+1]]):n.setOrientations(null),n.evaluateOrientation(r,o,a)),e.getDistancesToFirstPoint=()=>{const n=t.distancesTime.getMTime();if(n<t.points.getMTime()||n<e.getMTime()){const n=e.getNumberOfPoints();if(t.distances?t.distances.length=n:t.distances=new Array(n),n>0){const e=new Array(3),a=new Array(3);let i=0;t.distances[0]=i,t.points.getPoint(0,e);for(let s=1;s<n;++s)t.points.getPoint(s,a),i+=t.distanceFunction(e,a),t.distances[s]=i,o=a,(r=e)[0]=o[0],r[1]=o[1],r[2]=o[2]}t.distancesTime.modified()}var r,o;return t.distances},e.findPointIdAtDistanceFromFirstPoint=t=>{const n=e.getDistancesToFirstPoint();if(n.length<2)return-1;let r=0,o=n.length-1;if(t<n[r]||t>n[o]||0===n[o])return-1;for(;o-r>1;){const e=Math.floor((r+o)/2);n[e]<=t?r=e:o=e}return r}}(e,t)}var Lc={newInstance:Wt.newInstance(Dc,"vtkPolyLine"),extend:Dc};const Bc={elements:[]};function Nc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bc,n),Wt.obj(e,t),function(e,t){t.classHierarchy.push("vtkPriorityQueue"),e.push=(e,n)=>{const r=t.elements.findIndex((t=>t.priority>e));t.elements.splice(r,0,{priority:e,element:n})},e.pop=()=>t.elements.length>0?t.elements.shift().element:null,e.deleteById=e=>{t.elements=t.elements.filter((t=>{let{element:n}=t;return n.id!==e}))},e.length=()=>t.elements.length}(e,t)}var Fc={newInstance:Wt.newInstance(Nc,"vtkPriorityQueue"),extend:Nc};const _c=1e-6,kc=1.1920929e-7,Gc={FAILURE:-1,OUTSIDE:0,INSIDE:1,INTERSECTION:2,ON_LINE:3};function Uc(e,t,n,r,o){return(r[e]-n[e])*(o[t]-n[t])-(o[e]-n[e])*(r[t]-n[t])}const zc={PolygonWithPointIntersectionState:Gc,pointInPolygon:function(e,t,n,r){if(e[0]<n[0]||e[0]>n[1]||e[1]<n[2]||e[1]>n[3]||e[2]<n[4]||e[2]>n[5])return Gc.OUTSIDE;if(Fo(r)<=kc)return Gc.FAILURE;let o=1e-8*((n[1]-n[0])*(n[1]-n[0])+(n[3]-n[2])*(n[3]-n[2])+(n[5]-n[4])*(n[5]-n[4]));o*=o,o=0===o?kc:o;const a=[],i=[];for(let n=0;n<t.length;){if(a[0]=t[n++],a[1]=t[n++],a[2]=t[n++],Go(e,a)<=o)return Gc.INSIDE;const{distance:r,t:s}=Pc.distanceToLine(e,a,i);if(r<=o&&s>0&&s<1)return Gc.INSIDE}let s,l;Math.abs(r[0])>Math.abs(r[1])?Math.abs(r[0])>Math.abs(r[2])?(s=1,l=2):(s=0,l=1):Math.abs(r[1])>Math.abs(r[2])?(s=0,l=2):(s=0,l=1);let c=0;for(let n=0;n<t.length;)a[0]=t[n++],a[1]=t[n++],a[2]=t[n++],n<t.length?(i[0]=t[n],i[1]=t[n+1],i[2]=t[n+2]):(i[0]=t[0],i[1]=t[1],i[2]=t[2]),a[l]<=e[l]?i[l]>e[l]&&Uc(s,l,a,i,e)>0&&++c:i[l]<=e[l]&&Uc(s,l,a,i,e)<0&&--c;return 0===c?Gc.OUTSIDE:Gc.INSIDE},getBounds:function(e,t,n){const r=e.length,o=[];t.getPoint(e[0],o),n[0]=o[0],n[1]=o[0],n[2]=o[1],n[3]=o[1],n[4]=o[2],n[5]=o[2];for(let a=1;a<r;a++)t.getPoint(e[a],o),Gi.addPoint(n,...o);const a=Gi.getLengths(n);return Lo(a,a)},getNormal:function(e,t,n){n.length=3,n[0]=0,n[1]=0,n[2]=0;const r=[];let o=[],a=[];const i=[],s=[];t.getPoint(e[0],r),t.getPoint(e[1],o);for(let l=2;l<e.length;l++){t.getPoint(e[l],a),Mo(a,o,i),Mo(r,o,s);const c=[0,0,0];Bo(i,s,c),Ro(n,c,n),[o,a]=[a,o]}return Fo(n)},computeCentroid:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[0,0,0];n[0]=0,n[1]=0,n[2]=0;const r=e.length,o=[];for(let a=0;a<r;a++)t.getPoint(e[a],o),n[0]+=o[0],n[1]+=o[1],n[2]+=o[2];return n[0]/=r,n[1]/=r,n[2]/=r,n}};function Wc(e,t){function n(e){const n=[0,0,0],r=[0,0,0],o=[0,0,0],a=[0,0,0];Mo(e.point,e.previous.point,n),Mo(e.next.point,e.point,r),Mo(e.previous.point,e.next.point,o),Bo(n,r,a);const i=Lo(a,t.normal);if(i<=0)return-1;const s=No(n)+No(r)+No(o);return s*s/i}function r(e){if(t.pointCount<=3)return!0;const n=e.previous,r=e.next,o=[0,0,0];Mo(r.point,n.point,o);const a=[0,0,0];if(Bo(o,t.normal,a),Fo(a),0===No(a))return!1;let i=ei.evaluate(a,n.point,r.next.point),s=i>_c?1:i<-1e-6?-1:0,l=s<0?1:0;for(let e=r.next.next;e.id!==n.id;e=e.next){const t=e.previous;i=ei.evaluate(a,n.point,e.point);const o=i>_c?1:i<-1e-6?-1:0;if(o!==s){if(l||(l=o<=0?1:0),Pc.intersection(n.point,r.point,e.point,t.point,[0],[0])===bc.YES_INTERSECTION)return!1;s=o}}return 1===l}function o(e,r){t.pointCount-=1;const o=e.previous,a=e.next;t.tris=t.tris.concat(e.point),t.tris=t.tris.concat(a.point),t.tris=t.tris.concat(o.point),o.next=a,a.previous=o,r.deleteById(o.id),r.deleteById(a.id);const i=n(o);i>0&&r.push(i,o);const s=n(a);s>0&&r.push(s,a),e.id===t.firstPoint.id&&(t.firstPoint=a)}t.classHierarchy.push("vtkPolygon"),e.triangulate=()=>t.firstPoint?function(){!function(){const e=[0,0,0],n=[0,0,0];t.normal=[0,0,0];const r=[...t.firstPoint.point];let o=t.firstPoint;for(let a=0;a<t.pointCount;a++){Mo(o.point,r,e),Mo(o.next.point,r,n);const a=[0,0,0];Bo(e,n,a),Ro(t.normal,a,t.normal),o=o.next}Fo(t.normal)}();const e=Fc.newInstance();let a=t.firstPoint;for(let r=0;r<t.pointCount;r++){const t=n(a);t>0&&e.push(t,a),a=a.next}for(;t.pointCount>2&&e.length()>0;)if(t.pointCount===e.length())o(e.pop(),e);else{const t=e.pop();r(t)&&o(t,e)}return t.pointCount<=2}():null,e.setPoints=e=>{t.pointCount=e.length,t.firstPoint={id:0,point:e[0],next:null,previous:null};let n=t.firstPoint;for(let r=1;r<t.pointCount;r++)n.next={id:r,point:e[r],next:null,previous:n},n=n.next;t.firstPoint.previous=n,n.next=t.firstPoint},e.getPointArray=()=>t.tris}const Hc={firstPoint:null,pointCount:0,tris:[]};function jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hc,n),Wt.obj(e,t),Wc(e,t)}var Kc={newInstance:Wt.newInstance(jc,"vtkPolygon"),extend:jc,...zc};function $c(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function qc(e,t,n,r){$c(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}function Xc(e){e[0]=-1,e[1]=1,e[2]=0,e[3]=-1,e[4]=0,e[5]=1}const Yc={computeNormalDirection:$c,computeNormal:qc,interpolationDerivs:Xc,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];qc(e,t,n,d),qc(r,o,a,p);const f=-Lo(d,e),g=-Lo(p,r),m=[Lo(p,e)+g,Lo(p,t)+g,Lo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[Lo(d,r)+f,Lo(d,o)+f,Lo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],T=[r,o,a],y=Lo(d,p),b=(f-g*y)/(y*y-1),x=(g-f*y)/(y*y-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Bo(d,p,[]);Fo(S);let A=0,I=0;const w=[],O=[];let P,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ei.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=Lo(a.x,S)-Lo(C,S));const s=ei.intersectWithLine(T[n],T[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),O[I++]=Lo(s.x,S)-Lo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=O[2];O[2]=O[E],O[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(O[0])||Number.isNaN(O[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(O[0]>O[1]){const e=O[1];O[1]=O[0],O[0]=e}return w[1]<O[0]||O[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<O[0]?w[1]<O[1]?(u[0]=2,u[1]=1,P=O[0],R=w[1]):(u[0]=2,u[1]=2,P=O[0],R=O[1]):w[1]<O[1]?(u[0]=1,u[1]=1,P=w[0],R=w[1]):(u[0]=1,u[1]=2,P=w[0],R=O[1]),Do(C,S,P,l),Do(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}},Zc={};function Qc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zc,n),Jl.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(qc(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ei.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Go(u,d),h=Go(d,p),v=Go(p,u);t.line||(t.line=Pc.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const T=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=T.betweenPoints,s.t=T.t,T.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=Lo(n,e)/v,i[1]=Lo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const T=[];let y,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),$c(l,c,u,d),ei.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(T[s++]=i);for(i=0;i<2;i++)f[i]=I[T[i]]-u[T[i]],g[i]=l[T[i]]-u[T[i]],m[i]=c[T[i]]-u[T[i]];if(h=Wo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Wo(f,m)/h,r[1]=Wo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Go(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(y=Go(e,u),b=Pc.distanceToLine(e,l,u,t,S),x=Pc.distanceToLine(e,u,c,t,A),y<b?(a.dist2=y,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(y=Go(e,l),b=Pc.distanceToLine(e,l,u,t,S),x=Pc.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(y=Go(e,c),b=Pc.distanceToLine(e,c,u,t,S),x=Pc.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Pc.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Pc.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Pc.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n},e.derivatives=(e,n,r,o,a)=>{const i=t.points.getPoint(0),s=t.points.getPoint(1),l=t.points.getPoint(2),c=[],u=[],d=[],p=[];qc(i,s,l,c),Mo(s,i,u),Mo(l,i,p),Bo(c,u,d);const f=Fo(u);if(f<=0||Fo(d)<=0){for(let e=0;e<o;e++)for(let t=0;t<3;t++)a[e*o+t]=0;return}const g=[0,0],m=[f,0],h=[Lo(p,u),Lo(p,d)],v=new Array(6);Xc(v);const T=[m[0]-g[0],m[1]-g[1],h[0]-g[0],h[1]-g[1]],y=Wt.newTypedArray(ot.Float64Array,4);la(T,y,2);for(let e=0;e<o;e++){let t=0,n=0;for(let a=0;a<3;a++)t+=v[a]*r[o*a+e],n+=v[3+a]*r[o*a+e];const i=t*y[0]+n*y[1],s=t*y[2]+n*y[3];a[3*e]=i*u[0]+s*d[0],a[3*e+1]=i*u[1]+s*d[1],a[3*e+2]=i*u[2]+s*d[2]}},e.cellBoundary=(e,n,r)=>{const o=n[0]-n[1],a=.5*(1-n[0])-n[1],i=2*n[0]+n[1]-1;return o>=0&&a>=0?(r[0]=t.pointsIds[0],r[1]=t.pointsIds[1]):a<0&&i>=0?(r[0]=t.pointsIds[1],r[1]=t.pointsIds[2]):(r[0]=t.pointsIds[2],r[1]=t.pointsIds[0]),!(n[0]<0||n[1]<0||n[0]>1||n[1]>1||1-n[0]-n[1]<0)}}(e,t)}var Jc={newInstance:Wt.newInstance(Qc,"vtkTriangle"),extend:Qc,...Yc};const eu={};function tu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eu,n),Jl.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkQuad"),e.getCellDimension=()=>2,e.getCellType=()=>dc,e.getNumberOfEdges=()=>4,e.getNumberOfFaces=()=>0,e.intersectWithLine=(e,n,r,o,a)=>{let i,s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};const l=t.points.getPoint(0,[]),c=t.points.getPoint(1,[]),u=t.points.getPoint(2,[]),d=t.points.getPoint(3,[]),p=Go(l,u),f=Go(c,d);if(p===f){let e,n=0,r=0;for(let o=0;o<4;o++)e=t.pointsIds[o],e>n&&(n=e,r=o);i=0===r||2===r?0:1}else i=p<f?0:1;let g,m=null;t.triangle?m=t.triangle.getPoints():(t.triangle=Jc.newInstance(),m=Yl.newInstance(),m.setNumberOfPoints(3),t.triangle.initialize(m));const h=[0,0,0],v=[0,0,0];let T;const y=[0,0,0],b=[0,0,0];let x,C;switch(i){case 0:m.setPoint(0,...l),m.setPoint(1,...c),m.setPoint(2,...u),g=t.triangle.intersectWithLine(e,n,r,h,v),m.setPoint(0,...u),m.setPoint(1,...d),m.setPoint(2,...l),T=t.triangle.intersectWithLine(e,n,r,y,b),x=g.intersect&&T.intersect?g.t<=T.t:g.intersect,C=g.intersect&&T.intersect?T.t<g.t:T.intersect,x?(s=g,o[0]=h[0],o[1]=h[1],o[2]=h[2],a[0]=v[0]+v[1],a[1]=v[1],a[2]=v[2]):C&&(s=T,o[0]=y[0],o[1]=y[1],o[2]=y[2],a[0]=1-(b[0]+b[1]),a[1]=1-b[1],a[2]=b[2]);break;case 1:m.setPoint(0,...l),m.setPoint(1,...c),m.setPoint(2,...d),g=t.triangle.intersectWithLine(e,n,r,h,v),m.setPoint(0,...u),m.setPoint(1,...d),m.setPoint(2,...c),T=t.triangle.intersectWithLine(e,n,r,y,b),x=g.intersect&&T.intersect?g.t<=T.t:g.intersect,C=g.intersect&&T.intersect?T.t<g.t:T.intersect,x?(s=g,o[0]=h[0],o[1]=h[1],o[2]=h[2],a[0]=v[0],a[1]=v[1],a[2]=v[2]):C&&(s=T,o[0]=y[0],o[1]=y[1],o[2]=y[2],a[0]=1-b[0],a[1]=1-b[1],a[2]=b[2])}return s},e.interpolationFunctions=(e,t)=>{const n=1-e[0],r=1-e[1];t[0]=n*r,t[1]=e[0]*r,t[2]=e[0]*e[1],t[3]=n*e[1]},e.evaluateLocation=(n,r,o)=>{const a=[];e.interpolationFunctions(n,o),r[0]=0,r[1]=0,r[2]=0;for(let e=0;e<4;e++){t.points.getPoint(e,a);for(let t=0;t<3;t++)r[t]+=a[t]*o[e]}}}(e,t)}var nu={newInstance:Wt.newInstance(tu,"vtkQuad"),extend:tu};const{vtkErrorMacro:ru}=Wt;function ou(e){return()=>ru(`vtkTriangleStrip.${e} - NOT IMPLEMENTED`)}const au={decomposeStrip:function(e,t){if(!Array.isArray(e)||e.length<3)return void ru("decomposeStrip - Invalid points array");let n=e[0],r=e[1];for(let o=0;o<e.length-2;o++){const a=e[o+2];o%2?t.insertNextCell([r,n,a]):t.insertNextCell([n,r,a]),n=r,r=a}}},iu={line:null,triangle:null,tris:null};function su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),Jl.extend(e,t,n),t.line||(t.line=Pc.newInstance()),t.triangle||(t.triangle=Jc.newInstance()),function(e,t){t.classHierarchy.push("vtkTriangleStrip");const n=e.initialize;e.initialize=(e,r)=>{t.triangle.initialize(e,r),n(e,r)},e.getCellType=()=>cc,e.getCellDimension=()=>2,e.getNumberOfEdges=()=>t.pointsIds.length,e.getNumberOfFaces=()=>0,e.evaluatePosition=(e,n,r,o,a)=>{const i=[0,0,0];let s=Number.MAX_VALUE,l=0;const c=[],u=[],d=[];r[2]=0,u[0]=0,u[1]=0,u[2]=0;const p=t.triangle.getPoints();p.setNumberOfPoints(3);const f=t.triangle.getPointsIds().length;for(let e=0;e<f;e++)a[e]=0;for(let o=0;o<f-2;o++){const a=[];p.getPoint(o,a);const f=[];p.getPoint(o+1,f);const g=[];p.getPoint(o+2,g),p.setData(Float32Array.from([...a,...f,...g]),3);const m=t.triangle.evaluatePosition(e,d,i,c),h=m.dist2;m.evaluation>=0&&(h<s||h===s&&0===l)&&(l=m,n&&(n[0]=d[0],n[1]=d[1],n[2]=d[2]),r[0]=i[0],r[1]=i[1],s=h,u[0]=c[0],u[1]=c[1],u[2]=c[2])}return o[0]=s,a[0]=u[0],a[1]=u[1],a[2]=u[2],l},e.evaluateLocation=(e,n,r,o)=>{const a=[[0,1,2],[1,0,2]],i=e%2,s=t.pointsIds.length;for(let e=0;e<s;e++)o[e]=0;const l=1-n[0]-n[1];o[e]=l,o[e+1]=n[0],o[e+2]=n[1];const c=[];t.points.getPoint(e+a[i][0],c);const u=[];t.points.getPoint(e+a[i][1],u);const d=[];t.points.getPoint(e+a[i][2],d);for(let t=0;t<3;t++)r[t]=c[t]*o[e]+u[t]*o[e+1]+d[t]*o[e+2]},e.cellBoundary=(e,n,r)=>{const o=[[0,1,2],[1,0,2]],a=e%2,i=t.triangle.getPointsIds();return i[0]=t.pointsIds[o[a][0]],i[1]=t.pointsIds[o[a][1]],i[2]=t.pointsIds[o[a][2]],t.triangle.cellBoundary(0,n,r)},e.getEdge=e=>{let n,r;const o=t.pointsIds.length;return 0===e?(n=0,r=1):e===o-1?(n=e-1,r=e):(n=e-1,r=e+1),t.line.getPointsIds()[0]=t.pointsIds[n],t.line.getPointsIds()[1]=t.pointsIds[r],t.line.getPoints().setPoint(0,t.points.getPoint(n)),t.line.getPoints().setPoint(1,t.points.getPoint(r)),t.line},e.intersectWithLine=(e,n,r,o,a)=>{const i=t.pointsIds.length-2,s=t.triangle.getPoints();s.setNumberOfPoints(3);for(let l=0;l<i;l++){const i=[];t.points.getPoint(t.pointsIds[l],i);const c=[];t.points.getPoint(t.pointsIds[l+1],c);const u=[];t.points.getPoint(t.pointsIds[l+2],u),s.setData(Float32Array.from([...i,...c,...u]),3);const d=t.triangle.intersectWithLine(e,n,r,o,a);if(d.intersect)return d}return!1},e.triangulate=()=>{const e=t.points.getNumberOfPoints()-2;t.tris=new Array(3*e);const n=[[0,1,2],[1,0,2]];for(let r=0;r<e;r++){const e=r%2;for(let o=0;o<3;o++)t.tris[3*r+o]=r+n[e][o]}return!0},e.getPointArray=()=>t.tris,e.derivatives=(e,n,r,o,a)=>{const i=[];t.points.getPoint(e,i);const s=[];t.points.getPoint(e+1,s);const l=[];t.points.getPoint(e+2,l);const c=t.triangle.getPoints();c.setPoint(0,...i),c.setPoint(1,...s),c.setPoint(2,...l),t.triangle.derivatives(0,n,r,o,a)},e.getParametricCenter=e=>(e[0]=.333333,e[1]=.333333,e[2]=0,Math.floor((t.pointsIds.length-2)/2)),e.contour=(e,t,n,r,o,a,i,s,l,c,u)=>ou("contour")(),e.clip=(e,t,n,r,o,a,i,s,l,c)=>ou("clip")()}(e,t)}var lu={newInstance:Wt.newInstance(su,"vtkTriangleStrip"),extend:su,...au};const cu=["verts","lines","polys","strips"],{vtkWarningMacro:uu}=Wt,du={[ic]:Pc,[dc]:nu,[sc]:Pc,[lc]:Jc,[cc]:lu,[sc]:Lc,[uc]:Kc},pu={};function fu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pu,n),Ec.extend(e,t,n),Wt.get(e,t,["cells","links"]),Wt.setGet(e,t,["verts","lines","polys","strips"]),function(e,t){t.classHierarchy.push("vtkPolyData"),cu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=ze(t[n]):t[n]=Kl.newInstance()})),e.getNumberOfCells=()=>cu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),cu.forEach((n=>{t[n]=Kl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))};const r=e.getMTime;e.getMTime=()=>cu.reduce(((e,n)=>Math.max(e,t[n]?.getMTime()??e)),r());const o=e.initialize;e.initialize=()=>(cu.forEach((e=>t[e]?.initialize())),o()),e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?ac:oc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?sc:ic,1===t&&uu("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=lc;break;case 4:l[n]=dc;break;default:l[n]=uc}t<3&&uu("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(cc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=yc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=nc.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case oc:case ac:o=t.verts;break;case ic:case sc:o=t.lines;break;case lc:case dc:case uc:o=t.polys;break;case cc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||du[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o},e.getMaxCellSize=()=>cu.reduce(((e,n)=>Math.max(e,t[n]?.getMaxCellSize?.()??0)),0)}(e,t)}var gu={newInstance:Wt.newInstance(fu,"vtkPolyData"),extend:fu};const mu={image:null,canvas:null,jsImageData:null,imageBitmap:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function hu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mu,n),Wt.obj(e,t),Wt.algo(e,t,6,0),Wt.get(e,t,["canvas","image","jsImageData","imageBitmap","imageLoaded","resizable"]),Wt.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),function(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.imageBitmap=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setImageBitmap=n=>{t.imageBitmap!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.jsImageData=null),t.imageBitmap=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.imageBitmap=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null,t.imageBitmap=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),t.imageBitmap&&(n=t.imageBitmap.width,r=t.imageBitmap.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData;if(t.imageBitmap)return t.imageBitmap;if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=t.image.width,n=t.image.height,r=new OffscreenCanvas(e,n).getContext("2d");return r.translate(0,n),r.scale(1,-1),r.drawImage(t.image,0,0,e,n),r.getImageData(0,0,e,n)}return null}}(e,t)}var vu={newInstance:Wt.newInstance(hu,"vtkTexture"),extend:hu,generateMipmaps:(e,t,n)=>{const r=e.createShaderModule({code:"\n    @group(0) @binding(0) var inputTexture: texture_2d<f32>;\n    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(8, 8)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n      let texelCoord = vec2<i32>(global_id.xy);\n      let outputSize = textureDimensions(outputTexture);\n\n      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {\n        return;\n      }\n\n      let inputSize = textureDimensions(inputTexture);\n      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);\n\n      // Compute the floating-point source coordinate\n      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;\n\n      // Get integer coordinates for the four surrounding texels\n      let x0 = i32(floor(srcCoord.x));\n      let x1 = min(x0 + 1, i32(inputSize.x) - 1);\n      let y0 = i32(floor(srcCoord.y));\n      let y1 = min(y0 + 1, i32(inputSize.y) - 1);\n\n      // Compute the weights\n      let wx = srcCoord.x - f32(x0);\n      let wy = srcCoord.y - f32(y0);\n\n      // Fetch the four texels\n      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);\n      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);\n      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);\n      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);\n\n      // Bilinear interpolation\n      let color = mix(\n        mix(c00, c10, wx),\n        mix(c01, c11, wx),\n        wy\n      );\n\n      textureStore(outputTexture, texelCoord, color);\n    }\n  "}),o=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}}]}),a=e.createPipelineLayout({bindGroupLayouts:[o]}),i=e.createComputePipeline({label:"ComputeMipmapPipeline",layout:a,compute:{module:r,entryPoint:"main"}}),s=e.createSampler({magFilter:"linear",minFilter:"linear"});for(let r=1;r<n;r++){const n=t.createView({baseMipLevel:r-1,mipLevelCount:1}),o=t.createView({baseMipLevel:r,mipLevelCount:1}),a=e.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:o},{binding:2,resource:s}]}),l=e.createCommandEncoder({label:"MipmapGenerateCommandEncoder"}),c=l.beginComputePass();c.setPipeline(i),c.setBindGroup(0,a);const u=Math.max(1,t.width>>r),d=Math.max(1,t.height>>r),p=Math.ceil(u/8),f=Math.ceil(d/8);c.dispatchWorkgroups(p,f),c.end(),e.queue.submit([l.finish()])}}};const Tu=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],yu=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],bu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],xu=[0,1,0,1,0,1,0,1,2,2,2,2],Cu=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Su=new Float64Array(3),Au=new Float64Array(3),Iu=new Float64Array(3),wu=new Float64Array(3),Ou=new Float64Array(3),Pu=new Float64Array(3),Ru=new Float64Array(16);function Mu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Eu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=ro().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}const Vu=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Wt.obj(e,t),t.tmPolyData=gu.newInstance(),t.tmMapper=Gl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=ss.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),Wt.setGet(e,t,["renderable"]),Wt.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},Wt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},Wt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Su[0]=c[3*n],Su[1]=c[3*n+1],Su[2]=c[3*n+2],In(Iu,Su,r),Iu[0]+=.1,In(Au,Iu,o),Tn(Ou,Au,Su),Iu[0]-=.1,Iu[1]+=.1,In(Au,Iu,o),Tn(Pu,Au,Su);for(let e=0;e<3;e++)Ou[e]/=.05*u[0],Pu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Su[0]=c[3*n],Su[1]=c[3*n+1],Su[2]=c[3*n+2],a[0]<-.5?bn(Iu,Ou,a[0]*i-l.width):a[0]>.5?bn(Iu,Ou,a[0]*i):bn(Iu,Ou,a[0]*i-l.width/2),vn(Su,Su,Iu),bn(Iu,Pu,a[1]*i-l.height/2),vn(Su,Su,Iu),s.points[3*d]=Su[0],s.points[3*d+1]=Su[1],s.points[3*d+2]=Su[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,bn(Iu,Ou,l.width),vn(Su,Su,Iu),s.points[3*d]=Su[0],s.points[3*d+1]=Su[1],s.points[3*d+2]=Su[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,bn(Iu,Pu,l.height),vn(Su,Su,Iu),s.points[3*d]=Su[0],s.points[3*d+1]=Su[1],s.points[3*d+2]=Su[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,bn(Iu,Ou,l.width),Tn(Su,Su,Iu),s.points[3*d]=Su[0],s.points[3*d+1]=Su[1],s.points[3*d+2]=Su[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);h(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);v(Ru,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Su[0]=f[3*u],Su[1]=f[3*u+1],Su[2]=f[3*u+2],In(Iu,Su,n),Su[0]=f[3*u+3],Su[1]=f[3*u+4],Su[2]=f[3*u+5],In(wu,Su,n),Tn(Iu,Iu,wu);const r=[Iu[0],Iu[1]];zo(r),e.createPolyDataForOneLabel(g[d],u,n,Ru,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,Ru,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const m=xs.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(m),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}(e,t)}),"vtkCubeAxesActorHelper");function Du(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};ss.extend(e,t,function(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Gi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:Eu,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=vu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=Gl.newInstance(),t.polyData=gu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=ss.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=gu.newInstance(),Wt.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),Wt.setGetArray(e,t,["dataBounds"],6),Wt.setGetArray(e,t,["axisLabels"],3),Wt.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),function(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();h(e,e);let n=!1;const r=Gi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Su[s]=t.dataBounds[a]-.1*r*Tu[a][s],Su[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Su[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),In(Iu,Su,e),Su[s]=t.dataBounds[a],In(wu,Su,e),Tn(Iu,wu,Iu),Cn(Iu,Iu),i=Iu[2]>o,t.camera.getParallelProjection()||(Cn(wu,wu),i=Sn(wu,Iu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Cu[t][0]].length+2*r[Cu[t][1]].length,a+=r[Cu[t][0]].length+r[Cu[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=bu[e][0],l[3*u+2]=bu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Cu[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Cu[n][0]]=o[r],s[3*c+Cu[n][1]]=t.dataBounds[2*Cu[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Cu[n][0]]=o[r],s[3*c+Cu[n][1]]=t.dataBounds[2*Cu[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Cu[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Cu[n][1]]=o[r],s[3*c+Cu[n][0]]=t.dataBounds[2*Cu[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Cu[n][1]]=o[r],s[3*c+Cu[n][0]]=t.dataBounds[2*Cu[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[xu[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=yu[a][e];if(1===n[d]){const e=xu[d],n=3*bu[d][0],p=3*bu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Cu[a][0]]=.5*(t.dataBounds[2*Cu[a][0]]+t.dataBounds[2*Cu[a][0]+1]),s[3*l+Cu[a][1]]=.5*(t.dataBounds[2*Cu[a][1]]+t.dataBounds[2*Cu[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[yu[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Mu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Mu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=wo(n),r=wo(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Mu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Gi.setBounds(t.bounds,t.gridActor.getBounds()),Gi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=Wt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}(e,t)}var Lu={newInstance:Wt.newInstance(Du,"vtkCubeAxesActor"),extend:Du,newCubeAxesActorHelper:Vu,defaultGenerateTicks:Eu};const Bu={};const Nu=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bu,n),qt.extend(e,t,n),t.CubeAxesActorHelper=Lu.newCubeAxesActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLCubeAxesActor");Jt("vtkCubeAxesActor",Nu);const Fu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var _u={ObjectType:Fu};const{ObjectType:ku}=_u,Gu={objectType:ku.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function Uu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gu,n),Wt.obj(e,t),Wt.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),Wt.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e){switch(e){case ku.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case ku.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case ku.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}(e,t)}var zu={newInstance:Wt.newInstance(Uu),extend:Uu,..._u};function Wu(e){let t=0,n=0;for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t+=a*a;const i=.5*(o[1]+o[0]);n+=i*i}const r=t>0&&(Math.abs(n)/t>1e6||Math.abs(Math.log10(t))>3||0===t&&n>1e6);if(r){const t=new Float64Array(3),n=new Float64Array(3);for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t[r]=.5*(o[1]+o[0]),n[r]=a>0?1/a:1}return{useShiftAndScale:r,coordShift:t,coordScale:n}}return{useShiftAndScale:r,coordShift:new Float32Array([0,0,0]),coordScale:new Float32Array([1,1,1])}}const{vtkErrorMacro:Hu}=Wt;const ju={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function Ku(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ju,n),zu.extend(e,t,n),Wt.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),Wt.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),function(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(Fu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=zu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,T=0,y=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints(e,t){return e},linesToWireframe(e,t){return e>1?2*(e-1):0},polysToWireframe(e,t){return e>2?2*e:0},stripsToWireframe(e,t){return e>2?4*e-6:0},polysToSurface(e,t){return e>2?3*(e-2):0},stripsToSurface(e,t,n){return e>2?3*(e-2):0}};let C=null,S=null;o===Zi.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===Zi.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let O=null;const P=new Float32Array(w*t.blockSize);u&&(O=new Uint8Array(4*w));let R=0,M=0;const{useShiftAndScale:E,coordShift:V,coordScale:D}=Wu(a.points);if(E?e.setCoordShiftAndScale(V,D):!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null),i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=y+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(P[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],P[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],P[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(P[R++]=s[g++],P[R++]=s[g++],P[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(y+a.cellOffset):3*e,P[R++]=l[m++],P[R++]=l[m++],P[R++]=l[m++]),t.customData.forEach((t=>{T=e*t.components;for(let e=0;e<t.components;++e)P[R++]=t.data[T++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)P[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(y+a.cellOffset)*d:e*d,O[M++]=u[v++],O[M++]=u[v++],O[M++]=u[v++],O[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,y++)C(A[e],A,e+1,y+a.cellOffset);return t.elementCount=w,e.upload(P,Fu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(O,Fu.ARRAY_BUFFER)),y},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Pn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Pn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(On(e,[0,0,0])&&On(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);xn(n,t);const r=new Float64Array(16);return _(r,Ba(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):Hu("Wrong type for coordScale, expected vec3 or null"):Hu("Wrong type for coordShift, expected vec3 or null")}}(e,t)}var $u={newInstance:Wt.newInstance(Ku),extend:Ku};const{vtkErrorMacro:qu}=Wt,Xu={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function Yu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xu,n),Wt.obj(e,t),Wt.setGet(e,t,["shaderType","source","error","handle","context"]),function(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return qu(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}(e,t)}var Zu={newInstance:Wt.newInstance(Yu,"vtkShader"),extend:Yu};const{vtkErrorMacro:Qu}=Wt,Ju={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function ed(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ju,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=Zu.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=Zu.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=Zu.newInstance(),t.geometryShader.setShaderType("Geometry"),Wt.obj(e,t),Wt.get(e,t,["lastCameraMTime"]),Wt.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),function(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(Qu(`Links failed: ${t.error}`),0):(Qu(t.error),0):(Qu(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Qu(t.fragmentShader.getError()),0):(Qu(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Qu(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return Qu(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(Qu("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return Qu("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}(e,t)}var td={newInstance:Wt.newInstance(ed,"vtkShaderProgram"),extend:ed,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};const nd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function rd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nd,n),t.buffers=[],Wt.obj(e,t),Wt.get(e,t,["supported"]),Wt.setGet(e,t,["forceEmulation"]),function(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==Fu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}var od={newInstance:Wt.newInstance(rd,"vtkOpenGLVertexArrayObject"),extend:rd};const ad={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6},id={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,id,n),Wt.obj(e,t),t.shaderSourceTime={},Wt.obj(t.shaderSourceTime),t.attributeUpdateTime={},Wt.obj(t.attributeUpdateTime),Wt.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=td.newInstance(),t.VAO=od.newInstance(),t.CABO=$u.newInstance(),function(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===Zi.POINTS||n===ad.Points?t.context.POINTS:e===Zi.WIREFRAME||n===ad.Lines||n===ad.TrisEdges||n===ad.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===ad.Points||r.getProperty().getRepresentation()===Zi.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=td.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=td.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=td.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=td.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===ad.Points?2:t.primitiveType===ad.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}(e,t)}var ld={newInstance:Wt.newInstance(sd),extend:sd,primTypes:ad};const cd={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},ud={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var dd={Wrap:cd,Filter:ud};const pd=new Float32Array(1),fd=new Int32Array(pd.buffer);var gd={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){pd[0]=e;const t=fd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let md;const{Wrap:hd,Filter:vd}=dd,{VtkDataTypes:Td}=xs,{vtkDebugMacro:yd,vtkErrorMacro:bd,vtkWarningMacro:xd,requiredParam:Cd}=Ht,{toHalf:Sd}=gd;function Ad(e,t){function n(){return{internalFormat:t.internalFormat,format:t.format,openGLDataType:t.openGLDataType,width:t.width,height:t.height}}t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(vd.LINEAR),e.setMagnificationFilter(vd.LINEAR)):(e.setMinificationFilter(vd.NEAREST),e.setMagnificationFilter(vd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(hd.REPEAT),e.setWrapS(hd.REPEAT),e.setWrapT(hd.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImageBitmap()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImageBitmap()&&t.renderable.getImageLoaded()&&(e.create2DFromImageBitmap(t.renderable.getImageBitmap()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:Td.UNSIGNED_CHAR,data:n,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:Td.UNSIGNED_CHAR,data:n.data,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:a}):e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const r=()=>{if(t.minificationFilter!==vd.LINEAR&&t.magnificationFilter!==vd.LINEAR||(void 0===md&&(md=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,T=i.getExtension("WEBGL_lose_context");return T&&T.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),md))return t.oglNorm16Ext};function o(e){const[t,n,r,o,a,i]=e;return[n-t+1,o-r+1,i-a+1]}function a(e){const[t,n,r]=o(e);return t*n*r}function i(e,n){const r=new((arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||e.constructor)(n.reduce(((e,t)=>e+a(t)),0)),o=[t.width,t.height,t.depth];let i=0;return n.forEach((t=>{!function(e,t,n,r,o){const[a,i,s,l,c,u]=n,[d,p]=t,f=d*p;let g=o;for(let t=c;t<=u;t++){const n=t*f;for(let t=s;t<=l;t++){const o=n+t*d;for(let t=o+a,n=o+i;t<=n;t++,g++)r[g]=e[t]}}}(e,o,t,r,i),i+=a(t)})),r}function s(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Oo(r)||!Oo(o))){const i=t.context.getExtension("OES_texture_half_float"),s=wo(r),l=wo(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?gd.toHalf(gd.fromHalf(e[u][l+s+t])*h*(1-v)+gd.fromHalf(e[u][l+p+t])*h*v+gd.fromHalf(e[u][c+s+t])*m*(1-v)+gd.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function l(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&r())||e!==Td.UNSIGNED_SHORT&&e!==Td.SHORT)))}function c(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:xd("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||yd(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&xd("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(n,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(n,o,r(),e.useHalfFloat()),a||(a||(yd("Unsupported internal texture type!"),yd(`Unable to find suitable internal format for T=${n} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t._prevTexParams=null,t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=n=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(n){case Td.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case r()&&!o&&Td.SHORT:return t.context.SHORT;case r()&&!o&&Td.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&Td.SHORT:case o&&Td.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Td.FLOAT:case Td.VOID:default:return t.context.FLOAT}switch(n){case Td.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Td.FLOAT:case Td.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case vd.NEAREST:return t.context.NEAREST;case vd.LINEAR:return t.context.LINEAR;case vd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case vd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case vd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case vd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case hd.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case hd.REPEAT:return t.context.REPEAT;case hd.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];const a=[];let s=t.width*t.height*t.components;r&&(s*=t.depth);const l=!!o.length;if(e!==Td.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Float32Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Float32Array(t))}else a.push(null);if(e!==Td.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Uint8Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Uint8Array(t))}else a.push(null);let c=!1;if(t._openGLRenderWindow.getWebgl2())c=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");c=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(c)for(let e=0;e<n.length;e++)if(n[e]){const t=l?i(n[e],o):n[e],r=new Uint16Array(l?t.length:s),c=r.length;for(let e=0;e<c;e++)r[e]=Sd(t[e]);a.push(r)}else a.push(null);if(0===a.length)for(let e=0;e<n.length;e++)a.push(l&&n[e]?i(n[e],o):n[e]);return a},e.create2DFromRaw=function(){let{width:n=Cd("width"),height:o=Cd("height"),numComps:a=Cd("numComps"),dataType:i=Cd("dataType"),data:c=Cd("data"),flip:u=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i,!0),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return bd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=s(e.updateArrayDataTypeForGL(i,d));return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=p[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,p[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,p[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=function(){let{width:n=Cd("width"),height:o=Cd("height"),numComps:a=Cd("numComps"),dataType:i=Cd("dataType"),data:c=Cd("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return bd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=s(e.updateArrayDataTypeForGL(i,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(i,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,o=t.height;for(;r>=1&&o>=1;){let a=null;n<=t.maxLevel&&(a=d[6*n+e]),l(i)?null!=a&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,o,t.format,t.openGLDataType,a):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,o,0,t.format,t.openGLDataType,a),n++,r/=2,o/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=function(){let{width:n=Cd("width"),height:o=Cd("height"),dataType:a=Cd("dataType"),data:i=Cd("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Td.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,r(),e.useHalfFloat()),e.deactivate(),!0):(bd("Failed to determine texture parameters."),!1)},e.create2DFromImage=n=>{if(e.getOpenGLDataType(Td.UNSIGNED_CHAR),e.getInternalFormat(Td.UNSIGNED_CHAR,4),e.getFormat(Td.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return bd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const o=!(t._openGLRenderWindow.getWebgl2()||Oo(n.width)&&Oo(n.height));let a=n,i=n.width,s=n.height,c=!0;const u=window.chrome;if(o||u){const e=new OffscreenCanvas(wo(n.width),wo(n.height));i=e.width,s=e.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n,0,0,n.width,n.height,0,0,e.width,e.height),a=e,c=!1}return t.width=i,t.height=s,t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,c),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(Td.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,a)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,a),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Td.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFromImageBitmap=n=>(e.getOpenGLDataType(Td.UNSIGNED_CHAR),e.getInternalFormat(Td.UNSIGNED_CHAR,4),e.getFormat(Td.UNSIGNED_CHAR,4),t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),t.width=n.width,t.height=n.height,l(Td.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,n)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,n),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Td.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0):(bd("Failed to determine texture parameters."),!1)),e.create2DFilterableFromRaw=function(){let{width:t=Cd("width"),height:n=Cd("height"),numComps:r=Cd("numComps"),dataType:o=Cd("dataType"),data:a=Cd("data"),preferSizeOverAccuracy:i=!1,ranges:s}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create2DFilterableFromDataArray({width:t,height:n,dataArray:xs.newInstance({numberOfComponents:r,dataType:o,values:a,ranges:s}),preferSizeOverAccuracy:i})},e.create2DFilterableFromDataArray=function(){let{width:t=Cd("width"),height:n=Cd("height"),dataArray:r=Cd("dataArray"),preferSizeOverAccuracy:o=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:a,dataType:i,data:s}=c(r,o);e.create2DFromRaw({width:t,height:n,numComps:a,dataType:i,data:s})},e.updateVolumeInfoForGL=(n,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(r()&&!i&&n===Td.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(r()&&!i&&n===Td.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(n===Td.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(n===Td.FLOAT||i&&(n===Td.SHORT||n===Td.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=function(){let{width:i=Cd("width"),height:c=Cd("height"),depth:u=Cd("depth"),numComps:d=Cd("numComps"),dataType:p=Cd("dataType"),data:f=Cd("data"),updatedExtents:g=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=p,h=f;if(!e.updateVolumeInfoForGL(m,d)&&h){const e=i*c*u,n=structuredClone(t.volumeInfo),r=new Float32Array(e*d);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const a=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<d;e++)r[o]=(h[o]-n.offset[e])*a[e],o++;m=Td.FLOAT,h=r}if(e.getOpenGLDataType(m),e.getInternalFormat(m,d),e.getFormat(m,d),!t.internalFormat||!t.format||!t.openGLDataType)return bd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=d,t.width=i,t.height=c,t.depth=u,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const v=g.length>0,T=!v||!ke(t._prevTexParams,n()),y=[h],b=s(e.updateArrayDataTypeForGL(m,y,!0,T?[]:g));if(t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),T)l(m)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=b[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,b[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,b[0]),t._prevTexParams=n();else if(v){const e=b[0];let n=0;for(let r=0;r<g.length;r++){const i=g[r],s=o(i),l=a(i),c=new e.constructor(e.buffer,n,l);n+=c.byteLength,t.context.texSubImage3D(t.target,0,i[0],i[2],i[4],s[0],s[1],s[2],t.format,t.openGLDataType,c)}}return t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(m,r(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(){let{width:t=Cd("width"),height:n=Cd("height"),depth:r=Cd("depth"),numComps:o=Cd("numComps"),dataType:a=Cd("dataType"),data:i=Cd("data"),preferSizeOverAccuracy:s=!1,ranges:l,updatedExtents:c=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create3DFilterableFromDataArray({width:t,height:n,depth:r,dataArray:xs.newInstance({numberOfComponents:o,dataType:a,values:i,ranges:l}),preferSizeOverAccuracy:s,updatedExtents:c})},e.create3DFilterableFromDataArray=function(){let{width:n=Cd("width"),height:r=Cd("height"),depth:o=Cd("depth"),dataArray:a=Cd("dataArray"),preferSizeOverAccuracy:i=!1,updatedExtents:s=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:u,dataType:d,data:p,scaleOffsets:f}=c(a,i),g=[],m=[];for(let e=0;e<u;++e)g[e]=0,m[e]=1;if(t.volumeInfo={scale:m,offset:g,dataComputedScale:f.scale,dataComputedOffset:f.offset,width:n,height:r,depth:o},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw({width:n,height:r,depth:o,numComps:u,dataType:d,data:p,updatedExtents:s});const h=n*r*o,v=structuredClone(f);let T=(e,t,n,r,o)=>{e[t]=n},y=Td.UNSIGNED_CHAR;if(d===Td.UNSIGNED_CHAR)for(let e=0;e<u;++e)v.offset[e]=0,v.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=Td.FLOAT,T=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Td.UNSIGNED_CHAR,T=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,u),e.getFormat(y,u),!t.internalFormat||!t.format||!t.openGLDataType)return bd("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=u,t.depth=1,t.numberOfDimensions=2;let b=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);b>4096&&(y===Td.FLOAT||u>=3)&&(b=4096);let x=1,C=1;h>b*b&&(x=Math.ceil(Math.sqrt(h/(b*b))),C=x);let S=Math.sqrt(h)/x;S=wo(S);const A=Math.floor(S*x/n),I=Math.ceil(o/A),w=wo(r*I/C);let O;t.width=S,t.height=w,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=A,t.volumeInfo.yreps=I,t.volumeInfo.xstride=x,t.volumeInfo.ystride=C,t.volumeInfo.offset=v.offset,t.volumeInfo.scale=v.scale;const P=S*w*u;O=y===Td.FLOAT?new Float32Array(P):new Uint8Array(P);let R=0;const M=Math.floor(n/x),E=Math.floor(r/C);for(let e=0;e<I;e++){const a=Math.min(A,o-e*A),i=u*(t.width-a*Math.floor(n/x));for(let t=0;t<E;t++){for(let o=0;o<a;o++){const a=u*((e*A+o)*n*r+C*t*n);for(let e=0;e<M;e++)for(let t=0;t<u;t++)T(O,R,p[a+x*e*u+t],v.offset[t],v.scale[t]),R++}R+=i}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=O&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,O)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,O),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Id={_openGLRenderWindow:null,_forceInternalFormat:!1,_prevTexParams:null,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:hd.CLAMP_TO_EDGE,wrapT:hd.CLAMP_TO_EDGE,wrapR:hd.CLAMP_TO_EDGE,minificationFilter:vd.NEAREST,magnificationFilter:vd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function wd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Id,n),qt.extend(e,t,n),t.sendParametersTime={},ht(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},ht(t.textureBuildTime,{mtime:0}),xt(e,t,["format","openGLDataType"]),Ct(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),Tt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),wt(0,t,["openGLRenderWindow"]),Ad(e,t)}const Od=Mt(wd,"vtkOpenGLTexture");var Pd={newInstance:Od,extend:wd,...dd};Jt("vtkTexture",Od);var Rd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",Md="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",Ed=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=td.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=td.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=td.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=td.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=td.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=td.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=td.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},Vd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=td.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Dd}=Us,{primTypes:Ld}=ld,{Representation:Bd,Shading:Nd}=os,{ScalarMode:Fd}=Gl,{Filter:_d,Wrap:kd}=Pd,{vtkErrorMacro:Gd}=Ht,Ud={type:"StartEvent"},zd={type:"EndEvent"},{CoordinateSystem:Wd}=Ki;const Hd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:Al.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function jd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hd,n),qt.extend(e,t,n),Ed(e,t,n),Vd(e,t,n),t.primitives=[],t.primTypes=Ld,t.tmpMat3=fe(new Float64Array(9)),t.tmpMat4=m(new Float64Array(16));for(let e=Ld.Start;e<Ld.End;e++)t.primitives[e]=ld.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);Ct(e,t,["context"]),t.VBOBuildTime={},ht(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},ht(t.selectionStateChanged,{mtime:0}),function(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Ld.Start;e<Ld.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=Rd,e.Fragment=Md,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=td.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=td.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=td.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=td.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=td.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=td.substitute(i,"//VTK::Color::Impl",c).result):i=td.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=td.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=td.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=td.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=td.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=td.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=td.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=td.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:Gd("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=td.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=td.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=td.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=td.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=td.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=td.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=td.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=td.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=td.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=td.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=td.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=td.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=td.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=td.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=td.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=td.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=td.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=td.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=td.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=td.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=td.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=td.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=td.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=td.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=td.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=td.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=td.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=td.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=td.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=td.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=td.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=td.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=td.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=td.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=td.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=td.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=td.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=td.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=td.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=td.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=td.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==gl.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===Bd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===Ld.Points||o.getRepresentation()===Bd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===Ld.Lines||o.getRepresentation()===Bd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==Ld.Tris&&e!==Ld.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==Ld.TrisEdges&&e!==Ld.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Dd.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=td.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==Al.ID_LOW24&&t.lastSelectionState!==Al.ID_HIGH24||(a=td.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=td.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=td.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=td.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case Al.ID_LOW24:o=td.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case Al.ID_HIGH24:o=td.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=td.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=td.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=td.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=td.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===Nd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||Gd("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||Gd("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||Gd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||Gd("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||Gd("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?p(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(h(i,i),b(i,i,a),h(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],Fo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],Fo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();h(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);In(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),g=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Wd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();m(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,b(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,g.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,g.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,g.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Dd.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():Al.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Bd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Dd.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===Al.ID_LOW24||t.lastSelectionState===Al.ID_HIGH24);for(let i=Ld.Start;i<Ld.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===Ld.TrisEdges||i===Ld.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(Ud),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(zd),!t.currentInput)return void Gd("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Fd.USE_CELL_DATA&&a!==Fd.USE_CELL_FIELD_DATA&&a!==Fd.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Fd.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==Nd.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Pd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(_d.NEAREST),e.setMagnificationFilter(_d.NEAREST),e.setWrapS(kd.CLAMP_TO_EDGE),e.setWrapT(kd.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===Bd.SURFACE;for(let n=Ld.Start;n<Ld.End;n++)n!==Ld.TrisEdges&&n!==Ld.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,Bd.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}const Kd=Mt(jd,"vtkOpenGLPolyDataMapper");var $d={newInstance:Kd,extend:jd};Jt("vtkMapper",Kd);const qd=1,{primTypes:Xd}=ld,{Filter:Yd,Wrap:Zd}=Pd,{vtkErrorMacro:Qd}=Ht,Jd={type:"StartEvent"},ep={type:"EndEvent"},tp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const np=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tp,n),qt.extend(e,t,n),Ed(e,t,n),Vd(e,t,n),t.primitives=[],t.primTypes=Xd,t.tmpMat4=m(new Float64Array(16));for(let e=Xd.Start;e<Xd.End;e++)t.primitives[e]=ld.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);Ct(e,t,["context"]),t.VBOBuildTime={},ht(t.VBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Xd.Start;e<Xd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{if(e.invokeEvent(Jd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(ep),!t.currentInput)return void Qd("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors(),a=n.getProperty().getRepresentation();let i=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(i=null);let s=!1;if(t.renderable.getColorCoordinates()){i=t.renderable.getColorCoordinates(),s=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Pd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Yd.NEAREST),e.setMagnificationFilter(Yd.NEAREST),e.setWrapS(Zd.CLAMP_TO_EDGE),e.setWrapT(Zd.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${a}B${r.getMTime()}C${o?o.getMTime():1}D${i?i.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=Yl.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const c={points:n,tcoords:i,colors:o,cellOffset:0,useTCoordsPerCell:s,haveCellScalars:t.renderable.getAreScalarsMappedFromCells(),customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};c.cellOffset+=t.primitives[Xd.Points].getCABO().createVBO(r.getVerts(),"verts",a,c),c.cellOffset+=t.primitives[Xd.Lines].getCABO().createVBO(r.getLines(),"lines",a,c),c.cellOffset+=t.primitives[Xd.Tris].getCABO().createVBO(r.getPolys(),"polys",a,c),c.cellOffset+=t.primitives[Xd.TriStrips].getCABO().createVBO(r.getStrips(),"strips",a,c),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=Xd.Start;a<Xd.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment,s=["uniform vec3 diffuseColorUniform;","uniform float opacityUniform;"],l=["vec3 diffuseColor = diffuseColorUniform;","float opacity = opacityUniform;"];0!==t.lastBoundBO.getCABO().getColorComponents()?(s=s.concat(["varying vec4 vertexColorVSOutput;"]),o=td.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=td.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=td.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=td.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,i=td.substitute(i,"//VTK::Color::Impl",l.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result):t.renderable.getAreScalarsMappedFromCells()&&(l=l.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  opacity = opacity*texColor.a;"])),l=l.concat(["gl_FragData[0] = vec4(diffuseColor, opacity);"]),i=td.substitute(i,"//VTK::Color::Dec",s).result,i=td.substitute(i,"//VTK::Color::Impl",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=td.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=td.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=td.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=td.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=td.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=td.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=td.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=td.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=td.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=td.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=td.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=td.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.renderable.getAreScalarsMappedFromCells()&&(r=td.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=td.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=td.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Qd("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Qd(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Qd("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),e.getProgram().isAttributeUsed("scalarColor")&&e.getCABO().getColorComponents()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"scalarColor",e.getCABO().getColorOffset(),e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||Qd("Error setting scalarColor in shader VAO."):e.getVAO().removeAttributeArray("scalarColor"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&t.internalColorTexture.getTextureUnit()>-1&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity();t.setUniformf("opacityUniform",o);const a=n.getColor();t.setUniform3fArray("diffuseColorUniform",a)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=yo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=yo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=yo(c[0]-(d[0]-l[0])*p[0]),g=yo(c[1]-(d[1]-l[1])*p[1]),v=-f;let T=-f+s[0];const y=-g;let b=-g+s[1];v===T&&(T=v+1),y===b&&(b=y+1);const x=m(new Float64Array(16));var C,S,A;x[0]=2/(T-v),x[5]=2/(b-y),x[3]=-1*(T+v)/(T-v),x[7]=-1*(b+y)/(b-y),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===qd?-1:1,x[15]=1,h(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}),"vtkOpenGLPolyDataMapper2D");Jt("vtkMapper2D",np);var rp={Orientation:{HORIZONTAL:"horizontal",VERTICAL:"vertical",AUTO:"auto"}};const{VectorMode:op}=cl,{Orientation:ap}=rp;function ip(e,t,n){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor;const r=t.fontSize??n;e.font=`${t.fontStyle} ${r}px ${t.fontFamily}`}function sp(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),void 0===i.fontSize&&(i.fontSize=Math.max(24*a,12)),void 0===s.fontSize&&(e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10));const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();let u=!1;if(u=t.orientation===ap.VERTICAL||t.orientation!==ap.HORIZONTAL&&e.getLastAspectRatio()>1,u)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function lp(e,t){return e=>{const t=e.getLastTickBounds(),n=ro().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}const cp=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Wt.obj(e,t),Wt.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings","tickPositions"]),Wt.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),Wt.getArray(e,t,["boxPosition","boxSize"]),Wt.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},Wt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=Gl.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=gu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=ss.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=gu.newInstance(),t.tmMapper=Gl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=vu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=ss.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;ip(t.tmContext,t.axisTextStyle,18);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,ip(t.tmContext,t.tickTextStyle,14);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=wo(o),a=wo(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{const r=e.textStyle===t.axisTextStyle?18:14;ip(t.tmContext,e.textStyle,r),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),T=e.getTicks(),y=e.getTickStrings(),b=e.getTickPositions();for(let n=0;n<T.length;n++){const o=b?b[n]:(T[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(y[n],r,p,"horizontal",g,c)}const x=xs.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(x),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===op.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=xs.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}(e,t)}),"vtkScalarBarActorHelper");function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,function(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:void 0,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:void 0,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,orientation:null,...e}}(n)),t.autoLayout||(t.autoLayout=sp(0,t)),t.generateTicks||(t.generateTicks=lp()),ss.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),Wt.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch","orientation"]),Wt.get(e,t,["axisTextStyle","tickTextStyle"]),Wt.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),Wt.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),function(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.setOrientationToHorizontal=()=>e.setOrientation(ap.HORIZONTAL),e.setOrientationToVertical=()=>e.setOrientation(ap.VERTICAL),e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(sp(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(lp())}}(e,t)}var dp={newInstance:Wt.newInstance(up,"vtkScalarBarActor"),extend:up,newScalarBarActorHelper:cp,...rp};const pp={};const fp=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pp,n),qt.extend(e,t,n),t.scalarBarActorHelper=dp.newScalarBarActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLScalarBarActor");Jt("vtkScalarBarActor",fp);const{vtkErrorMacro:gp}=Ht,mp={context:null};const hp=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mp,n),qt.extend(e,t,n),t.openGLTexture=Pd.newInstance(),t.tris=ld.newInstance(),t.keyMatrixTime={},ht(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:fe(new Float64Array(9)),mcwc:m(new Float64Array(16))},Ct(e,t,["context"]),Tt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(v(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=xs.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=xs.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",Zi.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||gp("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||gp("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}(e,t)}));Jt("vtkSkybox",hp);const{FieldAssociations:vp}=Us,Tp={fieldAssociation:vp.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tp,n),Wt.obj(e,t),Wt.setGet(e,t,["fieldAssociation","captureZValues"]),function(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}(e,t)}var bp={newInstance:Wt.newInstance(yp,"vtkHardwareSelector"),extend:yp};const xp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Cp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xp,n),ht(e,t),t.colorBuffers&&et("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],St(e,t,["colorBuffers"]),function(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null===n&&(n=t.context.FRAMEBUFFER),t.context.bindFramebuffer(n,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et("Attaching depth buffer textures to fbo requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et("Attaching depth buffer textures to framebuffers requires WebGL 2");else et("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void et("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=Pd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(ud.LINEAR),r.setMagnificationFilter(ud.LINEAR),r.create2DFromRaw({width:t.glFramebuffer.width,height:t.glFramebuffer.height,numComps:4,dataType:cs.UNSIGNED_CHAR,data:null}),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}(e,t)}var Sp={newInstance:Mt(Cp,"vtkFramebuffer"),extend:Cp};const Ap={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function Ip(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ap,n),Wt.obj(e,t),t.properties={},Wt.setGet(e,t,["contentType","fieldType","properties","selectionList"]),function(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}(e,t)}var wp={newInstance:Wt.newInstance(Ip,"vtkSelectionNode"),extend:Ip,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Op}=Il,{SelectionContent:Pp,SelectionField:Rp}=wp,{FieldAssociations:Mp}=Us,{vtkErrorMacro:Ep}=Wt;function Vp(e){return`${e.propID} ${e.compositeID}`}function Dp(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function Lp(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function Bp(e,t){let n=t;return n<<=24,n|=e,n}function Np(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=Lp(n[0],n[1],e.pixBuffer[Op.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=Lp(n[0],n[1],e.pixBuffer[Op.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Op.ID_LOW24]&&0===Dp(n[0],n[1],e.pixBuffer[Op.ID_LOW24],e.area))return a;const s=Lp(n[0],n[1],e.pixBuffer[Op.ID_LOW24],e.area),l=Lp(n[0],n[1],e.pixBuffer[Op.ID_HIGH24],e.area);return a.attributeID=Bp(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=Np(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Np(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=Np(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Np(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=Np(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function Fp(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=wp.newInstance();switch(l.setContentType(Pp.INDICES),e){case Mp.FIELD_ASSOCIATION_CELLS:l.setFieldType(Rp.CELL);break;case Mp.FIELD_ASSOCIATION_POINTS:l.setFieldType(Rp.POINT);break;default:Ep("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}const _p={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function kp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_p,n),bp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),Wt.setGetArray(e,t,["area"],4),Wt.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),Wt.setGetArray(e,t,["propColorValue"],3),Wt.moveToProtected(e,t,["renderer","openGLRenderWindow"]),Wt.event(e,t,"event"),function(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=Sp.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===Mp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Np(e,[n,t],0,u);if(r&&r.valid){const t=Vp(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return Fp(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return Ep("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=Op.MIN_KNOWN_PASS;t.currentPass<=Op.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Op.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=Op.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Op.ID_HIGH24){if(t.fieldAssociation===Mp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===Mp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Op.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=Lp(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Op.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Op.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>Wt.enumToString(Op,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=Lp(e[0],e[1],t.pixBuffer[Op.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=Lp(e[0],e[1],t.pixBuffer[Op.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Op.ID_LOW24]&&0===Dp(e[0],e[1],t.pixBuffer[Op.ID_LOW24],t.area))return a;const s=Lp(e[0],e[1],t.pixBuffer[Op.ID_LOW24],t.area),l=Lp(e[0],e[1],t.pixBuffer[Op.ID_HIGH24],t.area);return a.attributeID=Bp(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=Vp(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return Fp(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}(e,t)}var Gp={newInstance:Wt.newInstance(kp,"vtkOpenGLHardwareSelector"),extend:kp,...Il};const{vtkErrorMacro:Up}=Ht,{Representation:zp}=os,{ObjectType:Wp}=zu,{PassTypes:Hp}=Gp,jp={type:"StartEvent"},Kp={type:"EndEvent"};function $p(e,t,n){e[12]=(e[12]-t[0])*n[0],e[13]=(e[13]-t[1])*n[1],e[14]=(e[14]-t[2])*n[2],e[0]*=n[0],e[5]*=n[1],e[10]*=n[2]}const qp={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Xp=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),$d.extend(e,t,n),t.tmpMat3=fe(new Float64Array(9)),t.normalMatrix=fe(new Float64Array(9)),t.mcpcMatrix=m(new Float64Array(16)),t.mcvcMatrix=m(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},ht(t.glyphBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(jp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(Kp),!t.currentInput)return void Up("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],T=t[14],y=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*T,e[3]=b*s+x*d+C*m+S*y,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*T,e[7]=b*s+x*d+C*m+S*y,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*T,e[11]=b*s+x*d+C*m+S*y,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*T,e[15]=b*s+x*d+C*m+S*y},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=td.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=td.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderClip=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex,r=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();n=td.substitute(n,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,n=td.substitute(n,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    vec4 gVertex = gMatrix * vertexMC;","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], gVertex);","    }"]).result,r=td.substitute(r,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,r=td.substitute(r,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=n,e.Fragment=r}n.replaceShaderClip(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=td.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=td.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=td.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=td.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=td.substitute(o,"//VTK::Color::Impl",s).result,o=td.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=td.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=td.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=td.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=td.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=td.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=td.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=td.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=td.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],T=n[r+1],y=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+T*d+y*g,o[1]=v*i+T*p+y*m,o[2]=v*c+T*f+y*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===zp.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();Te(t.normalMatrix,s.normalMatrix,l.normalMatrix),b(t.mcpcMatrix,s.wcpc,l.mcwc),b(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===Hp.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||Up("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||Up("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Up("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Up("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{const o=t.renderable.getMatrixArray(),a=t.renderable.getInputData(0).getPoints(),{useShiftAndScale:i,coordShift:s,coordScale:l}=Wu(a);if(t.hardwareSupport){const e=t.renderable.getNormalArray(),n=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=zu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=zu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=zu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=zu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),i){const e=o.buffer;for(let t=0;t<o.byteLength;t+=64)$p(new Float32Array(e,t,16),s,l)}if(t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(o,Wp.ARRAY_BUFFER),t.normalBuffer.upload(e,Wp.ARRAY_BUFFER),n?t.colorBuffer.upload(n.getData(),Wp.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const r=o.length/16,a=new Uint8Array(4*r);for(let e=0;e<r;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,Wp.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}if(n.buildBufferObjects(e,r),i)for(let e=ad.Start;e<ad.End;e++)t.primitives[e].getCABO().setCoordShiftAndScale(s,l)}}(e,t)}),"vtkOpenGLGlyph3DMapper");Jt("vtkGlyph3DMapper",Xp);const{vtkErrorMacro:Yp}=Wt;class Zp{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}const Qp={};function Jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qp,n),Wt.obj(e,t),Wt.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Yp("Invalid or missing input");const r=t[0]?.initialize()||gu.newInstance();r.shallowCopy(n);const o=new Zp,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(Kl.newInstance({values:c,name:"faces"})),t[0]=r}}(e,t)}var ef={newInstance:Wt.newInstance(Jp,"vtkClosedPolyLineToSurfaceFilter"),extend:Jp};const{vtkErrorMacro:tf}=Ht;function nf(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void tf("Invalid or missing input");if(!t.cutFunction)return void tf("Missing cut function");const o=n[0]?.initialize()||gu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=e.getPointData(),i=r.getNumberOfPoints(),s=[],l=[],c=[],u={},d=a.getNumberOfArrays();for(let e=0;e<d;e++)u[a.getArrayName(e)]=[];(!t.cutScalars||t.cutScalars.length<i)&&(t.cutScalars=new Float32Array(i));let p=0,f=0;for(;p<o.length;)t.cutScalars[f++]=t.cutFunction.evaluateFunction(o[p++],o[p++],o[p++]);const g=[],m=new Array(3),h=new Array(3),v=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)v[e]=t.cutScalars[n.cell[e++]];const e=v[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(v[t]>0!==e){r=!1;break}if(r)continue;const i=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,s=v[e]>0;if(v[r]>0===s)continue;let l=e,c=r,u=v[c]-v[l];u<=0&&(l=r,c=e,u*=-1);let p=0;0!==u&&(p=(t.cutValue-v[l])/u);const f=n.cell[l],g=n.cell[c];m[0]=o[3*f],m[1]=o[3*f+1],m[2]=o[3*f+2],h[0]=o[3*g],h[1]=o[3*g+1],h[2]=o[3*g+2];const T=[m[0]+p*(h[0]-m[0]),m[1]+p*(h[1]-m[1]),m[2]+p*(h[2]-m[2])],y={};for(let e=0;e<d;e++){const t=a.getArrayByIndex(e),n=a.getArrayName(e),r=t.getData(),o=t.getNumberOfComponents(),i=new Array(o);for(let e=0;e<o;e++){const t=r[o*f+e],n=r[o*g+e];i.push(t+p*(n-t))}y[n]=i}i.push({pointEdge1:f,pointEdge2:g,intersectedPoint:T,intersectedArrays:y,newPointID:-1})}for(let e=0;e<i.length;e++){const t=i[e];let n=!1;for(let r=0;r<g.length;r++){const o=g[r],a=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(a||s){n=!0,i[e].newPointID=g[r].newPointID;break}}n||(s.push(t.intersectedPoint[0]),s.push(t.intersectedPoint[1]),s.push(t.intersectedPoint[2]),Object.keys(t.intersectedArrays).forEach((e=>{u[e].push(...t.intersectedArrays[e])})),i[e].newPointID=s.length/3-1,g.push(i[e]))}const p=i.length;2===p?l.push(p,i[0].newPointID,i[1].newPointID):p>2&&(c.push(p),i.forEach((e=>{c.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),s),3);const T=n.getPointData();for(let e=0;e<d;e++){const t=a.getArrayName(e),n=xs.newInstance({name:t,dataType:a.getArrayByIndex(e).getDataType(),values:u[t],numberOfComponents:a.getArrayByIndex(e).getNumberOfComponents()});T.addArray(n)}0!==l.length&&n.getLines().setData(Uint16Array.from(l)),0!==c.length&&n.getPolys().setData(Uint16Array.from(c))})(r,o),n[0]=o}}const rf={cutFunction:null,cutScalars:null,cutValue:0};function of(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rf,n),ht(e,t),Ot(e,t,1,1),Ct(e,t,["cutFunction","cutValue"]),nf(e,t)}var af={newInstance:Mt(of,"vtkCutter"),extend:of};const sf=e=>e,lf=1e-6;class cf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=m(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?c:sf}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);hn(n,e[0],e[1],e[2]),hn(r,t[0],t[1],t[2]),Cn(n,n),Cn(r,r);const a=Sn(n,r);return a>=1||(An(this.tmp,n,r),gn(this.tmp)<lf&&(An(this.tmp,[1,0,0],e),gn(this.tmp)<lf&&An(this.tmp,[0,1,0],e)),R(o,Math.acos(a),this.tmp),b(this.matrix,this.matrix,o)),this}rotate(e,t){return hn(this.tmp,...t),Cn(this.tmp,this.tmp),S(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return w(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return hn(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return hn(this.tmp,e,t,n),C(this.matrix,this.matrix,this.tmp),this}multiply(e){return b(this.matrix,this.matrix,e),this}multiply3x3(e){return b(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return v(this.matrix,this.matrix),this}identity(){return m(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(Xo(ao,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)hn(this.tmp,e[n],e[n+1],e[n+2]),In(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&p(this.matrix,e),this}}var uf=function(){return new cf(!0)},df=function(){return new cf(!1)};const pf=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],ff=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22],gf={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function mf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gf,n),Wt.obj(e,t),Wt.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),Wt.setGetArray(e,t,["center","rotations"],3),Wt.setGetArray(e,t,["matrix"],16),t._polys=Kl.newInstance({values:Uint16Array.from(ff)}),t._lineCells=Kl.newInstance({values:Uint16Array.from(pf)}),Wt.moveToProtected(e,t,["polys","lineCells"]),Wt.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCubeSource"),e.requestData=(e,n)=>{const r=n[0]?.initialize()||gu.newInstance();n[0]=r;const o=Wt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=Wt.newTypedArray(t.pointType,72),i=xs.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=Wt.newTypedArray(t.pointType,24*s),c=xs.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&uf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&df().translate(...t.center).apply(o),t.matrix){df().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];df().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()},e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))}}(e,t)}var hf={newInstance:Wt.newInstance(mf,"vtkCubeSource"),extend:mf};const{vtkErrorMacro:vf}=Wt,Tf={};function yf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Wt.obj(e,t),Wt.algo(e,t,1,1),t._cubeSource=hf.newInstance(),Wt.moveToProtected(e,t,["cubeSource","tmpOut"]),function(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void vf("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):vf("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}(e,t)}var bf={newInstance:Wt.newInstance(yf,"vtkImageDataOutlineFilter"),extend:yf};const{vtkWarningMacro:xf}=Wt;let Cf;const Sf={preMultiplyFlag:!1,matrix:[...ao]};function Af(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sf,n),Wt.obj(e,t),Wt.setGet(e,t,["preMultiplyFlag"]),Wt.setGetArray(e,t,["matrix"],16),function(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(In(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],In(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?b(n,t.matrix,e):b(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>b(o,t.matrix,r):()=>b(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>Cf({matrix:Da.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag}),e.translate=(n,r,o)=>{if(0===n&&0===r&&0===o)return;const a=u();O(a,[n,r,o]),t.preMultiplyFlag?b(t.matrix,t.matrix,a):b(t.matrix,a,t.matrix),e.modified()},e.rotateWXYZ=(n,r,o,a)=>{if(0===r&&0===o&&0===a)return void xf("No rotation applied, axis is zero vector.");if(0===n)return;const i=Da.radiansFromDegrees(n),s=Ba();Na(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),t.preMultiplyFlag?b(t.matrix,t.matrix,l):b(t.matrix,l,t.matrix),e.modified()},e.rotateX=t=>{e.rotateWXYZ(t,1,0,0)},e.rotateY=t=>{e.rotateWXYZ(t,0,1,0)},e.rotateZ=t=>{e.rotateWXYZ(t,0,0,1)},e.scale=(n,r,o)=>{if(1===n&&1===r&&1===o)return;const a=u();P(a,[n,r,o]),t.preMultiplyFlag?b(t.matrix,t.matrix,a):b(t.matrix,a,t.matrix),e.modified()},e.transformNormal=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const o=le(se(),t.matrix),a=se();me(a,o);const i=se();return ge(i,a),e.transformVector(n,r,i),Da.normalize(r),r},e.transformNormals=(n,r)=>{const o=n.getData(),a=r.getData(),i=[0,0,0],s=le(se(),t.matrix),l=se();me(l,s);const c=se();ge(c,l);for(let t=0;t<o.length;t+=3)i[0]=o[t],i[1]=o[t+1],i[2]=o[t+2],e.transformVector(i,i,c),Da.normalize(i),a[t]=i[0],a[t+1]=i[1],a[t+2]=i[2]},e.transformVector=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,(arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||le(se(),t.matrix)),n},e.transformVectors=(t,n)=>{const r=t.getData(),o=n.getData(),a=[0,0,0];for(let t=0;t<r.length;t+=3)a[0]=r[t],a[1]=r[t+1],a[2]=r[t+2],e.transformVector(a,a),Da.normalize(a),o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2]},e.transformPointsNormalsVectors=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;const c=t.getNumberOfPoints(),u=s?.length??0,d=new Float64Array(3),p=new Float64Array(3),f=new Float64Array(3),g=new Float64Array(3);let m=!1,h=!1,v=!1;const T=[];for(let y=0;y<c;y++){if(t.getPoint(y,d),p.set(d),e.transformPoint(d,d),n.setPoint(y,...d),Da.areEquals(p,d)||(m=!0),a){const t=a.getData(),n=i.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],f.set(d),e.transformVector(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],Da.areEquals(f,d)||(h=!0)}if(r){const t=r.getData(),n=o.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],g.set(d),e.transformNormal(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],Da.areEquals(g,d)||(v=!0)}if(s)for(let t=0;t<u;t++){const n=s[t].getData(),r=l[t].getData();d[0]=n[3*y],d[1]=n[3*y+1],d[2]=n[3*y+2],f.set(d),e.transformVector(d,d),r[3*y]=d[0],r[3*y+1]=d[1],r[3*y+2]=d[2],Da.arrayEqual(f,d)||T.includes(t)||T.push(t)}}m&&n.modified(),h&&i.modified(),v&&o.modified(),T.forEach((e=>l[e].modified()))}}(e,t)}Cf=Wt.newInstance(Af,"vtkTransform");var If={newInstance:Cf,extend:Af};function wf(e,t,n){return e.length>0?`${e.map((e=>e?.getMTime()??"x")).join("/")}-${t}-${n}`:"0"}function Of(e,t){return`${t.getMTime()}`}const Pf={NEAREST:0,LINEAR:1};var Rf={InterpolationType:Pf};const{vtkErrorMacro:Mf}=Ht;function Ef(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}const Vf={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastNumberOfComponents:0,lastMultiTexturePerVolumeEnabled:!1,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,scalarTextures:[],_scalarTexturesCore:[],colorTexture:null,_colorTextureCore:null,pwfTexture:null,_pwfTextureCore:null,_externalOpenGLTexture:!1,resliceGeom:null,resliceGeomUpdateString:null,tris:null};const Df=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vf,n),qt.extend(e,t,n),Ed(e,t,n),Vd(e,t,n),t.tris=ld.newInstance(),t.scalarTextures=[],t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},ht(t.VBOBuildTime),t.tmpMat4=m(new Float64Array(16)),t.outlineFilter=bf.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=gu.newInstance(),t.cutter=af.newInstance(),t.lineToSurfaceFilter=ef.newInstance(),t.transform=If.newInstance(),Tt(e,t,["scalarTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageResliceMapper");const n=new Map;function o(t,r,o){r!==o&&(function(t,r){if(!r)return;const o=(n.get(r)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(r,e),n.delete(r)):n.set(r,o)}(t,r),function(t,r){if(!r)return;const o=n.get(r)??0,a=o+1;n.set(r,a),o<=0&&t.registerGraphicsResourceUser(r,e)}(t,o))}function a(t){[...n.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera());const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&a(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==gl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}const a=t.currentValidInputs.length;if(a<=0)return void Mf("No input!");const i=t.currentValidInputs[0].imageData.getPointData().getScalars();t.multiTexturePerVolumeEnabled=a>1,t.numberOfComponents=t.multiTexturePerVolumeEnabled?a:i.getNumberOfComponents(),e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r);const o=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=o[n].getInterpolationType(),a=t.scalarTextures[n];r===Pf.NEAREST?(a.setMinificationFilter(ud.NEAREST),a.setMagnificationFilter(ud.NEAREST)):(a.setMinificationFilter(ud.LINEAR),a.setMagnificationFilter(ud.LINEAR))}));const a=t.currentValidInputs[0];o[a.inputIndex].getInterpolationType()===Pf.NEAREST?(t.colorTexture.setMinificationFilter(ud.NEAREST),t.colorTexture.setMagnificationFilter(ud.NEAREST),t.pwfTexture.setMinificationFilter(ud.NEAREST),t.pwfTexture.setMagnificationFilter(ud.NEAREST)):(t.colorTexture.setMinificationFilter(ud.LINEAR),t.colorTexture.setMagnificationFilter(ud.LINEAR),t.pwfTexture.setMinificationFilter(ud.LINEAR),t.pwfTexture.setMagnificationFilter(ud.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.pwfTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(e,n)=>{const r=n.getProperties();t.currentValidInputs.forEach(((e,n)=>{let{imageData:a}=e;const i=a.getPointData().getScalars(),s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=Of(0,i),c=!s?.oglObject?.getHandle()||s?.hash!==l,u=r[n],d=u.getUpdatedExtents(),p=!!d.length;if(c&&!p){const e=Pd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const r=a.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:r[0],height:r[1],depth:r[2],dataArray:i}),t._openGLRenderWindow.setGraphicsResourceForObject(i,e,l),t.scalarTextures[n]=e}else t.scalarTextures[n]=s.oglObject;if(p){u.setUpdatedExtents([]);const e=a.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:i,updatedExtents:d})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],i),t._scalarTexturesCore[n]=i}));const a=t.currentValidInputs[0],i=r[a.inputIndex],s=i.getIndependentComponents(),l=s?t.numberOfComponents:1,c=s?2*l:1,u=[];for(let e=0;e<l;++e)u.push(i.getRGBTransferFunction(e));const d=wf(u,s,l),p=i.getRGBTransferFunction(),f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.oglObject?.getHandle()&&f?.hash===d)t.colorTexture=f.oglObject;else{let e=t.renderable.getColorTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=new Uint8ClampedArray(e*c*3),r=Pd.newInstance();if(r.setOpenGLRenderWindow(t._openGLRenderWindow),p){const t=new Float32Array(3*e);for(let r=0;r<l;r++){const o=i.getRGBTransferFunction(r),a=o.getRange();if(o.getTable(a[0],a[1],e,t,1),s)for(let o=0;o<3*e;o++)n[r*e*6+o]=255*t[o],n[r*e*6+o+3*e]=255*t[o];else for(let o=0;o<3*e;o++)n[r*e*3+o]=255*t[o]}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:c,numComps:3,dataType:cs.UNSIGNED_CHAR,data:n})}else{for(let t=0;t<3*e;++t){const r=255*t/(3*(e-1));for(let o=0;o<c;++o)n[o*e*3+t+0]=r,n[o*e*3+t+1]=r,n[o*e*3+t+2]=r}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:1,numComps:3,dataType:cs.UNSIGNED_CHAR,data:n})}p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,r,d),t.colorTexture=r}o(t._openGLRenderWindow,t._colorTextureCore,p),t._colorTextureCore=p;const g=[];for(let e=0;e<l;++e)g.push(i.getPiecewiseFunction(e));const m=wf(g,s,l),h=i.getPiecewiseFunction(),v=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(v?.oglObject?.getHandle()&&v?.hash===m)t.pwfTexture=v.oglObject;else{let e=t.renderable.getOpacityTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=e*c,r=new Uint8ClampedArray(n),o=Pd.newInstance();if(o.setOpenGLRenderWindow(t._openGLRenderWindow),h){const t=new Float32Array(n),r=new Float32Array(e);for(let n=0;n<l;++n){const o=i.getPiecewiseFunction(n);if(null===o)t.fill(1);else{const a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),s)for(let o=0;o<e;o++)t[n*e*2+o]=r[o],t[n*e*2+o+e]=r[o];else for(let n=0;n<e;n++)t[n]=r[n]}}o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:cs.FLOAT,data:t})}else r.fill(255),o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:cs.UNSIGNED_CHAR,data:r});h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,o,m),t.pwfTexture=o}o(t._openGLRenderWindow,t._pwfTextureCore,h),t._pwfTextureCore=h;const T=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==T){const e=xs.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=xs.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:Mf("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",Zi.SURFACE,r)}t.VBOBuildString=T,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.currentValidInputs[0].imageData;if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())})),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Mf("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Mf("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",i.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=i.getDimensions();p(t.tmpMat4,i.getIndexToWorld()),x(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),C(t.tmpMat4,t.tmpMat4,n),v(t.tmpMat4,t.tmpMat4),e&&b(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(m(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",Ef([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(m(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",Ef([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(t.currentValidInputs[0].inputIndex),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.numberOfComponents,l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));for(let e=0;e<s;e++){const n=t.multiTexturePerVolumeEnabled,r=n?e:0,i=n?0:e,s=t.scalarTextures[r].getVolumeInfo(),c=s.scale[i],u=s.offset[i],d=l?e:0;let p=a.getColorWindow(),f=a.getColorLevel();const g=a.getRGBTransferFunction(d);if(g&&a.getUseLookupTableScalarRange()){const e=g.getRange();p=e[1]-e[0],f=.5*(e[1]+e[0])}const m=c/p,h=(u-f)/p+.5;o.setUniformf(`cshift${e}`,h),o.setUniformf(`cscale${e}`,m);let v=1,T=0;const y=a.getPiecewiseFunction(d);if(y){const e=y.getRange(),t=e[1]-e[0];v=c/t,T=(u-.5*(e[0]+e[1]))/t+.5}o.setUniformf(`pwfshift${e}`,T),o.setUniformf(`pwfscale${e}`,v)}const c=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",u),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents(),a=t.renderable.getSlabThickness(),i=t.renderable.getSlabType(),s=t.renderable.getSlabTrapezoidIntegration();let l=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(l=!0),!(!l&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&t.lastNumberOfComponents===t.numberOfComponents&&t.lastMultiTexturePerVolumeEnabled===t.multiTexturePerVolumeEnabled&&0!==e.getProgram()?.getHandle()&&t.lastIndependentComponents===o&&t.lastSlabThickness===a&&t.lastSlabType===i&&t.lastSlabTrapezoidIntegration===s||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastNumberOfComponents=t.numberOfComponents,t.lastMultiTexturePerVolumeEnabled=t.multiTexturePerVolumeEnabled,t.lastIndependentComponents=o,t.lastSlabThickness=a,t.lastSlabType=i,t.lastSlabTrapezoidIntegration=s,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=td.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=td.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=td.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=td.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.numberOfComponents,c=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents();let u=["in vec3 fragTexCoord;",`uniform highp sampler3D volumeTexture[${t.scalarTextures.length}];`,"uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(u.push("vec4 rawSampleTexture(vec3 pos) {"),t.multiTexturePerVolumeEnabled){u.push("vec4 rawSample;");for(let e=0;e<t.scalarTextures.length;++e)u.push(`rawSample[${e}] = texture(volumeTexture[${e}], pos)[0];`);u.push("return rawSample;","}")}else u.push("return texture(volumeTexture[0], pos);","}");if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Mf("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=td.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = rawSampleTexture(fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Mf("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=td.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=td.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=td.substitute(a,"//VTK::PositionVC::Impl",u).result,a=td.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=td.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentValidInputs[0].imageData,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=se();n&&(e=e.concat(`Image${n.getMTime()}`),pe(t,...n.getDirection()),me(t,t));const r=[...s.getNormal()];wn(r,r,t),[o,a]=function(e){Da.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=Da.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ei.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();Da.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=xs.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=gu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();Da.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=xs.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else Mf("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setScalarTextures=e=>{t.scalarTextures=[...e],t._externalOpenGLTexture=!0},e.delete=Et((()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageResliceMapper");Jt("vtkImageResliceMapper",Df);var Lf={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:Bf}=Ht,{SlicingMode:Nf}=Lf;function Ff(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}const _f={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineOpacityTexture:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const kf=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_f,n),qt.extend(e,t,n),Ed(e,t,n),Vd(e,t,n),t.tris=ld.newInstance(),t.imagemat=m(new Float64Array(16)),t.imagematinv=m(new Float64Array(16)),t.projectionToWorld=m(new Float64Array(16)),t.idxToView=m(new Float64Array(16)),t.idxNormalMatrix=fe(new Float64Array(9)),t.modelToView=m(new Float64Array(16)),t.projectionToView=m(new Float64Array(16)),Ct(e,t,[]),t.VBOBuildTime={},ht(t.VBOBuildTime),function(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray,t._labelOutlineOpacity].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==gl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=Rd,e.Fragment=Md,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=td.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=td.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=td.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=td.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;"];if(o.getProperty().getUseLabelOutline()&&(c=c.concat(["uniform sampler2D labelOutlineTexture1;","uniform sampler2D labelOutlineOpacityTexture1;"])),l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Bf("Unsupported number of independent coordinates.")}}if(i=td.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=td.substitute(i,"//VTK::LabelOutline::Dec",["uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=td.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=td.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Bf("Unsupported number of independent coordinates.")}i=td.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=td.substitute(i,"//VTK::TCoord::Impl",[...Ff("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  float outlineOpacity = texture2D(labelOutlineOpacityTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=td.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=td.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=td.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=td.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=td.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6),o=td.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=td.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=td.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=td.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!!(i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||0===e.getProgram()?.getHandle()||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<r.getProperty().getMTime()||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Bf("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||Bf("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();if(n.getProgram().setUniformi("pwfTexture1",u),o.getProperty().getUseLabelOutline()){const e=t.labelOutlineThicknessTexture.getTextureUnit();n.getProgram().setUniformi("labelOutlineTexture1",e);const r=t.labelOutlineOpacityTexture.getTextureUnit();n.getProgram().setUniformi("labelOutlineOpacityTexture1",r)}if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?p(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(h(a,a),b(a,a,r),h(a,a)),h(t.imagemat,t.currentInput.getIndexToWorld()),b(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();b(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(b(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();b(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===Nf.NONE&&(i=Nf.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);v(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.activate(),t.labelOutlineOpacityTexture.activate()),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.deactivate(),t.labelOutlineOpacityTexture.deactivate()),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Bf("No input!")},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||r.getProperty().getUseLabelOutline()&&(!t.labelOutlineThicknessTexture?.getHandle()||!t.labelOutlineOpacityTexture?.getHandle())||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=[];for(let e=0;e<d;++e)f.push(l.getRGBTransferFunction(e));const g=wf(f,u,d),m=l.getRGBTransferFunction(),h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===g)t.colorTexture=h.oglObject;else{t.colorTexture=Pd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*p*3);if(c===Pf.NEAREST?(t.colorTexture.setMinificationFilter(ud.NEAREST),t.colorTexture.setMagnificationFilter(ud.NEAREST)):(t.colorTexture.setMinificationFilter(ud.LINEAR),t.colorTexture.setMagnificationFilter(ud.LINEAR)),m){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:p,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r})}m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.colorTexture,g),m!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=m)}const v=[];for(let e=0;e<d;++e)v.push(l.getPiecewiseFunction(e));const T=wf(v,u,d),y=l.getPiecewiseFunction(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y);if(b?.oglObject?.getHandle()&&b?.hash===T)t.pwfTexture=b.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Pd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===Pf.NEAREST?(t.pwfTexture.setMinificationFilter(ud.NEAREST),t.pwfTexture.setMagnificationFilter(ud.NEAREST)):(t.pwfTexture.setMinificationFilter(ud.LINEAR),t.pwfTexture.setMagnificationFilter(ud.LINEAR)),y){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:p,numComps:1,dataType:cs.FLOAT,data:e})}else o.fill(255),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:cs.UNSIGNED_CHAR,data:o});y&&(t._openGLRenderWindow.setGraphicsResourceForObject(y,t.pwfTexture,T),y!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(y,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=y)}r.getProperty().getUseLabelOutline()&&(e.updatelabelOutlineThicknessTexture(r),e.updateLabelOutlineOpacityTexture(r));const{ijkMode:x}=t.renderable.getClosestIJKAxis();let C=t.renderable.getSlice();x!==t.renderable.getSlicingMode()&&(C=t.renderable.getSliceAtPosition(C));const S=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(C),A=o.getExtent();let I;x===Nf.I&&(I=S-A[0]),x===Nf.J&&(I=S-A[2]),x!==Nf.K&&x!==Nf.NONE||(I=S-A[4]);const w=`${C}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==w){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Pd.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===Pf.NEAREST?(new Set([1,3,4]).has(s)&&i===cs.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(ud.NEAREST)):t.openGLTexture.setMinificationFilter(ud.NEAREST),t.openGLTexture.setMagnificationFilter(ud.NEAREST)):(4!==s||i!==cs.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(ud.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(ud.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(ud.LINEAR)),t.openGLTexture.setWrapS(cd.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(cd.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[Nf.X,Nf.Y,Nf.Z].includes(t.renderable.getSlicingMode())?C:S,p=o.getSpatialExtent(),f=a.getData();let g=null;if(x===Nf.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(I+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(x===Nf.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+I*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else x===Nf.K||x===Nf.NONE?(g=f.subarray(I*n,(I+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):Bf("Reformat slicing not yet supported.");const m=a.getRanges();t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw({width:e[0],height:e[1],numComps:s,dataType:a.getDataType(),data:g,preferSizeOverAccuracy:!!t.renderable.getPreferSizeOverAccuracy?.(),ranges:m}),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=xs.newInstance({numberOfComponents:3,values:r});h.setName("points");const v=xs.newInstance({numberOfComponents:2,values:l});v.setName("tcoords");const T=new Uint16Array(8);T[0]=3,T[1]=0,T[2]=1,T[3]=3,T[4]=3,T[5]=0,T[6]=3,T[7]=2;const y=xs.newInstance({numberOfComponents:1,values:T});t.tris.getCABO().createVBO(y,"polys",Zi.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=w}},e.updateLabelOutlineOpacityTexture=n=>{let r=n.getProperty().getLabelOutlineOpacity();"number"==typeof r&&(r=t._cachedLabelOutlineOpacityObj?.[0]===r?t._cachedLabelOutlineOpacityObj:[r],t._cachedLabelOutlineOpacityObj=r);const o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineOpacityTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Float32Array(n*o);for(let e=0;e<n;++e)i[e]=r[e]??r[0];t.labelOutlineOpacityTexture=Pd.newInstance({resizable:!1}),t.labelOutlineOpacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineOpacityTexture.resetFormatAndType(),t.labelOutlineOpacityTexture.setMinificationFilter(ud.NEAREST),t.labelOutlineOpacityTexture.setMagnificationFilter(ud.NEAREST),t.labelOutlineOpacityTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:cs.FLOAT,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineOpacityTexture,a),r!==t._labelOutlineOpacity&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineOpacity,e)),t._labelOutlineOpacity=r)}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Pd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(ud.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(ud.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:cs.UNSIGNED_CHAR,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Et((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageMapper");Jt("vtkAbstractImageMapper",kf);const Gf=0,Uf=1,zf=2,{vtkErrorMacro:Wf}=Wt,Hf={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const jf=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hf,n),qt.extend(e,t,n),Ed(e,t,n),Wt.algo(e,t,2,0),t.tris=ld.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=m(new Float64Array(16)),t.imagematinv=m(new Float64Array(16)),t.VBOBuildTime={},Wt.obj(t.VBOBuildTime,{mtime:0}),function(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===gl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===Pf.NEAREST?(t.volumeTexture.setMinificationFilter(ud.NEAREST),t.volumeTexture.setMagnificationFilter(ud.NEAREST),t.colorTexture.setMinificationFilter(ud.NEAREST),t.colorTexture.setMagnificationFilter(ud.NEAREST),t.pwfTexture.setMinificationFilter(ud.NEAREST),t.pwfTexture.setMagnificationFilter(ud.NEAREST)):(t.volumeTexture.setMinificationFilter(ud.LINEAR),t.volumeTexture.setMagnificationFilter(ud.LINEAR),t.colorTexture.setMinificationFilter(ud.LINEAR),t.colorTexture.setMagnificationFilter(ud.LINEAR),t.pwfTexture.setMinificationFilter(ud.LINEAR),t.pwfTexture.setMagnificationFilter(ud.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=r.getProperty(),s=o?.getPointData()?.getScalars();if(!s)return;const l=t._openGLRenderWindow.getGraphicsResourceForObject(s),c=Of(0,s),u=!l?.oglObject?.getHandle()||l?.hash!==c,d=i.getUpdatedExtents(),p=!!d.length;if(u){t.volumeTexture=Pd.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray({width:n[0],height:n[1],depth:n[2],dataArray:s,preferSizeOverAccuracy:t.renderable.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(s,t.volumeTexture,c),s!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(s,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=s}else t.volumeTexture=l.oglObject;if(p){i.setUpdatedExtents([]);const e=o.getDimensions();t.volumeTexture.create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:s,updatedExtents:d})}const f=s.getNumberOfComponents(),g=r.getProperty(),m=g.getIndependentComponents(),h=m?f:1,v=m?2*h:1,T=[];for(let e=0;e<h;++e)T.push(g.getRGBTransferFunction(e));const y=wf(T,m,h),b=g.getRGBTransferFunction(),x=t._openGLRenderWindow.getGraphicsResourceForObject(b);if(x?.oglObject?.getHandle()&&x?.hash===y)t.colorTexture=x.oglObject;else{let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*v*3);if(t.colorTexture=Pd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),b){const e=new Float32Array(3*n);for(let t=0;t<h;t++){const o=g.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),m)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:v,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r})}b&&(t._openGLRenderWindow.setGraphicsResourceForObject(b,t.colorTexture,y),b!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(b,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=b)}const C=[];for(let e=0;e<h;++e)C.push(g.getPiecewiseFunction(e));const S=wf(C,m,h),A=g.getPiecewiseFunction(),I=t._openGLRenderWindow.getGraphicsResourceForObject(A);if(I?.oglObject?.getHandle()&&I?.hash===S)t.pwfTexture=I.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*v,o=new Uint8ClampedArray(r);if(t.pwfTexture=Pd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),A){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<h;++t){const r=g.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),m)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:v,numComps:1,dataType:cs.FLOAT,data:e})}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:cs.UNSIGNED_CHAR,data:o});A&&(t._openGLRenderWindow.setGraphicsResourceForObject(A,t.pwfTexture,S),A!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(A,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=A)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=xs.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=xs.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=xs.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const T=[h,xs.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=xs.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=xs.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});T.push(a,s)}t.tris.getCABO().createVBO(d,"polys",Zi.SURFACE,{points:c,customAttributes:T}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=td.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=td.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=td.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=td.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Wf("Unsupported number of independent coordinates.")}}i=td.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===Uf?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case Gf:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case Uf:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===zf&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Wf("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=td.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=td.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=td.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Wt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=td.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=td.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=td.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=td.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=Rd,e.Fragment=Md,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||Wf("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&Wf(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=Mn([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=P(new Float32Array(16),xn([],l.getDimensions())),d=ae(u,u,c);if(a.setUniformMatrix("MCTCMatrix",d),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Wt.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?p(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(h(r,r),b(r,r,n),h(r,r)),h(t.imagemat,t.currentImageDataInput.getIndexToWorld()),b(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(b(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();b(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=Wt.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageCPRMapper");Jt("vtkImageCPRMapper",jf);const Kf={context:null,keyMatrixTime:null,keyMatrices:null};const $f=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kf,n),qt.extend(e,t,n),t.keyMatrixTime={},ht(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:m(new Float64Array(16))},Ct(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(p(t.keyMatrices.mcwc,t.renderable.getMatrix()),h(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}),"vtkOpenGLImageSlice");Jt("vtkImageSlice",$f);const qf={};const Xf=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qf,n),qt.extend(e,t,n),t.keyMatrixTime={},ht(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),Ct(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),p(t.MCWCMatrix,t.renderable.getMatrix()),h(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?fe(t.normalMatrix):(le(t.normalMatrix,t.MCWCMatrix),me(t.normalMatrix,t.normalMatrix),ge(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}(e,t)}),"vtkOpenGLVolume");Jt("vtkVolume",Xf);const Yf={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Zf={FRACTIONAL:0,PROPORTIONAL:1},Qf={DEFAULT:0,ADDITIVE:1,COLORIZE:2,CUSTOM:3};var Jf={InterpolationType:Yf,OpacityMode:Zf,ColorMixPreset:Qf,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const eg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var tg={BlendMode:eg};const{vtkWarningMacro:ng,vtkErrorMacro:rg}=Ht,og={idxToView:m(new Float64Array(16)),vecISToVCMatrix:fe(new Float64Array(9)),modelToView:m(new Float64Array(16)),projectionToView:m(new Float64Array(16)),projectionToWorld:m(new Float64Array(16))};const ag={context:null,VBOBuildTime:null,scalarTextures:[],_scalarTexturesCore:[],opacityTexture:null,_opacityTextureCore:null,colorTexture:null,_colorTextureCore:null,labelOutlineThicknessTexture:null,_labelOutlineThicknessTextureCore:null,jitterTexture:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,fullViewportTime:1,idxToView:null,vecISToVCMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const ig=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),qt.extend(e,t,n),Vd(e,t,n),t.VBOBuildTime={},ht(t.VBOBuildTime,{mtime:0}),t.tris=ld.newInstance(),t.jitterTexture=Pd.newInstance(),t.jitterTexture.setWrapS(cd.REPEAT),t.jitterTexture.setWrapT(cd.REPEAT),t.framebuffer=Sp.newInstance(),Ct(e,t,["context"]),function(e,t){function n(e){return e.getUseLabelOutline()||t.renderable.getBlendMode()===eg.LABELMAP_EDGE_PROJECTION_BLEND}t.classHierarchy.push("vtkOpenGLVolumeMapper");const r=new Map;function o(t,n,o){n!==o&&(function(t,n){if(!n)return;const o=(r.get(n)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(n,e),r.delete(n)):r.set(n,o)}(t,n),function(t,n){if(!n)return;const o=r.get(n)??0,a=o+1;r.set(n,a),o<=0&&t.registerGraphicsResourceUser(n,e)}(t,o))}function a(t){[...r.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){const n=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),n&&!n.isDeleted()&&n!==t._openGLRenderWindow&&a(n),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const r=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),e.renderPiece(o,r)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\nconst float infinity = 3.402823466e38;\n\n// the output of this shader\n//VTK::Output::Dec\n\nin vec3 vertexVCVSOutput;\n\n// From Sources\\Rendering\\Core\\VolumeProperty\\Constants.js\n#define COMPOSITE_BLEND 0\n#define MAXIMUM_INTENSITY_BLEND 1\n#define MINIMUM_INTENSITY_BLEND 2\n#define AVERAGE_INTENSITY_BLEND 3\n#define ADDITIVE_INTENSITY_BLEND 4\n#define RADON_TRANSFORM_BLEND 5\n#define LABELMAP_EDGE_PROJECTION_BLEND 6\n\n#define vtkNumberOfLights //VTK::NumberOfLights\n#define vtkMaxLaoKernelSize //VTK::MaxLaoKernelSize\n#define vtkNumberOfComponents //VTK::NumberOfComponents\n#define vtkBlendMode //VTK::BlendMode\n#define vtkMaximumNumberOfSamples //VTK::MaximumNumberOfSamples\n\n//VTK::EnabledColorFunctions\n\n//VTK::EnabledLightings\n\n//VTK::EnabledMultiTexturePerVolume\n\n//VTK::EnabledGradientOpacity\n\n//VTK::EnabledIndependentComponents\n\n//VTK::vtkProportionalComponents\n\n//VTK::vtkForceNearestComponents\n\nuniform int twoSidedLighting;\n\n#if vtkMaxLaoKernelSize > 0\n  vec2 kernelSample[vtkMaxLaoKernelSize];\n#endif\n\n// Textures\n#ifdef EnabledMultiTexturePerVolume\n  #define vtkNumberOfVolumeTextures vtkNumberOfComponents\n#else\n  #define vtkNumberOfVolumeTextures 1\n#endif\nuniform highp sampler3D volumeTexture[vtkNumberOfVolumeTextures];\nuniform sampler2D colorTexture;\nuniform sampler2D opacityTexture;\nuniform sampler2D jtexture;\nuniform sampler2D labelOutlineThicknessTexture;\n\nstruct Volume {\n  // ---- Volume geometry settings ----\n\n  vec3 originVC;          // in VC\n  vec3 spacing;           // in VC per IC\n  vec3 inverseSpacing;    // 1/spacing\n  ivec3 dimensions;       // in IC\n  vec3 inverseDimensions; // 1/vec3(dimensions)\n  mat3 vecISToVCMatrix;   // convert from IS to VC without translation\n  mat3 vecVCToISMatrix;   // convert from VC to IS without translation\n  mat4 PCWCMatrix;\n  mat4 worldToIndex;\n  float diagonalLength; // in VC, this is: length(size)\n\n  // ---- Texture settings ----\n\n  // Texture shift and scale\n  vec4 colorTextureScale;\n  vec4 colorTextureShift;\n  vec4 opacityTextureScale;\n  vec4 opacityTextureShift;\n\n  // The heights defined below are the locations for the up to four components\n  // of the transfer functions. The transfer functions have a height of (2 *\n  // numberOfComponents) pixels so the values are computed to hit the middle of\n  // the two rows for that component\n  vec4 transferFunctionsSampleHeight;\n\n  // ---- Mode specific settings ----\n\n  // Independent component default preset settings per component\n  vec4 independentComponentMix;\n\n  // Additive / average blending mode settings\n  vec4 ipScalarRangeMin;\n  vec4 ipScalarRangeMax;\n\n  // ---- Rendering settings ----\n\n  // Lighting\n  float ambient;\n  float diffuse;\n  float specular;\n  float specularPower;\n  int computeNormalFromOpacity;\n\n  // Gradient opacity\n  vec4 gradientOpacityScale;\n  vec4 gradientOpacityShift;\n  vec4 gradientOpacityMin;\n  vec4 gradientOpacityMax;\n\n  // Volume shadow\n  float volumetricScatteringBlending;\n  float globalIlluminationReach;\n  float anisotropy;\n  float anisotropySquared;\n\n  // LAO\n  int kernelSize;\n  int kernelRadius;\n\n  // Label outline\n  float outlineOpacity;\n};\nuniform Volume volume;\n\nstruct Light {\n  vec3 color;\n  vec3 positionVC;\n  vec3 directionVC; // normalized\n  vec3 halfAngleVC;\n  vec3 attenuation;\n  float exponent;\n  float coneAngle;\n  int isPositional;\n};\n#if vtkNumberOfLights > 0\n  uniform Light lights[vtkNumberOfLights];\n#endif\n\nuniform float vpWidth;\nuniform float vpHeight;\nuniform float vpOffsetX;\nuniform float vpOffsetY;\n\n// Bitmasks for label outline\nconst int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n#define MAX_SEGMENTS 256\n#define UINT_SIZE 32\n// We add UINT_SIZE - 1, as we want the ceil of the division instead of the\n// floor\n#define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\nuint labelOutlineBitmasks[BITMASK_SIZE];\n\n// Set the corresponding bit in the bitmask\nvoid setLabelOutlineBit(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  labelOutlineBitmasks[arrayIndex] |= 1u << bitIndex;\n}\n\n// Check if a bit is set in the bitmask\nbool isLabelOutlineBitSet(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  return ((labelOutlineBitmasks[arrayIndex] & (1u << bitIndex)) != 0u);\n}\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n//VTK::ClipPlane::Dec\n\n// A random number between 0 and 1 that only depends on the fragment\n// It uses the jtexture, so this random seed repeats by blocks of 32 fragments\n// in screen space\nfloat fragmentSeed;\n\n// sample texture is global\nuniform float sampleDistance;\nuniform float volumeShadowSampleDistance;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics\n// rendering module is complete)\nvec3 rayDirVC;\n\n#define INV4PI 0.0796\n#define EPSILON 0.001\n#define PI 3.1415\n#define PI2 9.8696\n\nvec4 rawSampleTexture(vec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    rawSample[0] = texture(volumeTexture[0], pos)[0];\n  #if vtkNumberOfComponents > 1\n    rawSample[1] = texture(volumeTexture[1], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 2\n    rawSample[2] = texture(volumeTexture[2], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 3\n    rawSample[3] = texture(volumeTexture[3], pos)[0];\n  #endif\n    return rawSample;\n  #else\n    return texture(volumeTexture[0], pos);\n  #endif\n}\n\nvec4 rawFetchTexture(ivec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    #if vtkNumberOfComponents > 0\n      rawSample[0] = texelFetch(volumeTexture[0], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 1\n      rawSample[1] = texelFetch(volumeTexture[1], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 2\n      rawSample[2] = texelFetch(volumeTexture[2], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 3\n      rawSample[3] = texelFetch(volumeTexture[3], pos, 0)[0];\n    #endif\n    return rawSample;\n  #else\n    return texelFetch(volumeTexture[0], pos, 0);\n  #endif\n}\n\nvec4 getTextureValue(vec3 pos) {\n  vec4 tmp = rawSampleTexture(pos);\n\n  // Force nearest\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volume.dimensions)) + 0.5) *\n                      volume.inverseDimensions;\n    vec4 nearestValue = rawSampleTexture(nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  // Set alpha when using dependent components\n  #ifndef EnabledIndependentComponents\n    #if vtkNumberOfComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumberOfComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumberOfComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n// `height` is usually `volume.transferFunctionsSampleHeight[component]`\n// when using independent component and `0.5` otherwise. Don't move the if\n// statement in these function, as the callers usually already knows if it is\n// using independent component or not\nfloat getOpacityFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.opacityTextureScale[component] +\n                       volume.opacityTextureShift[component];\n  return texture2D(opacityTexture, vec2(scaledScalar, height)).r;\n}\nvec3 getColorFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.colorTextureScale[component] +\n                       volume.colorTextureShift[component];\n  return texture2D(colorTexture, vec2(scaledScalar, height)).rgb;\n}\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\nvec3 posIStoVC(vec3 posIS) {\n  return volume.vecISToVCMatrix * posIS + volume.originVC;\n}\n\n// convert vector position from vc to idx\nvec3 posVCtoIS(vec3 posVC) {\n  return volume.vecVCToISMatrix * (posVC - volume.originVC);\n}\n\n// Rotate vector to view coordinate\nvec3 vecISToVC(vec3 dirIS) {\n  return volume.vecISToVCMatrix * dirIS;\n}\n\n// Rotate vector to idx coordinate\nvec3 vecVCToIS(vec3 dirVC) {\n  return volume.vecVCToISMatrix * dirVC;\n}\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(float normalMag, int component) {\n  float goscale = volume.gradientOpacityScale[component];\n  float goshift = volume.gradientOpacityShift[component];\n  float gomin = volume.gradientOpacityMin[component];\n  float gomax = volume.gradientOpacityMax[component];\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n#ifdef vtkClippingPlanesOn\n  bool isPointClipped(vec3 posVC) {\n    for (int i = 0; i < clip_numPlanes; ++i) {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0) {\n        return true;\n      }\n    }\n    return false;\n  }\n#endif\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward\n// difference\n\n// The output normal is in VC\nvec4 computeDensityNormal(vec3 opacityUCoords[2], float opacityTextureHeight,\n                          float gradientOpacity, int component) {\n  // Pass the scalars through the opacity functions\n  vec4 opacityG;\n  opacityG.x += getOpacityFromTexture(opacityUCoords[0].x, component,\n                                      opacityTextureHeight);\n  opacityG.y += getOpacityFromTexture(opacityUCoords[0].y, component,\n                                      opacityTextureHeight);\n  opacityG.z += getOpacityFromTexture(opacityUCoords[0].z, component,\n                                      opacityTextureHeight);\n  opacityG.x -= getOpacityFromTexture(opacityUCoords[1].x, component,\n                                      opacityTextureHeight);\n  opacityG.y -= getOpacityFromTexture(opacityUCoords[1].y, component,\n                                      opacityTextureHeight);\n  opacityG.z -= getOpacityFromTexture(opacityUCoords[1].z, component,\n                                      opacityTextureHeight);\n\n  // Divide by spacing and convert to VC\n  opacityG.xyz *= gradientOpacity * volume.inverseSpacing;\n  opacityG.w = length(opacityG.xyz);\n  if (opacityG.w == 0.0) {\n    return vec4(0.0);\n  }\n\n  // Normalize\n  opacityG.xyz = normalize(vecISToVC(opacityG.xyz));\n\n  return opacityG;\n}\n\n// The output normal is in VC\nvec4 computeNormalForDensity(vec3 posIS, out vec3 scalarInterp[2],\n                             const int opacityComponent) {\n  vec3 offsetedPosIS;\n  for (int axis = 0; axis < 3; ++axis) {\n    // Positive direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] += volume.inverseDimensions[axis];\n    scalarInterp[0][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[0][axis] = 0.0;\n      }\n    #endif\n\n    // Negative direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] -= volume.inverseDimensions[axis];\n    scalarInterp[1][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[1][axis] = 0.0;\n      }\n    #endif\n  }\n\n  vec4 result;\n  result.xyz = (scalarInterp[0] - scalarInterp[1]) * volume.inverseSpacing;\n  result.w = length(result.xyz);\n  if (result.w == 0.0) {\n    return vec4(0.0);\n  }\n  result.xyz = normalize(vecISToVC(result.xyz));\n  return result;\n}\n\nvec4 fragCoordToPCPos(vec4 fragCoord) {\n  return vec4((fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n              (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n              (fragCoord.z - 0.5) * 2.0, 1.0);\n}\n\nvec4 pcPosToWorldCoord(vec4 pcPos) {\n  return volume.PCWCMatrix * pcPos;\n}\n\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  vec4 vertex = (worldCoord / worldCoord.w);\n\n  vec3 index = (volume.worldToIndex * vertex).xyz;\n\n  // half voxel fix for labelmapOutline\n  return (index + vec3(0.5)) * volume.inverseDimensions;\n}\n\nvec3 fragCoordToWorld(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  return worldCoord.xyz;\n}\n\n//=======================================================================\n// Compute the normals and gradient magnitudes for a position for independent\n// components The output normals are in VC\nmat4 computeMat4Normal(vec3 posIS, vec4 tValue) {\n  vec3 xvec = vec3(volume.inverseDimensions.x, 0.0, 0.0);\n  vec3 yvec = vec3(0.0, volume.inverseDimensions.y, 0.0);\n  vec3 zvec = vec3(0.0, 0.0, volume.inverseDimensions.z);\n\n  vec4 distX = getTextureValue(posIS + xvec) - getTextureValue(posIS - xvec);\n  vec4 distY = getTextureValue(posIS + yvec) - getTextureValue(posIS - yvec);\n  vec4 distZ = getTextureValue(posIS + zvec) - getTextureValue(posIS - zvec);\n\n  // divide by spacing\n  distX *= 0.5 * volume.inverseSpacing.x;\n  distY *= 0.5 * volume.inverseSpacing.y;\n  distZ *= 0.5 * volume.inverseSpacing.z;\n\n  mat4 result;\n\n  // optionally compute the 1st component\n  #if vtkNumberOfComponents > 0 && !defined(vtkComponent0Proportional)\n    {\n      const int component = 0;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 2nd component\n  #if vtkNumberOfComponents > 1 && !defined(vtkComponent1Proportional)\n    {\n      const int component = 1;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 3rd component\n  #if vtkNumberOfComponents > 2 && !defined(vtkComponent2Proportional)\n    {\n      const int component = 2;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 4th component\n  #if vtkNumberOfComponents > 3 && !defined(vtkComponent3Proportional)\n    {\n      const int component = 3;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n\n// henyey greenstein phase function\nfloat phaseFunction(float cos_angle) {\n  // divide by 2.0 instead of 4pi to increase intensity\n  float anisotropy = volume.anisotropy;\n  if (abs(anisotropy) <= EPSILON) {\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    return 0.5;\n  }\n  float anisotropy2 = volume.anisotropySquared;\n  return ((1.0 - anisotropy2) /\n          pow(1.0 + anisotropy2 - 2.0 * anisotropy * cos_angle, 1.5)) /\n         2.0;\n}\n\n// Compute the two intersection distances of the ray with the volume in VC\n// The entry point is `rayOriginVC + distanceMin * rayDirVC` and the exit point\n// is `rayOriginVC + distanceMax * rayDirVC` If distanceMin < distanceMax, the\n// volume is not intersected The ray origin is inside the box when distanceMin <\n// 0.0 < distanceMax\nvec2 rayIntersectVolumeDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  // Compute origin and direction in IS\n  vec3 rayOriginIS = posVCtoIS(rayOriginVC);\n  vec3 rayDirIS = vecVCToIS(rayDirVC);\n  // Don't check for infinity as the min/max combination afterward will always\n  // find an intersection before infinity\n  vec3 invDir = 1.0 / rayDirIS;\n\n  // We have: bound = origin + t * dir\n  // So: t = (1/dir) * (bound - origin)\n  vec3 distancesTo0 = invDir * (vec3(0.0) - rayOriginIS);\n  vec3 distancesTo1 = invDir * (vec3(1.0) - rayOriginIS);\n  // Min and max distances to plane intersection per plane\n  vec3 dMinPerAxis = min(distancesTo0, distancesTo1);\n  vec3 dMaxPerAxis = max(distancesTo0, distancesTo1);\n  // Overall first and last intersection\n  float distanceMin = max(dMinPerAxis.x, max(dMinPerAxis.y, dMinPerAxis.z));\n  float distanceMax = min(dMaxPerAxis.x, min(dMaxPerAxis.y, dMaxPerAxis.z));\n  return vec2(distanceMin, distanceMax);\n}\n\n//=======================================================================\n// local ambient occlusion\n#if vtkMaxLaoKernelSize > 0\n\n  // Return a random point on the unit sphere\n  vec3 sampleDirectionUniform(int rayIndex) {\n    // Each ray of each fragment should be different, two sources of randomness\n    // are used. Only depends on ray index\n    vec2 rayRandomness = kernelSample[rayIndex];\n    // Only depends on fragment\n    float fragmentRandomness = fragmentSeed;\n    // Merge both source of randomness in a single uniform random variable using\n    // the formula (x+y < 1 ? x+y : x+y-1). The simpler formula (x+y)/2 doesn't\n    // result in a uniform distribution\n    vec2 mergedRandom = rayRandomness + vec2(fragmentRandomness);\n    mergedRandom -= vec2(greaterThanEqual(mergedRandom, vec2(1.0)));\n\n    // Insipred by:\n    // https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\n    float u = mergedRandom[0];\n    float v = mergedRandom[1];\n    float theta = u * 2.0 * PI;\n    float phi = acos(2.0 * v - 1.0);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    return vec3(sinPhi * cosTheta, sinPhi * sinTheta, cosPhi);\n  }\n\n  float computeLAO(vec3 posVC, vec4 normalVC, float originalOpacity) {\n    // apply LAO only at selected locations, otherwise return full brightness\n    if (normalVC.w <= 0.0 || originalOpacity <= 0.05) {\n      return 1.0;\n    }\n\n    #ifdef EnabledGradientOpacity\n      float gradientOpacityFactor = computeGradientOpacityFactor(normalVC.w, 0);\n    #endif\n\n    float visibilitySum = 0.0;\n    float weightSum = 0.0;\n    for (int i = 0; i < volume.kernelSize; i++) {\n      // Only sample on an hemisphere around the normalVC.xyz axis, so\n      // normalDotRay should be negative\n      vec3 rayDirectionVC = sampleDirectionUniform(i);\n      float normalDotRay = dot(normalVC.xyz, rayDirectionVC);\n      if (normalDotRay > 0.0) {\n        // Flip rayDirectionVC when it is in the wrong hemisphere\n        rayDirectionVC = -rayDirectionVC;\n        normalDotRay = -normalDotRay;\n      }\n\n      vec3 currPosIS = posVCtoIS(posVC);\n      float visibility = 1.0;\n      vec3 randomDirStepIS = vecVCToIS(rayDirectionVC * sampleDistance);\n      for (int j = 0; j < volume.kernelRadius; j++) {\n        currPosIS += randomDirStepIS;\n        // If out of the volume, we are done\n        if (any(lessThan(currPosIS, vec3(0.0))) ||\n            any(greaterThan(currPosIS, vec3(1.0)))) {\n          break;\n        }\n        float opacity = getOpacityFromTexture(getTextureValue(currPosIS).r, 0, 0.5);\n        #ifdef EnabledGradientOpacity\n          opacity *= gradientOpacityFactor;\n        #endif\n        visibility *= 1.0 - opacity;\n        // If visibility is less than EPSILON, consider it to be 0\n        if (visibility < EPSILON) {\n          visibility = 0.0;\n          break;\n        }\n      }\n      float rayWeight = -normalDotRay;\n      visibilitySum += visibility * rayWeight;\n      weightSum += rayWeight;\n    }\n\n    // If no sample, LAO factor is one\n    if (weightSum == 0.0) {\n      return 1.0;\n    }\n\n    // LAO factor is the average visibility:\n    // - visibility low => ambient low\n    // - visibility high => ambient high\n    float lao = visibilitySum / weightSum;\n\n    // Reduce variance by clamping\n    return clamp(lao, 0.3, 1.0);\n  }\n#endif\n\n//=======================================================================\n// Volume shadows\n#if vtkNumberOfLights > 0\n\n  // Non-memoised version\n  float computeVolumeShadowWithoutCache(vec3 posVC, vec3 lightDirNormVC) {\n    // modify sample distance with a random number between 1.5 and 3.0\n    float rayStepLength =\n        volumeShadowSampleDistance * mix(1.5, 3.0, fragmentSeed);\n\n    // in case the first sample near surface has a very tiled light ray, we need\n    // to offset start position\n    vec3 initialPosVC = posVC + rayStepLength * lightDirNormVC;\n\n    #ifdef vtkClippingPlanesOn\n      float clippingPlanesMaxDistance = infinity;\n      for (int i = 0; i < clip_numPlanes; ++i) {\n        // Find distance of intersection with the plane\n        // Points are clipped when:\n        // dot(planeOrigin - (rayOrigin + distance * rayDirection), planeNormal) > 0\n        // This is equivalent to:\n        // dot(planeOrigin - rayOrigin, planeNormal) - distance * dot(rayDirection,\n        // planeNormal) > 0.0\n        // We precompute the dot products, so we clip ray points when:\n        // dotOrigin - distance * dotDirection > 0.0\n        float dotOrigin =\n            dot(vClipPlaneOrigins[i] - initialPosVC, vClipPlaneNormals[i]);\n        if (dotOrigin > 0.0) {\n          // The initialPosVC is clipped by this plane\n          return 1.0;\n        }\n        float dotDirection = dot(lightDirNormVC, vClipPlaneNormals[i]);\n        if (dotDirection < 0.0) {\n          // We only hit the plane if dotDirection is negative, as (distance is\n          // positive)\n          float intersectionDistance =\n              dotOrigin / dotDirection; // negative divided by negative => positive\n          clippingPlanesMaxDistance =\n              min(clippingPlanesMaxDistance, intersectionDistance);\n        }\n      }\n    #endif\n\n    vec2 intersectionDistances =\n        rayIntersectVolumeDistances(initialPosVC, lightDirNormVC);\n\n    if (intersectionDistances[1] <= intersectionDistances[0] ||\n        intersectionDistances[1] <= 0.0) {\n      // Volume not hit or behind the ray\n      return 1.0;\n    }\n\n    // When globalIlluminationReach is 0, no sample at all\n    // When globalIlluminationReach is 1, the ray will go through the whole\n    // volume\n    float maxTravelDistance = mix(0.0, volume.diagonalLength,\n                                  volume.globalIlluminationReach);\n    float startDistance = max(intersectionDistances[0], 0.0);\n    float endDistance = min(intersectionDistances[1], startDistance + maxTravelDistance);\n    #ifdef vtkClippingPlanesOn\n      endDistance = min(endDistance, clippingPlanesMaxDistance);\n    #endif\n    if (endDistance - startDistance < 0.0) {\n      return 1.0;\n    }\n\n    // These two variables are used to compute posIS, without having to call\n    // VCtoIS at each step\n    vec3 initialPosIS = posVCtoIS(initialPosVC);\n    // The light dir is scaled and rotated, but not translated, as it is a\n    // vector (w = 0)\n    vec3 scaledLightDirIS = vecVCToIS(lightDirNormVC);\n\n    float shadow = 1.0;\n    for (float currentDistance = startDistance; currentDistance <= endDistance;\n          currentDistance += rayStepLength) {\n      vec3 posIS = initialPosIS + currentDistance * scaledLightDirIS;\n      vec4 scalar = getTextureValue(posIS);\n      float opacity = getOpacityFromTexture(scalar.r, 0, 0.5);\n      #if defined(EnabledGradientOpacity) && !defined(EnabledIndependentComponents)\n        vec3 scalarInterp[2];\n        vec4 normal = computeNormalForDensity(posIS, scalarInterp, 3);\n        float opacityFactor = computeGradientOpacityFactor(normal.w, 0);\n        opacity *= opacityFactor;\n      #endif\n      shadow *= 1.0 - opacity;\n\n      // Early termination if shadow coeff is near 0.0\n      if (shadow < EPSILON) {\n        return 0.0;\n      }\n    }\n    return shadow;\n  }\n\n  // Some cache for volume shadows\n  struct {\n    vec3 posVC;\n    float shadow;\n  } cachedShadows[vtkNumberOfLights];\n\n  // Memoised version\n  float computeVolumeShadow(vec3 posVC, vec3 lightDirNormVC, int lightIdx) {\n    if (posVC == cachedShadows[lightIdx].posVC) {\n      return cachedShadows[lightIdx].shadow;\n    }\n    float shadow = computeVolumeShadowWithoutCache(posVC, lightDirNormVC);\n    cachedShadows[lightIdx].posVC = posVC;\n    cachedShadows[lightIdx].shadow = shadow;\n    return shadow;\n  }\n\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkNumberOfLights > 0\n  vec3 applyLighting(vec3 tColor, vec4 normalVC) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      float df = dot(normalVC.xyz, lights[lightIdx].directionVC);\n      if (df > 0.0) {\n        diffuse += df * lights[lightIdx].color;\n        float sf = dot(normalVC.xyz, -lights[lightIdx].halfAngleVC);\n        if (sf > 0.0) {\n          specular += pow(sf, volume.specularPower) * lights[lightIdx].color;\n        }\n      }\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient) +\n          specular * volume.specular;\n  }\n\n  vec3 applySurfaceShadowLighting(vec3 tColor, float alpha, vec3 posVC,\n                                  vec4 normalVC) {\n    // everything in VC\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    for (int ligthIdx = 0; ligthIdx < vtkNumberOfLights; ligthIdx++) {\n      vec3 vertLightDirection;\n      float attenuation;\n      if (lights[ligthIdx].isPositional == 1) {\n        vertLightDirection = posVC - lights[ligthIdx].positionVC;\n        float lightDistance = length(vertLightDirection);\n        // Normalize with precomputed length\n        vertLightDirection = vertLightDirection / lightDistance;\n        // Base attenuation\n        vec3 attenuationPolynom = lights[ligthIdx].attenuation;\n        attenuation =\n            1.0 / (attenuationPolynom[0] +\n                  lightDistance * (attenuationPolynom[1] +\n                                    lightDistance * attenuationPolynom[2]));\n        // Cone attenuation\n        float coneDot = dot(vertLightDirection, lights[ligthIdx].directionVC);\n        // Per OpenGL standard cone angle is 90 or less for a spot light\n        if (lights[ligthIdx].coneAngle <= 90.0) {\n          if (coneDot >= cos(radians(lights[ligthIdx].coneAngle))) {\n            // Inside the cone\n            attenuation *= pow(coneDot, lights[ligthIdx].exponent);\n          } else {\n            // Outside the cone\n            attenuation = 0.0;\n          }\n        }\n      } else {\n        vertLightDirection = lights[ligthIdx].directionVC;\n        attenuation = 1.0;\n      }\n\n      float ndotL = dot(normalVC.xyz, vertLightDirection);\n      if (ndotL < 0.0 && twoSidedLighting == 1) {\n        ndotL = -ndotL;\n      }\n      if (ndotL > 0.0) {\n        // Diffuse\n        diffuse += ndotL * attenuation * lights[ligthIdx].color;\n        // Specular\n        float vdotR =\n            dot(-rayDirVC, normalize(vertLightDirection - 2.0 * ndotL * normalVC.xyz));\n        if (vdotR > 0.0) {\n          specular += pow(vdotR, volume.specularPower) * attenuation *\n                      lights[ligthIdx].color;\n        }\n      }\n    }\n    #if vtkMaxLaoKernelSize > 0\n      float laoFactor = computeLAO(posVC, normalVC, alpha);\n    #else\n      const float laoFactor = 1.0;\n    #endif\n    return tColor * (diffuse * volume.diffuse +\n                    volume.ambient * laoFactor) +\n          specular * volume.specular;\n  }\n\n  vec3 applyVolumeShadowLighting(vec3 tColor, vec3 posVC) {\n    // Here we have no effect of cones and no attenuation\n    vec3 diffuse = vec3(0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      vec3 lightDirVC = lights[lightIdx].isPositional == 1\n                            ? normalize(lights[lightIdx].positionVC - posVC)\n                            : -lights[lightIdx].directionVC;\n      float shadowCoeff = computeVolumeShadow(posVC, lightDirVC, lightIdx);\n      float phaseAttenuation = phaseFunction(dot(rayDirVC, lightDirVC));\n      diffuse += phaseAttenuation * shadowCoeff * lights[lightIdx].color;\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient);\n  }\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posVC,\n                       vec4 surfaceNormalVC) {\n  #if vtkNumberOfLights > 0\n    // 0 <= volCoeff < EPSILON => only surface shadows\n    // EPSILON <= volCoeff < 1 - EPSILON => mix of surface and volume shadows\n    // 1 - EPSILON <= volCoeff => only volume shadows\n    float volCoeff = volume.volumetricScatteringBlending *\n                    (1.0 - alpha / 2.0) *\n                    (1.0 - atan(surfaceNormalVC.w) * INV4PI);\n\n    // Compute surface lighting if needed\n    vec3 surfaceShadedColor = tColor;\n    #ifdef EnableSurfaceLighting\n      if (volCoeff < 1.0 - EPSILON) {\n        surfaceShadedColor =\n            applySurfaceShadowLighting(tColor, alpha, posVC, surfaceNormalVC);\n      }\n    #endif\n\n    // Compute volume lighting if needed\n    vec3 volumeShadedColor = tColor;\n    #ifdef EnableVolumeLighting\n      if (volCoeff >= EPSILON) {\n        volumeShadedColor = applyVolumeShadowLighting(tColor, posVC);\n      }\n    #endif\n\n    // Return the right mix\n    if (volCoeff < EPSILON) {\n      // Surface shadows\n      return surfaceShadedColor;\n    }\n    if (volCoeff >= 1.0 - EPSILON) {\n      // Volume shadows\n      return volumeShadedColor;\n    }\n    // Mix of surface and volume shadows\n    return mix(surfaceShadedColor, volumeShadedColor, volCoeff);\n  #endif\n  return tColor;\n}\n\nvec4 getColorForLabelOutline() {\n  vec3 centerPosIS =\n      fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = vec4(getColorFromTexture(centerValue.r, 0, 0.5),\n                     getOpacityFromTexture(centerValue.r, 0, 0.5));\n\n  int segmentIndex = int(centerValue.r * 255.0);\n\n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue =\n      texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n  int actualThickness = int(textureValue * 255.0);\n\n  // If it is the background (segment index 0), we should quickly bail out.\n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0) {\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't\n  // invisible. Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord =\n          vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j),\n               gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = volume.outlineOpacity;\n  }\n\n  return tColor;\n}\n\nvec4 getColorForAdditivePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLights[2];\n  normalLights[0] = normalMat[0];\n  normalLights[1] = normalMat[1];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      for (int component = 0; component < 2; ++component) {\n        vec3 scalarInterp[2];\n        float height = volume.transferFunctionsSampleHeight[component];\n        computeNormalForDensity(posIS, scalarInterp, component);\n        normalLights[component] =\n            computeDensityNormal(scalarInterp, height, 1.0, component);\n      }\n    }\n  #endif\n\n  // compute opacities\n  float opacities[2];\n  opacities[0] = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  opacities[1] = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n  #ifdef EnabledGradientOpacity\n    for (int component = 0; component < 2; ++component) {\n      opacities[component] *=\n          computeGradientOpacityFactor(normalMat[component].a, component);\n    }\n  #endif\n  float opacitySum = opacities[0] + opacities[1];\n  if (opacitySum <= 0.0) {\n    return vec4(0.0);\n  }\n\n  // mix the colors and opacities\n  vec3 colors[2];\n  for (int component = 0; component < 2; ++component) {\n    float sampleHeight = volume.transferFunctionsSampleHeight[component];\n    vec3 color = getColorFromTexture(tValue[component], component, sampleHeight);\n    color = applyAllLightning(color, opacities[component], posVC,\n                              normalLights[component]);\n    colors[component] = color;\n  }\n  vec3 mixedColor =\n      (opacities[0] * colors[0] + opacities[1] * colors[1]) / opacitySum;\n  return vec4(mixedColor, min(1.0, opacitySum));\n}\n\nvec4 getColorForColorizePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLight = normalMat[0];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      vec3 scalarInterp[2];\n      float height = volume.transferFunctionsSampleHeight[0];\n      computeNormalForDensity(posIS, scalarInterp, 0);\n      normalLight = computeDensityNormal(scalarInterp, height, 1.0, 0);\n    }\n  #endif\n\n  // compute opacities\n  float opacity = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  #ifdef EnabledGradientOpacity\n    opacity *= computeGradientOpacityFactor(normalMat[0].a, 0);\n  #endif\n\n  // colorizing component\n  vec3 colorizingColor = getColorFromTexture(\n      tValue[0], 1, volume.transferFunctionsSampleHeight[1]);\n  float colorizingOpacity = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n\n  // mix the colors and opacities\n  vec3 color =\n      getColorFromTexture(tValue[0], 0,\n                          volume.transferFunctionsSampleHeight[0]) *\n      mix(vec3(1.0), colorizingColor, colorizingOpacity);\n  color = applyAllLightning(color, opacity, posVC, normalLight);\n  return vec4(color, opacity);\n}\n\nvec4 getColorForDefaultIndependentPreset(vec4 tValue, vec3 posIS) {\n\n  // compute the normal vectors as needed\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    mat4 normalMat = computeMat4Normal(posIS, tValue);\n  #endif\n\n  // process color and opacity for each component\n  // initial value of alpha is determined by wether the first component is\n  // proportional or not\n  #if defined(vtkComponent0Proportional)\n    // when it is proportional, it starts at 1 (neutral for multiplications)\n    float alpha = 1.0;\n  #else\n    // when it is not proportional, it starts at 0 (neutral for additions)\n    float alpha = 0.0;\n  #endif\n\n  vec3 mixedColor = vec3(0.0);\n  #if vtkNumberOfComponents > 0\n    {\n      const int component = 0;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent0Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 1\n    {\n      const int component = 1;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent1Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 2\n    {\n      const int component = 2;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent2Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 3\n    {\n      const int component = 3;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent3Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n\n  return vec4(mixedColor, alpha);\n}\n\nvec4 getColorForDependentComponents(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    // use component 3 of the opacity texture as getTextureValue() sets alpha to\n    // the opacity value\n    vec3 scalarInterp[2];\n    vec4 normal0 = computeNormalForDensity(posIS, scalarInterp, 3);\n    float gradientOpacity = computeGradientOpacityFactor(normal0.a, 0);\n  #endif\n\n  // get color and opacity\n  #if vtkNumberOfComponents == 1\n    vec3 tColor = getColorFromTexture(tValue.r, 0, 0.5);\n    float alpha = getOpacityFromTexture(tValue.r, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 2\n    vec3 tColor = vec3(tValue.r * volume.colorTextureScale[0] +\n                  volume.colorTextureShift[0]);\n    float alpha = getOpacityFromTexture(tValue.a, 1, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 3\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 4\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 3, 0.5);\n  #endif\n\n  // Apply gradient opacity\n  #if defined(EnabledGradientOpacity)\n    alpha *= gradientOpacity;\n  #endif\n\n  #if vtkNumberOfComponents == 1\n    if (alpha < EPSILON) {\n      return vec4(0.0);\n    }\n  #endif\n\n  // lighting\n  #if vtkNumberOfLights > 0\n    vec4 normalLight;\n    if (volume.computeNormalFromOpacity == 1) {\n      if (normal0[3] != 0.0) {\n        normalLight =\n            computeDensityNormal(scalarInterp, 0.5, gradientOpacity, 0);\n        if (normalLight[3] == 0.0) {\n          normalLight = normal0;\n        }\n      }\n    } else {\n      normalLight = normal0;\n    }\n    tColor = applyAllLightning(tColor, alpha, posVC, normalLight);\n  #endif\n\n  return vec4(tColor, alpha);\n}\n\nvec4 getColorForValue(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #ifdef EnableColorForValueFunctionId0\n    return getColorForDependentComponents(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId1\n    return getColorForAdditivePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId2\n    return getColorForColorizePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId3\n    /*\n      * Mix the color information from all the independent components to get a\n      * single rgba output. See other shader functions like\n      * `getColorForAdditivePreset` to learn how to create a custom color mix.\n      * The custom color mix should return a value, but if it doesn't, it will\n      * fallback on the default shading\n      */\n    //VTK::CustomColorMix\n  #endif\n\n  #if defined(EnableColorForValueFunctionId4) || defined(EnableColorForValueFunctionId3)\n    return getColorForDefaultIndependentPreset(tValue, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId5\n    return getColorForLabelOutline();\n  #endif\n}\n\nbool valueWithinScalarRange(vec4 val) {\n  #if vtkNumberOfComponents > 1 && !defined(EnabledIndependentComponents)\n    return false;\n  #endif\n  vec4 rangeMin = volume.ipScalarRangeMin;\n  vec4 rangeMax = volume.ipScalarRangeMax;\n  for (int component = 0; component < vtkNumberOfComponents; ++component) {\n    if (val[component] < rangeMin[component] ||\n        rangeMax[component] < val[component]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n#if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n  bool checkOnEdgeForNeighbor(int xFragmentOffset, int yFragmentOffset,\n                              int segmentIndex, vec3 stepIS) {\n    vec3 volumeDimensions = vec3(volume.dimensions);\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(xFragmentOffset),\n                                  gl_FragCoord.y + float(yFragmentOffset),\n                                  gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS += stepIS;\n    }\n\n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS -= stepIS;\n    }\n\n    // onedge\n    float sampleHeight = volume.transferFunctionsSampleHeight[1];\n    vec3 tColorSegment =\n        getColorFromTexture(float(segmentIndex), 1, sampleHeight);\n    float pwfValueSegment =\n        getOpacityFromTexture(float(segmentIndex), 1, sampleHeight);\n    gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n    return true;\n  }\n#endif\n\nvec4 getColorAtPos(vec3 posVC) {\n  vec3 posIS = posVCtoIS(posVC);\n  vec4 texValue = getTextureValue(posIS);\n  return getColorForValue(texValue, posVC, posIS);\n}\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 rayOriginVC, vec3 rayDirVC, float minDistance,\n                float maxDistance) {\n  // start slightly inside and apply some jitter\n  vec3 stepVC = rayDirVC * sampleDistance;\n  float raySteps = (maxDistance - minDistance) / sampleDistance;\n\n  // Avoid 0.0 jitter\n  float jitter = 0.01 + 0.99 * fragmentSeed;\n\n  #if vtkBlendMode == COMPOSITE_BLEND\n    // now map through opacity and color\n    vec3 firstPosVC = rayOriginVC + minDistance * rayDirVC;\n    vec4 firstColor = getColorAtPos(firstPosVC);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      firstColor.a = 1.0 - pow(1.0 - firstColor.a, raySteps);\n      gl_FragData[0] = firstColor;\n      return;\n    }\n\n    // first color only counts for `jitter` factor of the step\n    firstColor.a = 1.0 - pow(1.0 - firstColor.a, jitter);\n    vec4 color = vec4(firstColor.rgb * firstColor.a, firstColor.a);\n    vec3 posVC = firstPosVC + jitter * stepVC;\n    float stepsTraveled = jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n      vec4 tColor = getColorAtPos(posVC);\n\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * (1.0 - color.a);\n      stepsTraveled++;\n      posVC += stepVC;\n      if (color.a > 0.99) {\n        color.a = 1.0;\n        break;\n      }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0) {\n      vec3 endPosVC = rayOriginVC + maxDistance * rayDirVC;\n      vec4 tColor = getColorAtPos(endPosVC);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb / color.a, color.a);\n  #endif\n\n  #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND ||                                 \\\n      vtkBlendMode == MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND\n      #define OP max\n    #else\n      #define OP min\n    #endif\n\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // Find a value to initialize the selected variables\n    vec4 selectedValue;\n    vec3 selectedPosVC;\n    vec3 selectedPosIS;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      selectedValue = getTextureValue(posIS);\n      selectedPosVC = posVC;\n      selectedPosIS = posIS;\n    }\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // Get selected values\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n    }\n\n    gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n  #endif\n\n  #if vtkBlendMode == ADDITIVE_INTENSITY_BLEND ||                                \\\n      vtkBlendMode == AVERAGE_INTENSITY_BLEND\n    vec4 sum = vec4(0.);\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      float totalWeight = 0.0;\n    #endif\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 value = getTextureValue(posIS);\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(value * raySteps, posVC, posIS);\n      return;\n    }\n\n    if (valueWithinScalarRange(value)) {\n      sum += value * jitter;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += jitter;\n      #endif\n    }\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      posIS = posVCtoIS(posVC);\n      value = getTextureValue(posIS);\n      // One can control the scalar range by setting the AverageIPScalarRange to\n      // disregard scalar values, not in the range of interest, from the average\n      // computation. Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(value)) {\n        sum += value;\n        #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n          totalWeight++;\n        #endif\n      }\n\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    posIS = posVCtoIS(posVC);\n    value = getTextureValue(posIS);\n    if (valueWithinScalarRange(value)) {\n      sum += value;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += raySteps - stepsTraveled;\n      #endif\n    }\n\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      sum /= vec4(totalWeight, totalWeight, totalWeight, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posVC, posIS);\n  #endif\n\n  #if vtkBlendMode == RADON_TRANSFORM_BLEND\n    float normalizedRayIntensity = 1.0;\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 tValue = getTextureValue(posIS);\n      normalizedRayIntensity -= raySteps * sampleDistance *\n                                getOpacityFromTexture(tValue.r, 0, 0.5);\n      gl_FragData[0] =\n          vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 value = getTextureValue(posIS);\n      // Convert scalar value to normalizedRayIntensity coefficient and\n      // accumulate normalizedRayIntensity\n      normalizedRayIntensity -=\n          sampleDistance * getOpacityFromTexture(value.r, 0, 0.5);\n\n      posVC += stepVC;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] =\n        vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n  #endif\n\n  #if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n    // Only works with a single volume\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 tValue = getTextureValue(posIS);\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(tValue, posVC, posIS);\n      return;\n    }\n\n    vec3 stepIS = vecVCToIS(stepVC);\n    vec4 value = tValue;\n    posIS += jitter * stepIS;\n    stepsTraveled += jitter;\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading\n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the\n      // segment index and later check if the bit is set via bit operations\n      setLabelOutlineBit(segmentIndex);\n    }\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setLabelOutlineBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value = tValue;   // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = posVCtoIS(rayOriginVC + maxDistance * rayDirVC);\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue;   // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }\n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      vec3 maxPosVC = posIStoVC(maxPosIS);\n      gl_FragData[0] = getColorForValue(value, maxPosVC, maxPosIS);\n      return;\n    }\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    vec3 volumeSpacings = volume.spacing;\n    float minVoxelSpacing =\n        min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base =\n        vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z,\n                          gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z,\n                          gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not\n      // been seen by the center segment\n      if (!isLabelOutlineBitSet(s)) {\n        continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have\n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue =\n          texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out\n      // faster if we find the edge\n      bool onEdge = checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s,\n                                          stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than\n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety\n      // of the all the fragments inside. i.e., this happens when we zoom out,\n      if (minVoxelSpacing >\n          (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n\n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n        for (int j = -actualThickness; j <= actualThickness; j++) {\n          if (i == 0 && j == 0)\n            continue; // Skip the center\n          if (abs(i) == actualThickness && abs(j) == actualThickness)\n            continue; // Skip corners\n          if (checkOnEdgeForNeighbor(i, j, s, stepIS)) {\n            return;\n          }\n        }\n      }\n    }\n\n    float sampleHeight = volume.transferFunctionsSampleHeight[0];\n    vec3 tColor0 = getColorFromTexture(value.r, 0, sampleHeight);\n    float pwfValue0 = getOpacityFromTexture(value.r, 0, sampleHeight);\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  vec2 dists = rayIntersectVolumeDistances(rayOriginVC, rayDirVC);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0, dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick / rayDirVC.z;\n  dists.y = min(farDist, dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\nfloat getFragmentSeed() {\n  // This first noise has a diagonal pattern\n  float firstNoise =\n      fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n  // This second noise is made out of blocks of CPU generated noise\n  float secondNoise = texture2D(jtexture, gl_FragCoord.xy / 32.0).r;\n  // Combine the two sources of noise in a way that the distribution is uniform\n  // in [0,1[\n  float noiseSum = firstNoise + secondNoise;\n  return noiseSum < 1.0 ? noiseSum : noiseSum - 1.0;\n}\n\nvoid main() {\n  fragmentSeed = getFragmentSeed();\n\n  if (cameraParallel == 1) {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 rayOriginVC = vertexVCVSOutput;\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayOriginVC, rayDirVC);\n  if (rayStartEndDistancesVC[1] <= rayStartEndDistancesVC[0] ||\n      rayStartEndDistancesVC[1] <= 0.0) {\n    // Volume not hit or behind the ray\n    discard;\n  }\n\n  // Perform the blending operation along the ray\n  applyBlend(rayOriginVC, rayDirVC, rayStartEndDistancesVC[0], rayStartEndDistancesVC[1]);\n}\n",e.Geometry=""},e.replaceShaderValues=(e,n,r)=>{let o=e.Fragment;o=td.substitute(o,"//VTK::EnabledColorFunctions",`#define EnableColorForValueFunctionId${t.previousState.colorForValueFunctionId}`).result;const a=[];t.previousState.surfaceLightingEnabled&&a.push("Surface"),t.previousState.volumeLightingEnabled&&a.push("Volume"),o=td.substitute(o,"//VTK::EnabledLightings",a.map((e=>`#define Enable${e}Lighting`))).result,t.previousState.multiTexturePerVolumeEnabled&&(o=td.substitute(o,"//VTK::EnabledMultiTexturePerVolume","#define EnabledMultiTexturePerVolume").result),t.previousState.useIndependentComponents&&(o=td.substitute(o,"//VTK::EnabledIndependentComponents","#define EnabledIndependentComponents").result),t.previousState.gradientOpacityEnabled&&(o=td.substitute(o,"//VTK::EnabledGradientOpacity","#define EnabledGradientOpacity").result),o=td.substitute(o,"//VTK::vtkProportionalComponents",t.previousState.proportionalComponents.map((e=>`#define vtkComponent${e}Proportional`)).join("\n")).result,o=td.substitute(o,"//VTK::vtkForceNearestComponents",t.previousState.forceNearestComponents.map((e=>`#define vtkComponent${e}ForceNearest`)).join("\n")).result,t.previousState.hasZBufferTexture&&(o=td.substitute(o,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,o=td.substitute(o,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDirVC.z;","dists.y = min(zdepth,dists.y);"]).result),o=td.substitute(o,"//VTK::BlendMode",`${t.previousState.blendMode}`).result,o=td.substitute(o,"//VTK::NumberOfLights",`${t.previousState.numberOfLights}`).result,o=td.substitute(o,"//VTK::MaxLaoKernelSize",`${t.previousState.maxLaoKernelSize}`).result,o=td.substitute(o,"//VTK::NumberOfComponents",`${t.previousState.numberOfComponents}`).result,o=td.substitute(o,"//VTK::MaximumNumberOfSamples",`${t.previousState.maximumNumberOfSamples}`).result,e.Fragment=o;const i=t.previousState.numberOfClippingPlanes;i>0&&(o=td.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=td.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${i}; i++) {`,"  float rayDirRatio = dot(rayDirVC, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result),e.Fragment=o},e.getNeedToRebuildShaders=(r,o,a)=>{const i=!!t.zBufferTexture,s=t.currentValidInputs.length,l=t.numberOfLights,c=t.numberOfComponents,u=t.useIndependentComponents,d=a.getProperties(),p=t.currentValidInputs[0],f=d[p.inputIndex],g=s>1,m=p.imageData.getBounds(),h=Gi.getDiagonalLength(m),v=Math.ceil(h/e.getCurrentSampleDistance(o));v>t.renderable.getMaximumSamplesPerRay()&&ng(`The number of steps required ${v} is larger than the specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\nPlease either change the volumeMapper sampleDistance or its maximum number of samples.`);const T=u?c:1;let y=!1;for(let e=0;e<T;++e)if(f.getUseGradientOpacity(e)){y=!0;break}let b=0;const x=f.getLAOKernelSize();x>b&&f.getLocalAmbientOcclusion()&&f.getAmbient()>0&&(b=x);const C=t.renderable.getClippingPlanes().length,S=t.renderable.getViewSpecificProperties().OpenGL?.ShaderReplacements,A=t.currentRenderPass?.getShaderReplacement(),I=t.renderable.getBlendMode(),w=(()=>{if(I!==eg.LABELMAP_EDGE_PROJECTION_BLEND&&n(f))return 5;if(u)switch(f.getColorMixPreset()){case Qf.ADDITIVE:return 1;case Qf.COLORIZE:return 2;case Qf.CUSTOM:return 3;default:return 4}return 0})(),O=f.getVolumetricScatteringBlending()<1,P=f.getVolumetricScatteringBlending()>0;let R=!1;for(let e=0;e<c;++e)if(f.getForceNearestInterpolation(e)){R=!0;break}const M=[],E=[];for(let e=0;e<c;e++)f.getOpacityMode(e)===Zf.PROPORTIONAL&&M.push(e),f.getForceNearestInterpolation(e)&&E.push(e);const V={numberOfComponents:c,useIndependentComponents:u,proportionalComponents:M,forceNearestComponents:E,blendMode:I,numberOfLights:l,numberOfValidInputs:s,maximumNumberOfSamples:v,hasZBufferTexture:i,maxLaoKernelSize:b,numberOfClippingPlanes:C,mapperShaderReplacements:S,renderPassShaderReplacements:A,colorForValueFunctionId:w,surfaceLightingEnabled:O,volumeLightingEnabled:P,forceNearestInterpolationEnabled:R,multiTexturePerVolumeEnabled:g,gradientOpacityEnabled:y};return!(0!==r.getProgram()?.getHandle()&&t.previousState&&ke(t.previousState,V)||(t.previousState=V,0))},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||rg("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified());const i=e.getCurrentSampleDistance(r);a.setUniformf("sampleDistance",i);const s=i*t.renderable.getVolumeShadowSamplingDistFactor();a.setUniformf("volumeShadowSampleDistance",s),t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())}));const l=o.getProperties()[t.currentValidInputs[0].inputIndex].getIpScalarRange(),c=new Float32Array(4),u=new Float32Array(4),d=(e,t,n)=>{t?.dataComputedScale?.length&&(c[e]=l[0]*t.dataComputedScale[n]+t.dataComputedOffset[n],u[e]=l[1]*t.dataComputedScale[n]+t.dataComputedOffset[n],c[e]=(c[e]-t.offset[n])/t.scale[n],u[e]=(u[e]-t.offset[n])/t.scale[n])};if(t.previousState.multiTexturePerVolumeEnabled)t.scalarTextures.forEach(((e,t)=>{const n=e.getVolumeInfo();d(t,n,0)}));else{const e=t.scalarTextures[0].getVolumeInfo();for(let t=0;t<4;++t)d(t,e,t)}const p="volume";if(a.setUniform4f(`${p}.ipScalarRangeMin`,c[0],c[1],c[2],c[3]),a.setUniform4f(`${p}.ipScalarRangeMax`,u[0],u[1],u[2],u[3]),null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(r,o,a)=>{const{idxToView:i,vecISToVCMatrix:s,modelToView:l,projectionToView:c,projectionToWorld:u}=og,d=t.openGLCamera.getKeyMatrices(o),p=t.openGLVolume.getKeyMatrices();b(l,d.wcvc,p.mcwc);const f=r.getProgram(),g=t.openGLCamera.getRenderable(),m=g.getParallelProjection(),h=g.getClippingRange();f.setUniformf("camThick",h[1]-h[0]),f.setUniformf("camNear",h[0]),f.setUniformf("camFar",h[1]),f.setUniformi("cameraParallel",m);const T=t.currentValidInputs[0],y=T.imageData.getBounds(),x=Gi.getCorners(y,[]).map((e=>(In(e,e,l),m||bn(e,e,-h[0]/(e[2]*gn(e))),In(e,e,d.vcpc),e))),C=Gi.addPoints([...Gi.INIT_BOUNDS],x);f.setUniformf("dcxmin",C[0]),f.setUniformf("dcxmax",C[1]),f.setUniformf("dcymin",C[2]),f.setUniformf("dcymax",C[3]);const S=e.getRenderTargetSize();f.setUniformf("vpWidth",S[0]),f.setUniformf("vpHeight",S[1]);const A=e.getRenderTargetOffset();f.setUniformf("vpOffsetX",A[0]/S[0]),f.setUniformf("vpOffsetY",A[1]/S[1]),v(c,d.vcpc),f.setUniformMatrix("PCVCMatrix",c),f.setUniformi("twoSidedLighting",o.getTwoSidedLighting());const I=new Array(2*t.previousState.maxLaoKernelSize);for(let e=0;e<t.previousState.maxLaoKernelSize;e++)I[2*e]=Math.random(),I[2*e+1]=Math.random();if(f.setUniform2fv("kernelSample",I),t.numberOfLights>0){let e=0;o.getLights().forEach((t=>{if(t.getSwitch()>0){const n=`lights[${e}]`,r=bn([],t.getColor(),t.getIntensity());f.setUniform3fv(`${n}.color`,r);const o=t.getTransformedPosition();In(o,o,l),f.setUniform3fv(`${n}.positionVC`,o);const a=[...t.getDirection()];wn(a,a,d.normalMatrix),Cn(a,a),f.setUniform3fv(`${n}.directionVC`,a);const i=[-.5*a[0],-.5*a[1],-.5*(a[2]-1)];f.setUniform3fv(`${n}.halfAngleVC`,i);const s=t.getAttenuationValues();f.setUniform3fv(`${n}.attenuation`,s);const c=t.getExponent();f.setUniformf(`${n}.exponent`,c);const u=t.getConeAngle();f.setUniformf(`${n}.coneAngle`,u);const p=t.getPositional();f.setUniformi(`${n}.isPositional`,p),e++}}))}const w="volume",O=a.getProperties()[T.inputIndex],P=T.imageData,R=P.getSpatialExtent(),M=P.getSpacing(),E=P.getDimensions(),V=P.getIndexToWorld(),D=P.getWorldToIndex(),L=P.getDirectionByReference();b(i,l,V),f.setUniform3fv(`${w}.spacing`,M);const B=xn([],M);f.setUniform3fv(`${w}.inverseSpacing`,B),f.setUniform3iv(`${w}.dimensions`,E),f.setUniform3fv(`${w}.inverseDimensions`,xn([],E)),f.setUniformMatrix(`${w}.worldToIndex`,D),s.fill(0);const N=yn(new Float64Array(3),E,M);s[0]=N[0],s[4]=N[1],s[8]=N[2],Te(s,L,s),Te(s,p.normalMatrix,s),Te(s,d.normalMatrix,s),f.setUniformMatrix3x3(`${w}.vecISToVCMatrix`,s),f.setUniformMatrix3x3(`${w}.vecVCToISMatrix`,me(new Float32Array(9),s));const F=mn(R[0],R[2],R[4]),_=In(new Float64Array(3),F,i);f.setUniform3fv(`${w}.originVC`,_);const k=gn(N);if(f.setUniformf(`${w}.diagonalLength`,k),n(O)){const e=g.getDistance();g.setClippingRange(e,e+.1),v(u,t.openGLCamera.getKeyMatrices(o).wcpc),g.setClippingRange(h[0],h[1]),t.openGLCamera.getKeyMatrices(o),f.setUniformMatrix(`${w}.PCWCMatrix`,u)}if(O.getVolumetricScatteringBlending()>0&&(f.setUniformf(`${w}.globalIlluminationReach`,O.getGlobalIlluminationReach()),f.setUniformf(`${w}.volumetricScatteringBlending`,O.getVolumetricScatteringBlending()),f.setUniformf(`${w}.anisotropy`,O.getAnisotropy()),f.setUniformf(`${w}.anisotropySquared`,O.getAnisotropy()**2)),O.getLocalAmbientOcclusion()&&O.getAmbient()>0){const e=O.getLAOKernelSize();f.setUniformi(`${w}.kernelSize`,e);const t=O.getLAOKernelRadius();f.setUniformi(`${w}.kernelRadius`,t)}else f.setUniformi(`${w}.kernelSize`,0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi("jtexture",t.jitterTexture.getTextureUnit());const a=r.getProperties();o.setUniformi("labelOutlineThicknessTexture",t.labelOutlineThicknessTexture.getTextureUnit()),o.setUniformi("opacityTexture",t.opacityTexture.getTextureUnit()),o.setUniformi("colorTexture",t.colorTexture.getTextureUnit());const i="volume",s=a[t.currentValidInputs[0].inputIndex],l=t.previousState.numberOfComponents,c=t.previousState.useIndependentComponents;if(c){const e=new Float32Array(4);for(let t=0;t<l;t++)e[t]=s.getComponentWeight(t);o.setUniform4fv(`${i}.independentComponentMix`,e);const t=new Float32Array(4),n=1/l;for(let e=0;e<l;++e)t[e]=(e+.5)*n;o.setUniform4fv(`${i}.transferFunctionsSampleHeight`,t)}const u=t.colorForValueFunctionId;o.setUniformi(`${i}.colorForValueFunctionId`,u);const d=s.getComputeNormalFromOpacity();o.setUniformi(`${i}.computeNormalFromOpacity`,d);const p=new Float32Array(4),f=new Float32Array(4),g=new Float32Array(4),m=new Float32Array(4);for(let e=0;e<l;e++){const n=t.previousState.multiTexturePerVolumeEnabled,r=n?e:0,o=n?0:e,a=t.scalarTextures[r].getVolumeInfo(),i=c?e:0,l=a.scale[o],u=s.getRGBTransferFunction(i).getRange();p[e]=l/(u[1]-u[0]),f[e]=(a.offset[o]-u[0])/(u[1]-u[0]);const d=s.getScalarOpacity(i).getRange();g[e]=l/(d[1]-d[0]),m[e]=(a.offset[o]-d[0])/(d[1]-d[0])}if(o.setUniform4fv(`${i}.colorTextureScale`,p),o.setUniform4fv(`${i}.colorTextureShift`,f),o.setUniform4fv(`${i}.opacityTextureScale`,g),o.setUniform4fv(`${i}.opacityTextureShift`,m),t.previousState.gradientOpacityEnabled){const e=new Array(4),n=new Array(4),r=new Array(4),a=new Array(4);if(c)for(let o=0;o<l;++o){const i=t.previousState.multiTexturePerVolumeEnabled,l=i?o:0,c=i?0:o,u=t.scalarTextures[l].getVolumeInfo().scale[c];if(s.getUseGradientOpacity(o)){const t=[s.getGradientOpacityMinimumOpacity(o),s.getGradientOpacityMaximumOpacity(o)],i=[s.getGradientOpacityMinimumValue(o),s.getGradientOpacityMaximumValue(o)];r[o]=t[0],a[o]=t[1],e[o]=u*(t[1]-t[0])/(i[1]-i[0]),n[o]=-i[0]*(t[1]-t[0])/(i[1]-i[0])+t[0]}else r[o]=1,a[o]=1,e[o]=0,n[o]=1}else{const o=l-1,i=t.previousState.multiTexturePerVolumeEnabled,c=i?o:0,u=i?0:o,d=t.scalarTextures[c].getVolumeInfo().scale[u],p=[s.getGradientOpacityMinimumOpacity(0),s.getGradientOpacityMaximumOpacity(0)],f=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];r[0]=p[0],a[0]=p[1],e[0]=d*(p[1]-p[0])/(f[1]-f[0]),n[0]=-f[0]*(p[1]-p[0])/(f[1]-f[0])+p[0]}o.setUniform4f(`${i}.gradientOpacityScale`,e),o.setUniform4f(`${i}.gradientOpacityShift`,n),o.setUniform4f(`${i}.gradientOpacityMin`,r),o.setUniform4f(`${i}.gradientOpacityMax`,a)}const h=s.getLabelOutlineOpacity();if(o.setUniformf(`${i}.outlineOpacity`,h),t.numberOfLights>0){o.setUniformf(`${i}.ambient`,s.getAmbient()),o.setUniformf(`${i}.diffuse`,s.getDiffuse()),o.setUniformf(`${i}.specular`,s.getSpecular());const e=s.getSpecularPower();o.setUniformf(`${i}.specularPower`,0===e?1:e)}},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();wn(t,t,r.normalMatrix),In(n,n,r.wcvc);const l=-1*Sn(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Et((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r);const a=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=a[n].getInterpolationType(),o=t.scalarTextures[n];r===Yf.NEAREST?(o.setMinificationFilter(ud.NEAREST),o.setMagnificationFilter(ud.NEAREST)):(o.setMinificationFilter(ud.LINEAR),o.setMagnificationFilter(ud.LINEAR))})),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.opacityTexture,t.labelOutlineThicknessTexture,t.jitterTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=od.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||rg("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}let a=0;if(t.currentValidInputs.length>0){const e=r.getProperties(),o=t.currentValidInputs[0],i=o.imageData.getPointData().getScalars(),s=e[o.inputIndex];s.getShade()&&t.renderable.getBlendMode()===eg.COMPOSITE_BLEND&&n.getLights().forEach((e=>{e.getSwitch()>0&&a++}));const l=t.currentValidInputs.length,c=l>1;t.numberOfComponents=c?l:i.getNumberOfComponents(),t.useIndependentComponents=function(e,t){const n=e.getIndependentComponents(),r=e.getColorMixPreset();return n&&t>=2||!!r}(s,t.numberOfComponents)}a!==t.numberOfLights&&(t.numberOfLights=a,e.modified()),e.invokeEvent({type:"EndEvent"}),0!==t.currentValidInputs.length&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.opacityTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.jitterTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{if(!t.jitterTexture.getHandle()){const e=new Float32Array(1024);for(let t=0;t<1024;++t)e[t]=Math.random();t.jitterTexture.setMinificationFilter(ud.NEAREST),t.jitterTexture.setMagnificationFilter(ud.NEAREST),t.jitterTexture.create2DFromRaw({width:32,height:32,numComps:1,dataType:cs.FLOAT,data:e})}const a=r.getProperties(),i=t.currentValidInputs[0],s=a[i.inputIndex],l=t.numberOfComponents,c=t.useIndependentComponents,u=c?l:1,d=[];for(let e=0;e<u;++e)d.push(s.getScalarOpacity(e));const p=wf(d,c,u),f=s.getScalarOpacity(),g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g.hash===p)t.opacityTexture=g.oglObject;else{const r=Pd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow);let o=t.renderable.getOpacityTextureWidth();o<=0&&(o=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const a=2*o*u,i=new Float32Array(a),l=new Float32Array(o);for(let t=0;t<u;++t){const r=s.getScalarOpacity(t),a=e.getCurrentSampleDistance(n)/s.getScalarOpacityUnitDistance(t),c=r.getRange();r.getTable(c[0],c[1],o,l,1);for(let e=0;e<o;++e)i[t*o*2+e]=1-(1-l[e])**a,i[t*o*2+e+o]=i[t*o*2+e]}if(r.resetFormatAndType(),r.setMinificationFilter(ud.LINEAR),r.setMagnificationFilter(ud.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:cs.FLOAT,data:i});else{const e=new Uint8ClampedArray(a);for(let t=0;t<a;++t)e[t]=255*i[t];r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:cs.UNSIGNED_CHAR,data:e})}f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,r,p),t.opacityTexture=r}o(t._openGLRenderWindow,t._opacityTextureCore,f),t._opacityTextureCore=f;const m=[];for(let e=0;e<u;++e)m.push(s.getRGBTransferFunction(e));const h=wf(m,c,u),v=s.getRGBTransferFunction(),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===h)t.colorTexture=T.oglObject;else{const e=Pd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(2*n*u*3),o=new Float32Array(3*n);for(let e=0;e<u;++e){const t=s.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}e.resetFormatAndType(),e.setMinificationFilter(ud.LINEAR),e.setMagnificationFilter(ud.LINEAR),e.create2DFromRaw({width:n,height:2*u,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r}),t._openGLRenderWindow.setGraphicsResourceForObject(v,e,h),t.colorTexture=e}o(t._openGLRenderWindow,t._colorTextureCore,v),t._colorTextureCore=v,t.currentValidInputs.forEach(((e,n)=>{let{imageData:r,inputIndex:i}=e;const s=a[i],l=r.getPointData().getScalars(),c=t._openGLRenderWindow.getGraphicsResourceForObject(l),u=Of(0,l),d=!c?.oglObject?.getHandle()||c?.hash!==u,p=s.getUpdatedExtents(),f=!!p.length;if(d&&!f){const e=Pd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const o=r.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:o[0],height:o[1],depth:o[2],dataArray:l,preferSizeOverAccuracy:s.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(l,e,u),t.scalarTextures[n]=e}else t.scalarTextures[n]=c.oglObject;if(f){s.setUpdatedExtents([]);const e=r.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:l,updatedExtents:p})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],l),t._scalarTexturesCore[n]=l}));const y=s.getLabelOutlineThickness(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y),x=y.join("-");if(b?.oglObject?.getHandle()&&b?.hash===x)t.labelOutlineThicknessTexture=b.oglObject;else{const e=Pd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=1,o=new Uint8Array(n*r);for(let e=0;e<n;++e){const t=void 0!==y[e]?y[e]:y[0];o[e]=t}e.resetFormatAndType(),e.setMinificationFilter(ud.NEAREST),e.setMagnificationFilter(ud.NEAREST),e.create2DFromRaw({width:n,height:r,numComps:1,dataType:cs.UNSIGNED_CHAR,data:o}),y&&t._openGLRenderWindow.setGraphicsResourceForObject(y,e,x),t.labelOutlineThicknessTexture=e}if(o(t._openGLRenderWindow,t._labelOutlineThicknessTextureCore,y),t._labelOutlineThicknessTextureCore=y,!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=xs.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=xs.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",Zi.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLVolumeMapper");Jt("vtkVolumeMapper",ig);const{vtkDebugMacro:sg}=Ht,lg={};const cg=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lg,n),qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():sg("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");Jt("vtkPixelSpaceCallbackMapper",cg);var ug="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:dg}=os;function pg(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Pd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw({width:o,height:a,numComps:4,dataType:"Float32Array",data:null}),s.activate(),s.sendParameters(),s.deactivate(),s}function fg(e,t){return pg(e,t,Pd.Filter.NEAREST,Pd.Wrap.CLAMP_TO_EDGE)}const gg={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function mg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gg,n),Wt.obj(e,t),Wt.get(e,t,["readIndex"]),Wt.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),Wt.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=ld.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=xs.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=xs.newInstance({numberOfComponents:1,values:o}),s=xs.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",dg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=fg(t._openGLRenderWindow,t.size),t.seedTexture0=fg(t._openGLRenderWindow,t.size),t.licTexture1=fg(t._openGLRenderWindow,t.size),t.seedTexture1=fg(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?pg(t._openGLRenderWindow,t.size,Pd.Filter.NEAREST,Pd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?(n=t._openGLRenderWindow,r=t.size,pg(n,r,Pd.Filter.LINEAR,Pd.Wrap.CLAMP_TO_EDGE)):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=od.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager");var n,r}(e,t)}var hg={newInstance:Wt.newInstance(mg,"vtkLICPingPongBufferManager"),extend:mg};const vg=0,Tg=1,yg=2,bg=3,xg=1,Cg={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function Sg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cg,n),Wt.obj(e,t),Wt.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),Wt.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(ug,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Sp.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=td.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=td.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ":"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    "}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=Sp.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=hg.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],T=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;T.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",0),y.setUniformf("uMaskThreshold",t.maskThreshold),y.setUniform2f("uNoiseBoundsPt1",...m),y.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),y.setUniformi("texLIC",t.bufs.getLICTextureUnit()),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:b}=t;T.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==Tg&&t.enhanceContrast!==bg||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",1),n(y,t.bufs),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;T.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)T.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),T.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Tg&&t.enhanceContrast!==bg||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}(e,t)}var Ag={newInstance:Wt.newInstance(Sg,"vtkLineIntegralConvolution2D"),extend:Sg};const Ig={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:vg,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:xg,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function wg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ig,n),Wt.obj(e,t),Wt.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),function(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}(0,t)}var Og={newInstance:Wt.newInstance(wg,"vtkSurfaceLICInterface"),extend:wg};const{Representation:Pg}=os;const Rg={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function Mg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rg,n),Og.extend(e,t,n),Wt.obj(e,t),Wt.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),Wt.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=od.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),oo(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===xg?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Pd.newInstance({wrapS:Pd.Wrap.REPEAT,wrapT:Pd.Wrap.REPEAT,minificationFilter:Pd.Filter.NEAREST,magnificationFilter:Pd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw({width:e,height:e,numComps:4,dataType:"Float32Array",data:d}),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(ug,e,""),e.allocateTextures=()=>{const n=Pd.Filter.NEAREST,r=Pd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Pd.newInstance({wrapS:Pd.Wrap.CLAMP_TO_EDGE,wrapT:Pd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw({width:t.size[0],height:t.size[1],numComps:4,dataType:"Float32Array",data:null}),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Pd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw({width:t.size[0],height:t.size[1],dataType:"Float32Array",data:null}),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Sp.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=ld.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=xs.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=xs.newInstance({numberOfComponents:1,values:o}),s=xs.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",Pg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=Ag.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===yg||u===bg){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}(e,t)}var Eg={newInstance:Wt.newInstance(Mg,"vtkSurfaceLICInterface"),extend:Mg};const{vtkErrorMacro:Vg}=Ht,Dg={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const Lg=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dg,n),$d.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=td.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=td.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=td.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=td.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=td.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(Vg("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(Vg("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(Vg("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Og.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=Eg.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(Vg("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}(e,t),Ct(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");Jt("vtkSurfaceLICMapper",Lg);const{vtkErrorMacro:Bg}=Ht,Ng={};const Fg=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ng,n),$d.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=Md,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=td.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=td.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=td.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=td.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=td.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=td.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=td.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||Bg("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc);const s=new Float64Array(16);if(o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())p(s,i.wcvc),e.getCABO().getCoordShiftAndScaleEnabled()&&b(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s);else{const n=t.openGLActor.getKeyMatrices();b(s,i.wcvc,n.mcwc),e.getCABO().getCoordShiftAndScaleEnabled()&&b(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(zu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(vo(30));let h=0,v=0;const{useShiftAndScale:T,coordShift:y,coordScale:b}=Wu(s);T&&a.setCoordShiftAndScale(y,b);let x=0,C=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e;const r=(c[h++]-y[0])*b[0],o=(c[h++]-y[1])*b[1],a=(c[h++]-y[2])*b[2];g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=-2*n*m,g[x++]=-n,d&&(v=e*p,f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=2*n*m,g[x++]=-n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=0,g[x++]=2*n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3])}a.setElementCount(x/5),a.upload(g,Fu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,Fu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLSphereMapper");Jt("vtkSphereMapper",Fg);const{vtkErrorMacro:_g}=Ht,kg={};const Gg=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kg,n),$d.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=Md,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=td.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=td.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=td.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=td.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=td.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=td.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=td.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||_g("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||_g("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||_g("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);b(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);Te(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(zu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():_g(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let T=0,y=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)T=3*e,f[b++]=c[T++],f[b++]=c[T++],f[b++]=c[T++],T=3*e,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,y=e*p,d&&(g[x++]=d[y],g[x++]=d[y+1],g[x++]=d[y+2],g[x++]=d[y+3])}a.setElementCount(b/7),a.upload(f,Fu.ARRAY_BUFFER),a.getColorBO().upload(g,Fu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLStickMapper");Jt("vtkStickMapper",Gg);const Ug=[];Ug["-".charCodeAt(0)]=62,Ug["_".charCodeAt(0)]=63;const zg="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<64;e++)Ug[zg.charCodeAt(e)]=e;function Wg(e){return void 0!==Ug[e.charCodeAt(0)]}function Hg(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!Wg(e[l]);)l++;for(c=Ug[e.charCodeAt(l++)]<<18;!Wg(e[l]);)l++;for(c|=Ug[e.charCodeAt(l++)]<<12;!Wg(e[l]);)l++;for(c|=Ug[e.charCodeAt(l++)]<<6;!Wg(e[l]);)l++;c|=Ug[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!Wg(e[l]);)l++;for(c=Ug[e.charCodeAt(l++)]<<10;!Wg(e[l]);)l++;for(c|=Ug[e.charCodeAt(l++)]<<4;!Wg(e[l]);)l++;c|=Ug[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!Wg(e[l]);)l++;for(c=Ug[e.charCodeAt(l++)]<<2;!Wg(e[l]);)l++;c|=Ug[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function jg(e,t,n){const r=(e<<16)+(t<<8)+n;return zg[r>>18]+zg[r>>12&63]+zg[r>>6&63]+zg[63&r]}function Kg(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=jg(t[n],t[n+1],t[n+2])}if(n>0){const e=jg(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var $g={toArrayBuffer:function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)Wg(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Hg(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o},fromArrayBuffer:Kg};const qg={};function Xg(e,t){qg[e]=t}var Yg={get:function(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return qg[arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http"](e)},has:function(e){return!!qg[e]},registerType:Xg},Zg=Uint8Array,Qg=Uint16Array,Jg=Uint32Array,em=new Zg([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),tm=new Zg([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),nm=new Zg([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),rm=function(e,t){for(var n=new Qg(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Jg(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},om=rm(em,2),am=om[0],im=om[1];am[28]=258,im[258]=28;for(var sm=rm(tm,0),lm=sm[0],cm=(sm[1],new Qg(32768)),um=0;um<32768;++um){var dm=(43690&um)>>>1|(21845&um)<<1;dm=(61680&(dm=(52428&dm)>>>2|(13107&dm)<<2))>>>4|(3855&dm)<<4,cm[um]=((65280&dm)>>>8|(255&dm)<<8)>>>1}var pm=function(e,t,n){for(var r=e.length,o=0,a=new Qg(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Qg(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Qg(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[cm[d]>>>l]=c}else for(i=new Qg(r),o=0;o<r;++o)e[o]&&(i[o]=cm[s[e[o]-1]++]>>>15-e[o]);return i},fm=new Zg(288);for(um=0;um<144;++um)fm[um]=8;for(um=144;um<256;++um)fm[um]=9;for(um=256;um<280;++um)fm[um]=7;for(um=280;um<288;++um)fm[um]=8;var gm=new Zg(32);for(um=0;um<32;++um)gm[um]=5;var mm=pm(fm,9,1),hm=pm(gm,5,1),vm=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},Tm=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},ym=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},bm=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Qg:4==e.BYTES_PER_ELEMENT?Jg:Zg)(n-t);return r.set(e.subarray(t,n)),r},xm=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Cm=function(e,t,n){var r=new Error(t||xm[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,Cm),!n)throw r;return r},Sm=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Zg(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Zg(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Zg(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=Tm(e,c,1);var h=Tm(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(P=4+((i+7)/8|0))-4)]|e[P-3]<<8,T=P+v;if(T>r){a&&Cm(0);break}o&&s(u+v),t.set(e.subarray(P,T),u),n.b=u+=v,n.p=c=8*T,n.f=l;continue}if(1==h)d=mm,p=hm,f=9,g=5;else if(2==h){var y=Tm(e,c,31)+257,b=Tm(e,c+10,15)+4,x=y+Tm(e,c+5,31)+1;c+=14;for(var C=new Zg(x),S=new Zg(19),A=0;A<b;++A)S[nm[A]]=Tm(e,c+3*A,7);c+=3*b;var I=vm(S),w=(1<<I)-1,O=pm(S,I,1);for(A=0;A<x;){var P,R=O[Tm(e,c,w)];if(c+=15&R,(P=R>>>4)<16)C[A++]=P;else{var M=0,E=0;for(16==P?(E=3+Tm(e,c,3),c+=2,M=C[A-1]):17==P?(E=3+Tm(e,c,7),c+=3):18==P&&(E=11+Tm(e,c,127),c+=7);E--;)C[A++]=M}}var V=C.subarray(0,y),D=C.subarray(y);f=vm(V),g=vm(D),d=pm(V,f,1),p=pm(D,g,1)}else Cm(1);if(c>m){a&&Cm(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var F=(M=d[ym(e,c)&L])>>>4;if((c+=15&M)>m){a&&Cm(0);break}if(M||Cm(2),F<256)t[u++]=F;else{if(256==F){N=c,d=null;break}var _=F-254;if(F>264){var k=em[A=F-257];_=Tm(e,c,(1<<k)-1)+am[A],c+=k}var G=p[ym(e,c)&B],U=G>>>4;if(G||Cm(3),c+=15&G,D=lm[U],U>3&&(k=tm[U],D+=ym(e,c)&(1<<k)-1,c+=k),c>m){a&&Cm(0);break}o&&s(u+131072);for(var z=u+_;u<z;u+=4)t[u]=t[u-D],t[u+1]=t[u+1-D],t[u+2]=t[u+2-D],t[u+3]=t[u+3-D];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:bm(t,0,u)},Am=new Zg(0),Im=function(e,t){return e[t]|e[t+1]<<8},wm=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Om=function(e,t){return wm(e,t)+4294967296*wm(e,t+4)};function Pm(e,t){return Sm(e,t)}function Rm(e,t){return Sm(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||Cm(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Zg((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function Mm(e,t){return Sm(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&Cm(6,"invalid zlib data"),32&n[1]&&Cm(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function Em(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Rm(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Pm(e,t):Mm(e,t)}var Vm="undefined"!=typeof TextEncoder&&new TextEncoder,Dm="undefined"!=typeof TextDecoder&&new TextDecoder;try{Dm.decode(Am,{stream:!0})}catch(e){}function Lm(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(Dm)return Dm.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,bm(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&Cm(8),a}var Bm=function(e,t){return t+30+Im(e,t+26)+Im(e,t+28)},Nm=function(e,t,n){var r=Im(e,t+28),o=Lm(e.subarray(t+46,t+46+r),!(2048&Im(e,t+8))),a=t+46+r,i=wm(e,t+20),s=n&&4294967295==i?Fm(e,a):[i,wm(e,t+24),wm(e,t+42)],l=s[0],c=s[1],u=s[2];return[Im(e,t+10),l,c,o,a+Im(e,t+30)+Im(e,t+32),u]},Fm=function(e,t){for(;1!=Im(e,t);t+=4+Im(e,t+2));return[Om(e,t+12),Om(e,t+4),Om(e,t+20)]};function _m(e,t){for(var n={},r=e.length-22;101010256!=wm(e,r);--r)(!r||e.length-r>65558)&&Cm(13);var o=Im(e,r+8);if(!o)return{};var a=wm(e,r+16),i=4294967295==a;i&&(r=wm(e,r-12),101075792!=wm(e,r)&&Cm(13),o=wm(e,r+32),a=wm(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=Nm(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Bm(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Pm(e.subarray(h,h+d),new Zg(p)):Cm(14,"unknown compression type "+u):n[f]=bm(e,h,h+d))}return n}function km(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var Gm=km(),Um=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:zm,vtkDebugMacro:Wm}=Wt;let Hm=0;function jm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const Km={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=jm("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Hm&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Lm(Em(new Uint8Array(n.buffer))):n.buffer=Em(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Gm!==n.ref.encode&&Gm&&(Wm(`Swap bytes of ${n.name}`),Um(n.buffer,ls[n.dataType])),n.values=Wt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&zm(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Hm&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=jm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Hm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Hm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(Lm(Em(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(zm("Supported algorithms are: [gz]"),zm(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=jm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Hm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Hm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(Lm(Em(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(zm("Supported algorithms are: [gz]"),zm(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=jm("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(Em(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};Xg("http",(e=>Km));const{vtkDebugMacro:$m}=Wt,qm={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,modelTransformMatrix:null,cameraLightTransform:u(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Xm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qm,n),Wt.obj(e,t),Wt.get(e,t,["distance"]),Wt.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),Wt.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),Wt.setGetArray(e,t,["clippingRange","windowCenter"],2),Wt.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),function(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=m(new Float64Array(16)),i=m(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=m(new Float64Array(16)),d=m(new Float64Array(16)),f=new Float64Array(3),g=new Float64Array(3);function T(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,$m("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,$m("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,T()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);m(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);S(u,u,vo(n),s),La(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;m(d),x(d,d,r),S(d,d,vo(n),t.viewUp),x(d,d,[-r[0],-r[1],-r[2]]),In(f,t.position,d),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;m(d),x(d,d,r),S(d,d,vo(n),t.viewUp),x(d,d,[-r[0],-r[1],-r[2]]),In(g,t.focalPoint,d),e.setFocalPoint(g[0],g[1],g[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];m(d),x(d,d,r),S(d,d,vo(n),a),x(d,d,[-r[0],-r[1],-r[2]]),In(f,t.position,d),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];m(d),x(d,d,r),S(d,d,vo(n),a),x(d,d,[-r[0],-r[1],-r[2]]),In(g,t.focalPoint,d),e.setFocalPoint(...g)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Ro(t.position,a,t.position),Ro(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],La(o,[...t.position,1],n),La(a,[...t.focalPoint,1],n),La(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,$m("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,$m("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Float64Array(24);const r=[[1,0,0,1],[-1,0,0,1],[0,1,0,1],[0,-1,0,1],[0,0,1,1],[0,0,-1,1]],o=e.getCompositeProjectionMatrix(t,-1,1);for(let e=0;e<6;e++)La(r[e],r[e],o),_o(r[e]),n[4*e+0]=r[e][0],n[4*e+1]=r[e][1],n[4*e+2]=r[e][2],n[4*e+3]=r[e][3];return n},e.getCameraLightTransformMatrix=e=>(p(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{p(a,e.getViewMatrix()),v(a,a),P(i,[t.distance,t.distance,t.distance]),b(a,a,i),m(t.cameraLightTransform),x(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=_a(e[0],e[1],e[2],e[3]),n=Ba(),r=_a(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],Fa(r,t,r),Fa(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),v(t,t)},e.getWorldToPhysicalMatrix=e=>{m(e);const n=[3];Bo(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],h(e,e),hn(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),C(e,e,s),x(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{v(a,i),In(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),In(l,r,a),Tn(l,l,s),Cn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),In(c,o,a),Tn(c,c,s),Cn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),b(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setModelTransformMatrix=e=>{t.modelTransformMatrix=e},e.getModelTransformMatrix=()=>t.modelTransformMatrix,e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(p(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),h(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.modelTransformMatrix?(b(a,t.viewMatrix,t.modelTransformMatrix),a):t.viewMatrix;X(a,t.position,t.focalPoint,t.viewUp),h(a,a);const e=new Float64Array(16);return t.modelTransformMatrix?b(e,a,t.modelTransformMatrix):p(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(m(o),t.projectionMatrix){const e=1/t.physicalScale;return hn(s,e,e,e),p(o,t.projectionMatrix),C(o,o,s),h(o,o),o}m(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;$(a,o,i,s,c,l[0],l[1]),h(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(vo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return p(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return b(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,T()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Bo(t.physicalViewNorth,t.physicalViewUp,i);const s=m(new Float64Array(16));S(s,s,vo(n),t.physicalViewUp),S(s,s,vo(r),i),S(s,s,vo(o),t.physicalViewNorth),S(s,s,vo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);In(l,l,s),In(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=m(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=vo(t),i=Ba();Na(i,[n,r,o],e),G(a,i)}const i=new Float64Array(3);In(i,[0,0,-1],a);const s=new Float64Array(3);In(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}(e,t)}var Ym={newInstance:Wt.newInstance(Xm,"vtkCamera"),extend:Xm};const Zm={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Qm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zm,n),Wt.obj(e,t),Wt.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),Wt.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),function(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?In(n,t.position,t.transformMatrix):hn(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?In(n,t.focalPoint,t.transformMatrix):hn(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(Rn(t.direction,t.focalPoint,t.position),Fo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);Rn(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=vo(t),o=vo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}(e,t)}var Jm={newInstance:Wt.newInstance(Qm,"vtkLight"),extend:Qm,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:eh}=Wt;const th={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function nh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,th,n),Wt.obj(e,t),Wt.event(e,t,"event"),Wt.setGetArray(e,t,["viewport"],4),Wt.setGetArray(e,t,["background","background2"],3),function(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{let r=[];const o=e.getActors2D();o.sort(((e,t)=>e.getLayerNumber()-t.getLayerNumber()));const a=t.props.filter((e=>!o.includes(e)));for(let e=0;e<a.length;e++)n(a[e],r);return r=r.concat(o),r},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>eh("call displayToView on your view instead"),e.viewToDisplay=()=>eh("callviewtodisplay on your view instead"),e.getSize=()=>eh("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=()=>eh("vtkViewport::PickPropFrom - NOT IMPLEMENTED")}(e,t)}var rh={newInstance:Wt.newInstance(nh,"vtkViewport"),extend:nh};const{vtkDebugMacro:oh,vtkErrorMacro:ah,vtkWarningMacro:ih}=Ht;function sh(e){return()=>ah(`vtkRenderer::${e} - NOT IMPLEMENTED`)}const lh={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Pa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function ch(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,lh,n),rh.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),Tt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),Ct(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),St(e,t,["actors","volumes","lights"]),It(e,t,["background"],4,1),wt(0,t,["renderWindow"]),function(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(oh("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(u())):ah("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=sh("allocateTime"),e.updateGeometry=sh("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{oh(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=Ym.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Jm.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return ah("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();v(o,o),h(o,o);const a=new Float64Array([e,n,r]);return In(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return ah("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);v(a,a),h(a,a);const i=new Float64Array([e,n,r]);return In(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return ah("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o);const a=new Float64Array([e,n,r]);return In(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return ah("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a);const i=new Float64Array([e,n,r]);return In(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Gi.INIT_BOUNDS[0],t.allBounds[1]=Gi.INIT_BOUNDS[1],t.allBounds[2]=Gi.INIT_BOUNDS[2],t.allBounds[3]=Gi.INIT_BOUNDS[3],t.allBounds[4]=Gi.INIT_BOUNDS[4],t.allBounds[5]=Gi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&ya(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Ta(t.allBounds),oh("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds(),r=[0,0,0];if(!ya(n))return oh("Cannot reset camera!"),!1;let a=null;if(!e.getActiveCamera())return ah("Trying to reset non-existent camera"),!1;a=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),r[0]=(n[0]+n[1])/2,r[1]=(n[2]+n[3])/2,r[2]=(n[4]+n[5])/2;let i=n[1]-n[0],s=n[3]-n[2],l=n[5]-n[4];i*=i,s*=s,l*=l;let c=i+s+l;c=0===c?1:c,c=.5*Math.sqrt(c);const u=vo(t.activeCamera.getViewAngle()),d=c,p=c/Math.sin(.5*u),f=t.activeCamera.getViewUp();return Math.abs(Lo(f,a))>.999&&(ih("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-f[2],f[0],f[1])),t.activeCamera.setFocalPoint(r[0],r[1],r[2]),t.activeCamera.setPosition(r[0]+p*a[0],r[1]+p*a[1],r[2]+p*a[2]),e.resetCameraClippingRange(n),t.activeCamera.setParallelScale(d),t.activeCamera.setPhysicalScale(c),t.activeCamera.setPhysicalTranslation(-r[0],-r[1],-r[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds();if(!ya(n))return oh("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return ah("Trying to reset clipping range of non-existent camera"),!1;const o=t.activeCamera.computeClippingRange(n);let a=0;if(t.activeCamera.getParallelProjection())a=.2*t.activeCamera.getParallelScale();else{const e=vo(t.activeCamera.getViewAngle());a=.2*Math.tan(e/2)*o[1]}return o[1]-o[0]<a&&(a=a-o[1]+o[0],o[1]+=a/2,o[0]-=a/2),o[0]<0&&(o[0]=0),o[0]=.99*o[0]-(o[1]-o[0])*t.clippingRangeExpansion,o[1]=1.01*o[1]+(o[1]-o[0])*t.clippingRangeExpansion,o[0]=o[0]>=o[1]?.01*o[1]:o[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),o[0]<t.nearClippingPlaneTolerance*o[1]&&(o[0]=t.nearClippingPlaneTolerance*o[1]),t.activeCamera.setClippingRange(o[0],o[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}(e,t)}var uh={newInstance:Mt(ch,"vtkRenderer"),extend:ch};const dh=Object.create(null);function ph(e,t){dh[e]=t}function fh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dh[e]&&dh[e](t)}const gh={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function mh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gh,n),Wt.obj(e,t),Wt.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),Wt.get(e,t,["neverRendered"]),Wt.getArray(e,t,["renderers","childRenderWindows"]),Wt.moveToProtected(e,t,["views"]),Wt.event(e,t,"completion"),function(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return fh(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Wt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}(e,t)}var hh={newInstance:Wt.newInstance(mh,"vtkRenderWindow"),extend:mh,registerViewConstructor:ph,listViewAPIs:function(){return Object.keys(dh)},newAPISpecificView:fh};const vh={Unknown:0,LeftController:1,RightController:2},Th={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var yh={Device:vh,Input:Th,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4},MouseButton:{LeftButton:1,MiddleButton:2,RightButton:3}};const{Device:bh,Input:xh}=yh,{vtkWarningMacro:Ch,vtkErrorMacro:Sh,normalizeWheel:Ah,vtkOnceErrorMacro:Ih}=Wt,wh={ctrlKey:!1,altKey:!1,shiftKey:!1},Oh={"xr-standard":[xh.Trigger,xh.Grip,xh.TrackPad,xh.Thumbstick,xh.A,xh.B]},Ph=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Rh(e){e.cancelable&&e.preventDefault()}function Mh(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}const Eh={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Vh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Eh,n),Wt.obj(e,t),t._animationExtendedEnd=0,Wt.event(e,t,"RenderEvent"),Ph.forEach((n=>Wt.event(e,t,n))),Wt.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),Wt.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),Wt.moveToProtected(e,t,["view"]),function(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Sh("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Ch("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0,movementX:a*e.movementX,movementY:s*e.movementY};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Rh),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),n.addEventListener("keypress",e.handleKeyPress),n.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.tabIndex=0,n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Rh),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel),n.removeEventListener("keypress",e.handleKeyPress),n.removeEventListener("keydown",e.handleKeyDown)),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Rh(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Ch("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Rh(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Sh(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Ch("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Sh("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Ch(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?bh.LeftController:bh.RightController,input:Oh[s.mapping]&&Oh[s.mapping][r]?Oh[s.mapping][r]:xh.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?bh.LeftController:bh.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Rh(n);const r={...Ah(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Sh(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Mh(o);if(2===r.length){const t={...l(wh),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(wh),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Mh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(wh),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(wh),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=Mh(o);e.recognizeGesture("TouchEnd",t);const a={...l(wh),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=Mh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(wh),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Ph.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void Ih("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=To(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=To(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}(e,t)}var Dh={newInstance:Wt.newInstance(Vh,"vtkRenderWindowInteractor"),extend:Vh,handledEvents:Ph,...yh};const{vtkErrorMacro:Lh,VOID:Bh}=Wt,Nh={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nh,n),Wt.obj(e,t),Wt.event(e,t,"InteractionEvent"),Wt.event(e,t,"StartInteractionEvent"),Wt.event(e,t,"EndInteractionEvent"),Wt.get(e,t,["_interactor","enabled"]),Wt.setGet(e,t,["priority","processEvents"]),Wt.moveToProtected(e,t,["interactor"]),function(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Dh.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):Bh),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Lh("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}(e,t)}var _h={newInstance:Wt.newInstance(Fh,"vtkInteractorObserver"),extend:Fh,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},kh={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Gh}=kh,Uh={Rotate:Gh.IS_ROTATE,Pan:Gh.IS_PAN,Spin:Gh.IS_SPIN,Dolly:Gh.IS_DOLLY,CameraPose:Gh.IS_CAMERA_POSE,WindowLevel:Gh.IS_WINDOW_LEVEL,Slice:Gh.IS_SLICE},zh={state:Gh.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zh,n),_h.extend(e,t,n),Wt.setGet(e,t,["focusedRenderer"]),function(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(Uh).forEach((n=>{Wt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Gh.IS_NONE&&(t.state=Uh[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},Wt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Uh[n]&&(t.state=Gh.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}(e,t)}var Hh={newInstance:Wt.newInstance(Wh,"vtkInteractorStyle"),extend:Wh,...kh};const{States:jh}=kh,Kh={motionFactor:10,zoomFactor:10};function $h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kh,n),Hh.extend(e,t,n),Wt.setGet(e,t,["motionFactor","zoomFactor"]),function(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case jh.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case jh.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case jh.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case jh.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==vh.RightController||n.input!==Th.Trigger&&n.input!==Th.TrackPad?!n||n.pressed||n.device!==vh.RightController||n.input!==Th.Trigger&&n.input!==Th.TrackPad||t.state!==jh.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===jh.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case jh.IS_DOLLY:e.endDolly();break;case jh.IS_PAN:e.endPan();break;case jh.IS_SPIN:e.endSpin();break;case jh.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=To(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=To(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}(e,t)}var qh={newInstance:Wt.newInstance($h,"vtkInteractorStyleTrackballCamera"),extend:$h};function Xh(e){return e}function Yh(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>Yh(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Zh=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Yh:Xh;return new URLSearchParams(t).forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};const Qh={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function Jh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qh,n),Wt.obj(e,t),Wt.get(e,t,["currentOperation"]),Wt.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),Wt.moveToProtected(e,t,["currentParent"]),function(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${Wt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}(e,t)}var ev={newInstance:Wt.newInstance(Jh,"vtkRenderPass"),extend:Jh};const{Representation:tv}=os,{vtkErrorMacro:nv}=Wt;function rv(e){const t=td.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}const ov={framebuffer:null,copyShader:null,tris:null};function av(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ov,n),ev.extend(e,t,n),t.VBOBuildTime={},Wt.obj(t.VBOBuildTime,{mtime:0}),t.tris=ld.newInstance(),Wt.get(e,t,["framebuffer"]),function(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=xs.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=xs.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=xs.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",tv.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Sp.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Pd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw({width:n[0],height:n[1],numComps:4,dataType:"Float32Array",data:null}),t.translucentRTexture=Pd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw({width:n[0],height:n[1],numComps:1,dataType:"Float32Array",data:null}),t.translucentZTexture=Pd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw({width:n[0],height:n[1],dataType:"Float32Array",data:null}),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||nv("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||nv("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=od.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?rv:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}(e,t)}var iv={newInstance:Wt.newInstance(av,"vtkOpenGLOrderIndependentTranslucentPass"),extend:av};const sv={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sv,n),ev.extend(e,t,n),Wt.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Sp.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=iv.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}(e,t)}var cv={newInstance:Wt.newInstance(lv,"vtkForwardPass"),extend:lv},uv=n(292);const dv=["lastShaderProgramBound","context","_openGLRenderWindow"],pv={lastShaderProgramBound:null,shaderPrograms:null,context:null};function fv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pv,n),t.shaderPrograms={},Wt.obj(e,t),Wt.setGet(e,t,dv),Wt.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=td.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=td.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=td.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=td.substitute(l,"varying","out").result,o=td.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=td.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=td.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:td.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=uv.hash(o);if(!(a in t.shaderPrograms)){const o=td.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}(e,t)}var gv={newInstance:Wt.newInstance(fv,"vtkShaderCache"),extend:fv};const{vtkErrorMacro:mv}=Wt,hv={context:null,numberOfTextureUnits:0,textureUnits:0};function vv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hv,n),Wt.obj(e,t),t.textureUnits=[],Wt.get(e,t,["numberOfTextureUnits"]),Wt.setGet(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&mv("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}(e,t)}var Tv={newInstance:Wt.newInstance(vv,"vtkOpenGLTextureUnitManager"),extend:vv};const yv={size:void 0,selector:void 0};function bv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yv,n),t.size||(t.size=[300,300]),Wt.getArray(e,t,["size"],2),Wt.get(e,t,["selector"]),qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{Wt.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{Wt.vtkErrorMacro("not implemented")},e.createSelector=()=>{Wt.vtkErrorMacro("not implemented")}}(e,t)}var xv={newInstance:Wt.newInstance(bv,"vtkRenderWindowViewNode"),extend:bv};const{vtkDebugMacro:Cv,vtkErrorMacro:Sv}=Wt,Av={position:"absolute",top:0,left:0,width:"100%",height:"100%"},Iv=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function wv(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let Ov=0;const Pv=[];function Rv(e){e.preventDefault()}function Mv(e,t){let n;t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",Rv,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(Ov++,Pv.forEach((e=>e(Ov)))),t.textureUnitManager=Tv.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Sv("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},r=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext("webgl2",e),r&&(t.webgl2=!0,Cv("using webgl2"))),r||(Cv("using webgl1"),r=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(r,(n||(n=function(){const e=new Map,t={apply(t,n,r){return e.has(r[0])?e.get(r[0]):t.apply(n,r)}},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply(t,n,r){return e.set(a,r[0]),t.apply(n,r)}}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n))},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=ev.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Sv("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case cs.CHAR:case cs.SIGNED_CHAR:case cs.UNSIGNED_CHAR:return 1;case n:case r:case cs.UNSIGNED_SHORT:case cs.SHORT:case cs.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case cs.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&cs.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&cs.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Av,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&wv(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&wv(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&wv(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&wv(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&wv(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&wv(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&wv(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&wv(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&wv(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&wv(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&wv(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&wv(n,n.RGB,n.FLOAT)?"RGB":"",r&&wv(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&wv(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&wv(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const i=r.toDataURL(n);r.remove(),e.invokeImageReady(i)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=Gp.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=Wt.chain((()=>{t.context&&(Ov--,Pv.forEach((e=>e(Ov)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",Rv),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null);const o=t._graphicsResources.get(n);o?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{const n=e.getViewNodeFor(t);n?.releaseGraphicsResources()}))};const i={...e};Iv.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):i[n](...arguments)}}))}const Ev={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const Vv=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ev,n),xv.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=Gp.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=nn.newInstance(),t.shaderCache=gv.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=cv.newInstance(),Wt.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),Wt.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),Wt.setGetArray(e,t,["size"],2),Wt.event(e,t,"imageReady"),Wt.event(e,t,"windowResizeEvent"),Mv(e,t)}),"vtkOpenGLRenderWindow");ph("WebGL",Vv),Jt("vtkRenderWindow",Vv);const Dv={device:null,handle:null};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dv,n),Wt.obj(e,t),Wt.get(e,t,["lastCameraMTime"]),Wt.setGet(e,t,["device","handle"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}(e,t)}var Bv={newInstance:Wt.newInstance(Lv,"vtkWebGPUShaderModule"),extend:Lv};const Nv={shaderModules:null,device:null,window:null};function Fv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nv,n),t._shaderModules=new Map,Wt.obj(e,t),Wt.setGet(e,t,["device","window"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=Bv.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}(e,t)}var _v={newInstance:Wt.newInstance(Fv,"vtkWebGPUShaderCache"),extend:Fv,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i);return{replace:a,result:e.replace(s,o)}}};const kv={device:null,handle:null,label:null};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Wt.obj(e,t),t.bindables=[],t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),Wt.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),Wt.setGet(e,t,["label","device","arrayInformation"]),function(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}(e,t)}var Uv={newInstance:Wt.newInstance(Gv),extend:Gv};const zv={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function Wv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zv,n),ht(e,t),t.layouts=[],t.shaderDescriptions=[],Tt(e,t,["handle","pipelineDescription"]),Ct(e,t,["device","renderEncoder","topology","vertexState"]),function(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}(e,t)}var Hv={newInstance:Mt(Wv,"vtkWebGPUPipeline"),extend:Wv};const jv={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function Kv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jv,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],Wt.obj(e,t),Wt.setGet(e,t,["type","hash","code"]),Wt.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=_v.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=_v.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=_v.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}(e,t)}var $v={newInstance:Wt.newInstance(Kv,"vtkWebGPUShaderDescription"),extend:Kv};const qv={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var Xv=function(e){return!e||e.length<6?0:e in qv==1?qv[e]:(et(`unknown format ${e}`),null)},Yv=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},Zv=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void et(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;et(`unknown format ${e}`)},Qv=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void et(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},Jv=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},eT=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void et(`unknown format ${e}`)};function tT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}const nT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function rT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nT,n),ht(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],Ct(e,t,["created","device","handle","indexBuffer"]),function(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(tT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=Qv(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}(e,t)}var oT={newInstance:Mt(rT,"vtkWebGPUVertexInput"),extend:rT};const aT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function iT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,aT,n),qt.extend(e,t,n),t.textureViews=[],t.vertexInput=oT.newInstance(),t.bindGroup=Uv.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n",t.vertexShaderTemplate=t.vertexShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",t.shaderReplacements=new Map,Wt.get(e,t,["pipeline","vertexInput"]),Wt.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),function(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=$v.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=$v.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=_v.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=_v.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=_v.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=_v.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=_v.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=Hv.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}(e,t)}var sT={newInstance:Wt.newInstance(iT,"vtkWebGPUSimpleMapper"),extend:iT};const lT={};function cT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lT,n),sT.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=_v.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}(e,t)}var uT={newInstance:Wt.newInstance(cT,"vtkWebGPUFullScreenQuad"),extend:cT};const dT=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"],pT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function fT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pT,n),ht(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=_v.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],Tt(e,t,["boundPipeline","colorTextureViews"]),Ct(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),function(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<dT.length;n++)e[dT[n]]=function(){return t.handle[dT[n]](...arguments)}}(e,t)}var gT={newInstance:Mt(fT,"vtkWebGPURenderEncoder"),extend:fT};const mT={device:null,handle:null,label:null,options:null};function hT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mT,n),Wt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),Wt.get(e,t,["bindGroupTime","handle","options"]),Wt.setGet(e,t,["bindGroupLayoutEntry","device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}(e,t)}var vT={newInstance:Wt.newInstance(hT),extend:hT};const TT={texture:null,handle:null,sampler:null,label:null};function yT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TT,n),Wt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),Wt.get(e,t,["bindGroupTime","texture"]),Wt.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),function(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=Xv(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=Xv(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=vT.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}(e,t)}var bT={newInstance:Wt.newInstance(yT),extend:yT};const xT={device:null,handle:null,buffer:null,ready:!1,label:null};function CT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xT,n),Wt.obj(e,t),Wt.get(e,t,["handle","ready","width","height","depth","format","usage"]),Wt.setGet(e,t,["device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];const o=r=>{t.device.getHandle().queue.copyExternalImageToTexture({source:r,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0,mipLevel:0,origin:{x:0,y:0,z:0}},[r.width,r.height,t.depth]),3!==e.getDimensionality()&&t.mipLevel>0&&vu.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0};if(n.canvas)return void o(n.canvas);if(n.imageBitmap)return n.width=n.imageBitmap.width,n.height=n.imageBitmap.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.imageBitmap);if(n.jsImageData)return n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.jsImageData);if(n.image)return n.width=n.image.width,n.height=n.image.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.image);const a=Xv(t.format);let i=t.width*a.stride;n.nativeArray&&(r=n.nativeArray);const s=3===e.getDimensionality(),l=((e,t,n)=>{const r=2===a.elementSize&&"float"===a.sampleType,o=e.BYTES_PER_ELEMENT,i=e.length/(t*n)*o;if(!r&&i%256==0)return[e,i];const s=i/o,l=a.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=Wt.newTypedArray(r?"Uint16Array":e.constructor.name,u*t*n),p=t*n;if(r)for(let t=0;t<p;t++){const n=t*s,r=t*u;for(let t=0;t<s;t++)d[r+t]=gd.toHalf(e[n+t])}else if(u===s)d.set(e);else for(let t=0;t<p;t++)d.set(e.subarray(t*s,(t+1)*s),t*u);return[d,c]})(r,t.height,s?t.depth:1);i=l[1];const c=l[0];t.device.getHandle().queue.writeTexture({texture:t.handle,mipLevel:0,origin:{x:0,y:0,z:0}},c,{offset:0,bytesPerRow:i,rowsPerImage:t.height},{width:t.width,height:t.height,depthOrArrayLayers:s?t.depth:1}),!s&&t.mipLevel>0&&vu.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0},e.getScale=()=>{const e=Xv(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>Xv(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=bT.newInstance({label:n});return o.create(e,r),o}}(e,t)}var ST={newInstance:Wt.newInstance(CT),extend:CT};const AT={renderEncoder:null,colorTexture:null,depthTexture:null};function IT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AT,n),ev.extend(e,t,n),Wt.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=ST.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=ST.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=gT.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}(e,t)}var wT={newInstance:Wt.newInstance(IT,"vtkWebGPUOpaquePass"),extend:IT};const OT={colorTextureView:null,depthTextureView:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OT,n),ev.extend(e,t,n),Wt.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=ST.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=ST.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=uT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=gT.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=_v.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=gT.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=_v.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}(e,t)}var RT={newInstance:Wt.newInstance(PT,"vtkWebGPUOrderIndependentTranslucentPass"),extend:PT},MT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const ET=["getMappedRange","mapAsync","unmap"];const VT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,VT,n),Wt.obj(e,t),Wt.get(e,t,["handle","sizeInBytes","usage"]),Wt.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),function(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{const r=4*Math.ceil(e.byteLength/4);t.handle=t.device.getHandle().createBuffer({size:r,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=r,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<ET.length;n++)e[ET[n]]=function(){return t.handle[ET[n]](...arguments)}}(e,t)}var LT={newInstance:Wt.newInstance(DT),extend:DT,...MT};const{Representation:BT}=os,{PrimitiveTypes:NT}=MT;class FT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function _T(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function kT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=_T(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=_T(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=_T(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=_T(n,o,t),n.ibo[n.iboId++]=a}function GT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let UT;const zT=new Uint32Array(1),WT=new Uint32Array(2),HT=new Uint32Array(3),jT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)zT[0]=t[n+a],UT(zT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)WT[0]=t[n+a],WT[1]=t[n+a+1],UT(WT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)WT[0]=t[n+a],WT[1]=t[n+(a+1)%e],UT(WT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)WT[0]=t[n+a],WT[1]=t[n+a+1],UT(WT,r,o);for(let a=0;a<e-2;a++)WT[0]=t[n+a],WT[1]=t[n+a+2],UT(WT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)HT[0]=t[n],HT[1]=t[n+a+1],HT[2]=t[n+a+2],UT(HT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)HT[0]=t[n+a],HT[1]=t[n+a+1+a%2],HT[2]=t[n+a+1+(a+1)%2],UT(HT,r,o)}};const KT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function $T(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KT,n),LT.extend(e,t,n),Wt.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),function(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case NT.Points:return"points";case NT.Lines:return"lines";case NT.Triangles:case NT.TriangleEdges:return"polys";case NT.TriangleStripEdges:case NT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new FT};let d=null;d=o===BT.POINTS||r===NT.Points?jT.anythingToPoints:o===BT.WIREFRAME||r===NT.Lines?jT[`${l}ToWireframe`]:jT[`${l}ToSurface`],UT=GT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),UT=kT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}(e,t)}var qT={newInstance:Wt.newInstance($T),extend:$T,...MT};const{BufferUsage:XT}=MT,{vtkErrorMacro:YT}=Ht,{VtkDataTypes:ZT}=xs;function QT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function JT(e,t,n,r){const o=[];return Bo([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),Fo(o),o}const ey={device:null,fullScreenQuadBuffer:null};function ty(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ey,n),ht(e,t),Ct(e,t,["device"]),function(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===XT.Index&&(n=qT.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=LT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===XT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===XT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===XT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===XT.PointArray){r=GPUBufferUsage.VERTEX;const t=Zv(e.format),o=QT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(Yv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===XT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=Zv(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=JT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=QT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(Yv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===XT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(Yv(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case ZT.UNSIGNED_CHAR:t="uint8";break;case ZT.FLOAT:t="float32";break;case ZT.UNSIGNED_INT:t="uint32";break;case ZT.INT:t="sint32";break;case ZT.DOUBLE:t="float32";break;case ZT.UNSIGNED_SHORT:t="uint16";break;case ZT.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||YT(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:XT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=LT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}(e,t)}var ny={newInstance:Mt(ty),extend:ty,...MT};const{BufferUsage:ry}=ny,{vtkErrorMacro:oy}=Wt,ay={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function iy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ay,n),Wt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},Wt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,Wt.get(e,t,["binding","bindGroupTime"]),Wt.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?oy(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:Jv(n),offset:-1,nativeType:eT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:ry.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=Wt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void oy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void oy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}(e,t)}var sy={newInstance:Wt.newInstance(iy,"vtkWebGPUUniformBuffer"),extend:iy};const{BufferUsage:ly}=ny,{vtkErrorMacro:cy}=Wt,uy={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uy,n),Wt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},Wt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},Wt.get(e,t,["bindGroupTime"]),Wt.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void cy(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=Jv(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:eT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:ly.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=Wt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void cy(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void cy(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void cy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void cy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void cy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}(e,t)}var py={newInstance:Wt.newInstance(dy,"vtkWebGPUStorageBuffer"),extend:dy};const fy=new Float64Array(16),gy=new Float64Array(16),my={volumes:null,rowLength:1024,lastVolumeLength:0};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),uT.extend(e,t,n),t.fragmentShaderTemplate="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",t.UBO=sy.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=py.newInstance({label:"volumeSSBO"}),t.componentSSBO=py.newInstance({label:"componentSSBO"}),t.lutBuildTime={},Wt.obj(t.lutBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=_v.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===eg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=_v.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=_v.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=_v.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===eg.COMPOSITE_BLEND?l=!0:n===eg.MAXIMUM_INTENSITY_BLEND?a=_v.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===eg.MINIMUM_INTENSITY_BLEND?a=_v.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===eg.AVERAGE_INTENSITY_BLEND?a=_v.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===eg.ADDITIVE_INTENSITY_BLEND&&(a=_v.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=_v.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper().getInputData();m(fy),x(fy,fy,o);const d=n.getMatrix();h(gy,d),v(gy,gy),b(fy,gy,fy);const p=r.getWorldToIndex();b(fy,p,fy);const f=r.getDimensions();m(gy),C(gy,gy,[1/f[0],1/f[1],1/f[2]]),b(fy,gy,fy);for(let t=0;t<16;t++)a[16*e+t]=fy[t];v(fy,fy);for(let t=0;t<4;t++)i[16*e+4*t]=fy[4*t],i[16*e+4*t+1]=fy[4*t+1],i[16*e+4*t+2]=fy[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/f[0],s[4*e+1]=1/f[1],s[4*e+2]=1/f[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const g=r.getSpacing();c[4*e]=g[0],c[4*e+1]=g[1],c[4*e+2]=g[2],c[4*e+3]=1;const T=t.textureViews[e+4].getTexture().getScale(),y=n.getProperty().getIpScalarRange();u[4*e]=y[0]/T,u[4*e+1]=y[1]/T,u[4*e+2]=n.getProperty().getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),g=new Float64Array(t.numRows),T=new Float64Array(t.numRows),y=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=Xv(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);g[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);T[I]=e,y[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else T[I]=1,y[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",g),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",T),t.componentSSBO.setAllInstancesFromArray("gomax",y),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=vT.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}(e,t)}var vy={newInstance:Wt.newInstance(hy,"vtkWebGPUVolumePassFSQ"),extend:hy};const{Representation:Ty}=os,{BufferUsage:yy,PrimitiveTypes:by}=ny,xy=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],Cy={colorTextureView:null,depthTextureView:null,volumes:null};function Sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cy,n),ev.extend(e,t,n),t._mapper=sT.newInstance(),t._mapper.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=gu.newInstance(),t._lastMTimes=[],Wt.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=vy.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=uT.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=sy.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Go(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=Wt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:yy.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:by.Triangles,representation:Ty.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:yy.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+xy[e][0],l[n++]=r+xy[e][1],l[n++]=r+xy[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=gT.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=_v.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcFactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcFactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=ST.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=ST.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=ST.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=gT.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=gT.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=gT.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=_v.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}(e,t)}var Ay={newInstance:Wt.newInstance(Sy,"vtkWebGPUVolumePass"),extend:Sy};const Iy={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function wy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Iy,n),ev.extend(e,t,n),Wt.setGet(e,t,["opaquePass","translucentPass","volumePass"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=wT.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=RT.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=Ay.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=gT.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=vT.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=uT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=bT.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}(e,t)}var Oy={newInstance:Wt.newInstance(wy,"vtkForwardPass"),extend:wy};const{VtkDataTypes:Py}=xs,Ry={handle:null,device:null};function My(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ry,n),Wt.obj(e,t),Wt.setGet(e,t,["device"]),function(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case Py.UNSIGNED_CHAR:e.format+="8unorm";break;case Py.FLOAT:case Py.UNSIGNED_INT:case Py.INT:case Py.DOUBLE:case Py.UNSIGNED_SHORT:case Py.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.imageBitmap&&(e.width=e.imageBitmap.width,e.height=e.imageBitmap.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=ST.newInstance({label:e.label});return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas||e.imageBitmap)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;const o={time:e.getMTime(),label:r};return e.getInputData()?o.imageData=e.getInputData():e.getImage()?o.image=e.getImage():e.getJsImageData()?o.jsImageData=e.getJsImageData():e.getImageBitmap()?o.imageBitmap=e.getImageBitmap():e.getCanvas()&&(o.canvas=e.getCanvas()),n(o),o.mipLevel=e.getMipLevel(),o.hash=o.time+o.format+o.mipLevel,t.device.getTextureManager().getTexture(o)}}(e,t)}var Ey={newInstance:Wt.newInstance(My),extend:My};class Vy extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}const Dy={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function Ly(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dy,n),ht(e,t),Ct(e,t,["handle"]),Tt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new Vy,t.shaderCache=_v.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=ny.newInstance(),t.bufferManager.setDevice(e),t.textureManager=Ey.newInstance(),t.textureManager.setDevice(e),t.pipelines={},function(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}(e,t)}var By={newInstance:Mt(Ly,"vtkWebGPUDevice"),extend:Ly};const Ny={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function Fy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ny,n),ev.extend(e,t,n),Wt.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=ST.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=ST.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=gT.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=_v.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}(e,t)}var _y={newInstance:Wt.newInstance(Fy,"vtkWebGPUHardwareSelectionPass"),extend:Fy};const{SelectionContent:ky,SelectionField:Gy}=wp,{FieldAssociations:Uy}=Us,{vtkErrorMacro:zy}=Wt;function Wy(e){return`${e.propID} ${e.compositeID}`}function Hy(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function jy(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=Hy(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=Hy(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=jy(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=jy(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=jy(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=jy(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=jy(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}const Ky={};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),bp.extend(e,t,n),t._selectionPass=_y.newInstance(),Wt.setGet(e,t,["_WebGPURenderWindow"]),Wt.moveToProtected(e,t,["WebGPURenderWindow"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return zy("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=LT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=LT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=jy(e,[n,t],0,u);if(r){const t=Wy(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=wp.newInstance();switch(i.setContentType(ky.INDICES),e){case Uy.FIELD_ASSOCIATION_CELLS:i.setFieldType(Gy.CELL);break;case Uy.FIELD_ASSOCIATION_POINTS:i.setFieldType(Gy.POINT);break;default:zy("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}(e,t)}var qy={newInstance:Wt.newInstance($y,"vtkWebGPUHardwareSelector"),extend:$y};const Xy=Object.create(null),Yy={};function Zy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yy,n),t.overrides=Xy,Zt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}(0,t)}var Qy={newInstance:Wt.newInstance(Zy,"vtkWebGPUViewNodeFactory"),extend:Zy};const{vtkErrorMacro:Jy}=Wt,eb={position:"absolute",top:0,left:0,width:"100%",height:"100%"};const tb={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const nb=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tb,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",xv.extend(e,t,n),t.myFactory=Qy.newInstance(),t.renderPasses[0]=Oy.newInstance(),t.selector||(t.selector=qy.newInstance(),t.selector.setWebGPURenderWindow(e)),Wt.event(e,t,"imageReady"),Wt.event(e,t,"initialized"),Wt.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),Wt.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),Wt.setGetArray(e,t,["size"],2),Wt.event(e,t,"windowResizeEvent"),function(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Jy("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Jy("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=By.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=ev.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=eb,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const l=r.toDataURL(n);r.remove(),e.invokeImageReady(l)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=LT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*gd.fromHalf(r.colorValues[o]),s[n+1]=255*gd.fromHalf(r.colorValues[o+1]),s[n+2]=255*gd.fromHalf(r.colorValues[o+2]),s[n+3]=255*gd.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=qy.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=Wt.chain(e.delete,e.setViewStream)}(e,t)}),"vtkWebGPURenderWindow");var rb;ph("WebGPU",nb),rb=nb,Xy.vtkRenderWindow=rb;const ob=Zh(),ab={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},ib={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function sb(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}const lb={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lb,n),Wt.obj(e,t),Wt.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),function(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),sb(t.container,t.containerStyle||ab),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=hh.newInstance(),t.renderer=uh.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(ob.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Dh.newInstance(),t.interactor.setInteractorStyle(qh.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),sb(t.controlContainer,t.controlPanelStyle||ib),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=Wt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}(e,t)}var ub={newInstance:Wt.newInstance(cb),extend:cb},db={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:pb,Scale:fb}=db,{ScalarMappingTarget:gb}=cl,{vtkDebugMacro:mb,vtkErrorMacro:hb,vtkWarningMacro:vb}=Wt;function Tb(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function yb(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function bb(e,t,n,r){const o=[],a=[];ha(t,o),ha(n,a);const i=[],s=[];Tb(o,i),Tb(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=yb(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=yb(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),va(u,r)}const xb={clamping:!0,colorSpace:pb.RGB,hSVWrap:!0,scale:fb.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xb,n),cl.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},Wt.obj(t.buildTime),Wt.get(e,t,["buildTime","mappingRange"]),Wt.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:pb},{type:"enum",name:"scale",enum:fb}]),Wt.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Wt.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return hb("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return hb("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[];return da([n,r,o],s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];da([n,r,o],u),da(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.logScaleEnabled=()=>t.scale===fb.LOG10,e.usingLogScale=()=>e.logScaleEnabled()&&t.mappingRange[0]>0,e.getTable=(n,r,o,a)=>{const i=e.usingLogScale(),s=i?Math.log10(Number(n)):Number(n),l=i?Math.log10(Number(r)):Number(r);if(Oa(s)||Oa(l)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let c=0;const u=t.nodes.length;let d=0,p=0,f=0;0!==u&&(d=t.nodes[u-1].r,p=t.nodes[u-1].g,f=t.nodes[u-1].b);let g=0,m=0,h=0;const v=[0,0,0],T=[0,0,0];let y=0,b=0;const x=[];let C=t.mappingRange;i&&(C=[Math.log10(t.mappingRange[0]),Math.log10(t.mappingRange[1])]);for(let n=0;n<o;n++){const r=3*n;if(g=o>1?s+n/(o-1)*(l-s):.5*(s+l),t.discretize){const e=C;if(g>=e[0]&&g<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)g=e[0]+r/2;else{const t=(g-e[0])/r,o=bo(n*t);g=e[0]+o/(n-1)*r}}}for(;c<u&&g>t.nodes[c].x;)c++,c<u&&(m=t.nodes[c-1].x,h=t.nodes[c].x,v[0]=t.nodes[c-1].r,T[0]=t.nodes[c].r,v[1]=t.nodes[c-1].g,T[1]=t.nodes[c].g,v[2]=t.nodes[c-1].b,T[2]=t.nodes[c].b,y=t.nodes[c-1].midpoint,b=t.nodes[c-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(g>C[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=d,a[r+1]=p,a[r+2]=f));else if(g<C[0]||Aa(g)&&g<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):u>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===c&&(Math.abs(g-s)<1e-6||t.discretize))u>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=(g-m)/(h-m),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),b>.99){if(e<.5){a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}a[r]=T[0],a[r+1]=T[1],a[r+2]=T[2];continue}if(b<.01){if(t.colorSpace===pb.RGB)a[r]=(1-e)*v[0]+e*T[0],a[r+1]=(1-e)*v[1]+e*T[1],a[r+2]=(1-e)*v[2]+e*T[2];else if(t.colorSpace===pb.HSV){const n=[],o=[];ua(v,n),ua(T,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],da(i,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===pb.LAB){const t=[],n=[];ha(v,t),ha(T,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],va(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===pb.DIVERGING?(bb(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):hb("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*b):e>.5&&(e=1-.5*(2*(1-e))**(1+10*b));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===pb.RGB)for(let e=0;e<3;e++)u=T[e]-v[e],d=(1-b)*u,a[r+e]=i*v[e]+s*T[e]+l*d+c*d;else if(t.colorSpace===pb.HSV){const e=[],n=[];ua(v,e),ua(T,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-b)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);da(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===pb.LAB){const e=[],t=[];ha(v,e),ha(T,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-b)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;va(n,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===pb.DIVERGING?(bb(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):hb("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return hb("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(hb("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return hb("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=[n,r],i=e.getRange(),s=e.logScaleEnabled();if(i[1]===o[1]&&i[0]===o[0])return;if(o[1]===o[0])return void hb("attempt to set zero width color range");s&&(o[0]<=0?console.warn("attempt to set log scale color range with non-positive minimum"):(a[0]=Math.log10(o[0]),a[1]=Math.log10(o[1])));const l=(a[1]-a[0])/(i[1]-i[0]),c=a[0]-i[0]*l;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*l+c;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):mb("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void vb("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===gb.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===gb.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===gb.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===gb.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=pb[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(hb(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=pb.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}(e,t)}var Sb={newInstance:Wt.newInstance(Cb,"vtkColorTransferFunction"),extend:Cb,...db},Ab={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:Ib,ScaleModes:wb}=Ab,{vtkErrorMacro:Ob}=Wt,Pb={orient:!0,orientationMode:Ib.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:wb.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function Rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),Gl.extend(e,t,n),Wt.algo(e,t,2,0),t.buildTime={},Wt.obj(t.buildTime,{mtime:0}),t.boundsTime={},Wt.obj(t.boundsTime,{mtime:0}),Wt.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),Wt.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),function(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>Wt.enumToString(Ib,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(Ib.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(Ib.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(Ib.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>Wt.enumToString(wb,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(wb.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(wb.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(wb.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Pa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===wb.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(Ob("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Gi.getCorners(l,c),t.bounds[0]=Gi.INIT_BOUNDS[0],t.bounds[1]=Gi.INIT_BOUNDS[1],t.bounds[2]=Gi.INIT_BOUNDS[2],t.bounds[3]=Gi.INIT_BOUNDS[3],t.bounds[4]=Gi.INIT_BOUNDS[4],t.bounds[5]=Gi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=m(new Float64Array(16)),f=[],g=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const T=t.normalArray.buffer,y=[],O=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],x(n,p,f),d)switch(d.getTuple(e,O),t.orientationMode){case Ib.MATRIX:b(n,n,[...O.slice(0,3),0,...O.slice(3,6),0,...O.slice(6,9),0,0,0,0,1]);break;case Ib.ROTATION:w(n,n,O[2]),A(n,n,O[0]),I(n,n,O[1]);break;case Ib.DIRECTION:if(0===O[1]&&0===O[2])O[0]<0&&I(n,n,3.1415926);else{const e=No(O),t=[];t[0]=(O[0]+e)/2,t[1]=O[1]/2,t[2]=O[2]/2,S(n,n,3.1415926,t)}}if(t.scaling){if(g[0]=t.scaleFactor,g[1]=t.scaleFactor,g[2]=t.scaleFactor,a)switch(t.scaleMode){case wb.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)y[t]=i[e*s+t];g[0]*=No(y,s),g[1]=g[0],g[2]=g[0];break;case wb.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)y[t]=i[e*s+t];g[0]*=y[0],g[1]*=y[1],g[2]*=y[2];case wb.SCALE_BY_CONSTANT:}0===g[0]&&(g[0]=1e-10),0===g[1]&&(g[1]=1e-10),0===g[2]&&(g[2]=1e-10),C(n,n,g)}for(let e=0;e<8;++e)In(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(T,36*e,9);le(r,n),me(r,r),ge(r,r)}const P=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&P&&(R.build(),t.colorArray=R.mapScalars(P,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}(e,t)}var Mb={newInstance:Wt.newInstance(Rb,"vtkGlyph3DMapper"),extend:Rb,...Ab};const{vtkErrorMacro:Eb}=Wt,Vb={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function Db(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vb,n),Wt.obj(e,t),t.nodes=[],Wt.setGet(e,t,["allowDuplicateScalars","clamping"]),Wt.setArray(e,t,["range"],2),Wt.getArray(e,t,["range"]),function(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(Eb("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return Eb("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return Eb("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return Eb("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,T=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>T?T:o[v]}}}}(e,t)}var Lb={newInstance:Wt.newInstance(Db,"vtkPiecewiseFunction"),extend:Db};const{InterpolationType:Bb,OpacityMode:Nb,FilterMode:Fb,ColorMixPreset:_b}=Jf,{vtkErrorMacro:kb}=Wt;function Gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({colorMixPreset:_b.DEFAULT,independentComponents:!0,interpolationType:Bb.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,ipScalarRange:[-1e6,1e6],filterMode:Fb.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7,updatedExtents:[],...e}))(n)),Wt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:Nb.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}Wt.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius","updatedExtents"]),Wt.setGetArray(e,t,["ipScalarRange"],2),Wt.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkVolumeProperty");const n={...e};e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(kb("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=Lb.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=Sb.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=Lb.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return kb("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(kb("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(Bb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(Bb.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(Bb.FAST_LINEAR),e.getInterpolationTypeAsString=()=>Wt.enumToString(Bb,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Wt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Wt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]})),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>Wt.enumToString(Fb,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(Fb.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(Fb.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(Fb.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(ba(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(ba(e,0,1)),e.setAnisotropy=e=>n.setAnisotropy(ba(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(bo(ba(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}(e,t)}var Ub={newInstance:Wt.newInstance(Gb,"vtkVolumeProperty"),extend:Gb,...Jf};const zb={mapper:null};function Wb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zb,n),Xi.extend(e,t,n),t.boundsMTime={},Wt.obj(t.boundsMTime),Wt.setGet(e,t,["mapper"]),function(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>[e],e.makeProperty=Ub.newInstance,e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}(e,t)}var Hb={newInstance:Wt.newInstance(Wb,"vtkVolume"),extend:Wb};const{BlendMode:jb}=tg,Kb=["getAnisotropy","getComputeNormalFromOpacity","getFilterMode","getFilterModeAsString","getGlobalIlluminationReach","getIpScalarRange","getIpScalarRangeByReference","getLAOKernelRadius","getLAOKernelSize","getLocalAmbientOcclusion","getPreferSizeOverAccuracy","getVolumetricScatteringBlending","setAnisotropy","setAverageIPScalarRange","setComputeNormalFromOpacity","setFilterMode","setFilterModeToNormalized","setFilterModeToOff","setFilterModeToRaw","setGlobalIlluminationReach","setIpScalarRange","setIpScalarRangeFrom","setLAOKernelRadius","setLAOKernelSize","setLocalAmbientOcclusion","setPreferSizeOverAccuracy","setVolumetricScatteringBlending"],$b={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=Lb.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Gi.INIT_BOUNDS],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:jb.COMPOSITE_BLEND,volumeShadowSamplingDistFactor:5,colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024,...e}))(n)),As(e,t,n),Wt.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","volumeShadowSamplingDistFactor","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Wt.event(e,t,"lightingActivated"),function(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>(t.static||e.update(),t.bounds=[...e.getInputData().getBounds()],t.bounds),e.setBlendModeToComposite=()=>{e.setBlendMode(jb.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(jb.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(jb.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(jb.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(jb.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(jb.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>Wt.enumToString(jb,t.blendMode),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),Kb.forEach((t=>{e[t]=()=>{throw new Error(`The method "volumeMapper.${t}()" doesn't exist anymore. It is a rendering property that has been moved to the volume property. Replace your code with:\nvolumeActor.getProperty().${t}()\n`)}}))}(e,t)}var Xb={newInstance:Wt.newInstance(qb,"vtkVolumeMapper"),extend:qb,...$b};const{InterpolationType:Yb}=Rf,{vtkErrorMacro:Zb}=Wt;function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({independentComponents:!1,interpolationType:Yb.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,updatedExtents:[],...e}))(n)),Wt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}Wt.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity","updatedExtents"]),Wt.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].rGBTransferFunction!==o&&(t.componentData[r].rGBTransferFunction=o,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].piecewiseFunction!==o&&(t.componentData[r].piecewiseFunction=o,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(t)||(r=t,n=0),e.setPiecewiseFunction(n,r)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return Zb("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(Zb("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(Yb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(Yb.LINEAR),e.getInterpolationTypeAsString=()=>Wt.enumToString(Yb,t.interpolationType)}(e,t)}var Jb={newInstance:Wt.newInstance(Qb,"vtkImageProperty"),extend:Qb};const ex={mapper:null,forceOpaque:!1,forceTranslucent:!1};function tx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ex,n),Xi.extend(e,t,n),t.boundsMTime={},Wt.obj(t.boundsMTime),Wt.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),function(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=Jb.newInstance,e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Gi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return h(a,t.matrix),Gi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return t.properties.forEach((t=>{e=Math.max(e,t.getMTime());const n=t.getRGBTransferFunction();null!==n&&(e=Math.max(e,n.getMTime()))})),e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}(e,t)}var nx={newInstance:Wt.newInstance(tx,"vtkImageSlice"),extend:tx};const rx={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1],colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024};var ox=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rx,n),As(e,t,n),Wt.setGet(e,t,["slice","useCustomExtents","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Wt.setGetArray(e,t,["customDisplayExtent"],6),Wt.setGetArray(e,t,["backgroundColor"],4),function(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(Wt.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Pa())}(e,t)};function ax(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Cn(c,c);const u=ei.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:ix,otherStaticMethods:sx}=Sl,{SlicingMode:lx}=Lf;const cx={slicingMode:lx.NONE,closestIJKAxis:{ijkMode:lx.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cx,n),ox(e,t,n),Wt.get(e,t,["slicingMode"]),Wt.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),Sl.implementCoincidentTopologyMethods(e,t),function(e,t){function n(){let n;switch(t.slicingMode){case lx.X:n=0;break;case lx.Y:n=1;break;case lx.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=Ra(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case lx.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case lx.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case lx.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case lx.I:l=ba(a[0],i[0],i[1]);break;case lx.J:l=ba(a[1],i[2],i[3]);break;case lx.K:l=ba(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case lx.I:case lx.J:case lx.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case lx.X:e.setSlice(r[0]);break;case lx.Y:e.setSlice(r[1]);break;case lx.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(lx.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(lx.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(lx.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(lx.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(lx.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(lx.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case lx.X:n[0]=1;break;case lx.Y:n[1]=1;break;case lx.Z:n[2]=1;break;case lx.I:Ho(r,[1,0,0],n);break;case lx.J:Ho(r,[0,1,0],n);break;case lx.K:Ho(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==lx.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Pa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case lx.I:r[0]=a,r[1]=a;break;case lx.J:r[2]=a,r[3]=a;break;case lx.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Pa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case lx.I:a[0]=s-r,a[1]=s+r;break;case lx.J:a[2]=s-r,a[3]=s+r;break;case lx.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=ax(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=ax(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}(e,t)}var dx={newInstance:Wt.newInstance(ux,"vtkImageMapper"),extend:ux,...ix,...sx,...Lf};const{vtkErrorMacro:px}=Wt;function fx(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}const gx={outputPointsPrecision:Ms.DEFAULT};function mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gx,n),Wt.setGet(e,t,["outputPointsPrecision"]),Wt.obj(e,t),Wt.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void px("No input specified.");if(1===o)return void(r[0]=n[0]);const a=r[0]&&n[0]!==r[0]?r[0].initialize():gu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Ms.SINGLE?s=cs.FLOAT:t.outputPointsPrecision===Ms.DOUBLE&&(s=cs.DOUBLE);const v=Yl.newInstance({dataType:s});v.setNumberOfPoints(i);const T=v.getData(),y=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=xs.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=xs.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=xs.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];T.set(t.getPoints().getData(),3*i),fx(y,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),fx(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),fx(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),fx(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(y),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}(e,t)}var hx={newInstance:Wt.newInstance(mx,"vtkAppendPolyData"),extend:mx};const vx={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function Tx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vx,n),Wt.obj(e,t),Wt.setGet(e,t,["height","radius","resolution","capping"]),Wt.setGetArray(e,t,["center","direction"],3),Wt.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=(e,n)=>{const r=2*Math.PI/t.resolution,o=-t.height/2,a=t.resolution+1,i=4*t.resolution+1+t.resolution;let s=0;const l=Wt.newTypedArray(t.pointType,3*a);let c=0;const u=new Uint32Array(i);l[0]=t.height/2,l[1]=0,l[2]=0,t.capping&&(u[c++]=t.resolution);for(let e=0;e<t.resolution;e++)s++,l[3*s+0]=o,l[3*s+1]=t.radius*Math.cos(e*r),l[3*s+2]=t.radius*Math.sin(e*r),t.capping&&(u[t.resolution-c+++1]=s);for(let e=0;e<t.resolution;e++)u[c++]=3,u[c++]=0,u[c++]=e+1,u[c++]=e+2>t.resolution?1:e+2;df().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(l);const d=n[0]?.initialize()||gu.newInstance();d.getPoints().setData(l,3),d.getPolys().setData(u,1),n[0]=d}}(e,t)}var yx={newInstance:Wt.newInstance(Tx,"vtkConeSource"),extend:Tx};const bx={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function xx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bx,n),Wt.obj(e,t),Wt.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),Wt.setGetArray(e,t,["center","direction"],3),Wt.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=(e,n)=>{const r=2*Math.PI/t.resolution;let o=2*t.resolution,a=5*t.resolution;t.capping&&(o=4*t.resolution,a=7*t.resolution+2);const i=Wt.newTypedArray(t.pointType,3*o);let s=0;const l=new Uint32Array(a),c=new Float32Array(3*o),u=xs.newInstance({numberOfComponents:3,values:c,name:"Normals"}),d=new Float32Array(2*o),p=xs.newInstance({numberOfComponents:2,values:d,name:"TCoords"}),f=[0,0,0],g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0],T=[0,0],y=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){f[0]=Math.cos(e*r+t.initAngle),g[0]=f[0],m[0]=t.radius*f[0]+t.center[0],h[0]=m[0],v[0]=Math.abs(2*e/t.resolution-1),T[0]=v[0],m[1]=.5*t.height+t.center[1],h[1]=-.5*t.height+t.center[1],v[1]=0,T[1]=1,f[2]=-Math.sin(e*r+t.initAngle),g[2]=f[2],m[2]=y*f[2]+t.center[2],h[2]=m[2];const n=2*e;for(let e=0;e<3;e++)c[3*n+e]=f[e],c[3*(n+1)+e]=g[e],i[3*n+e]=m[e],i[3*(n+1)+e]=h[e],e<2&&(d[2*n+e]=v[e],d[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){l[s++]=4,l[s++]=2*e,l[s++]=2*e+1;const n=(2*e+3)%(2*t.resolution);l[s++]=n,l[s++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){m[0]=t.radius*Math.cos(e*r+t.initAngle),h[0]=m[0],v[0]=m[0],T[0]=m[0],m[0]+=t.center[0],h[0]+=t.center[0],f[1]=1,g[1]=-1,m[1]=.5*t.height+t.center[1],h[1]=-.5*t.height+t.center[1],m[2]=-y*Math.sin(e*r+t.initAngle),h[2]=m[2],v[1]=m[2],T[1]=m[2],m[2]+=t.center[2],h[2]+=t.center[2];const n=2*t.resolution+e,o=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)c[3*n+e]=f[e],c[3*o+e]=g[e],i[3*n+e]=m[e],i[3*o+e]=h[e],e<2&&(d[2*n+e]=v[e],d[2*o+e]=T[e])}l[s++]=t.resolution;for(let e=0;e<t.resolution;e++)l[s++]=2*t.resolution+e;l[s++]=t.resolution;for(let e=0;e<t.resolution;e++)l[s++]=3*t.resolution+e}df().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(i);const b=n[0]?.initialize()||gu.newInstance();b.getPoints().setData(i,3),b.getPolys().setData(l,1),b.getPointData().setNormals(u),b.getPointData().setTCoords(p),n[0]=b}}(e,t)}var Cx={newInstance:Wt.newInstance(xx,"vtkCylinderSource"),extend:xx};const Sx={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function Ax(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sx,n),Wt.obj(e,t),Wt.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),Wt.setGetArray(e,t,["direction"],3),Wt.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=(e,n)=>{const r=Cx.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();uf().rotateZ(-90).apply(a).apply(i);const s=yx.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();df().translate(1-.5*t.tipLength,0,0).apply(c);const u=hx.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();df().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(df().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(df().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}(e,t)}var Ix={newInstance:Wt.newInstance(Ax,"vtkArrowSource"),extend:Ax};function wx(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];uf().translate(...n).apply(e.getPoints().getData())}function Ox(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],uf().translate(...o).apply(e.getPoints().getData())}function Px(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(xs.newInstance({name:"color",numberOfComponents:3,values:a}))}function Rx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};ss.extend(e,t,function(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}(n)),Wt.setGet(e,t,["config","xConfig","yConfig","zConfig"]),function(e,t){t.classHierarchy.push("vtkAxesActor");const n=Gl.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=Ix.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?wx(r):Ox(r,0,e.invert),Px(r,...e.color),e={...t.config,...t.yConfig};const o=Ix.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?wx(o):Ox(o,1,e.invert),Px(o,...e.color),e={...t.config,...t.zConfig};const a=Ix.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?wx(a):Ox(a,2,e.invert),Px(a,...e.color);const i=hx.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=Wt.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}(e,t)}var Mx={newInstance:Wt.newInstance(Rx,"vtkAxesActor"),extend:Rx};const Ex="resetcamera",Vx="orientation",Dx={MODE_RESET_CAMERA:Ex,MODE_ORIENTATION:Vx,MODE_SAME:"same"};const Lx={mode:Vx,focalPoint:[0,0,0],distance:6.8,active:!0};function Bx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lx,n),ht(e,t),Ct(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),It(e,t,["focalPoint"],3,0),function(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._onSrcRendererChanged=a,t._onDstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===Vx?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],Fo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===Ex&&t.dstRenderer.resetCamera())},e.delete=Et((()=>e.setSrcRenderer(null)),e.delete),a()}(e,t)}var Nx={newInstance:Mt(Bx,"vtkCameraSynchronizer"),extend:Bx,SynchronizationMode:Dx};const Fx={},_x={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=Nx.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:Nx.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var kx=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;Fx[r]||(Fx[r]={});const o=Fx[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=Nx.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];_x[e.type]?o[r]=new _x[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const Gx={},Ux=/instance:\${([^}]+)}/,zx={},Wx=[],Hx={},jx={vtkPoints:Yl,vtkCellArray:Kl,vtkDataArray:xs};function Kx(e){return e.map((e=>Ux.exec(e))).filter((e=>e)).map((e=>e[1]))}function $x(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),$x(e,t)})),t}function qx(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=Gx[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function Xx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Gx[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function Yx(){Object.keys(Gx).forEach((e=>{delete Gx[e]}))}function Zx(e){if(1===e[1].length)return-1===Wx.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===Wx.indexOf(e[1][n]);return t}function Qx(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(Hx[r]){const{key:n,value:o}=Hx[r];if(!n||e.properties[n]===o)return void Wx.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=Xx(r,{managedInstanceId:t}),n.registerInstance(t,o)),qx(r,o,e,n)})),t.calls&&t.calls.filter(Zx).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=Ux.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=jx[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function Jx(e,t,n){zx[t.id]||Qx(e,t,n),zx[t.id]=!0}function eC(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function tC(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function nC(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=tC(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=tC(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),eC(t.getPointData(),i.pointData),eC(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=Qx(t,s,r);return r.end(),l}}const rC=nC(["points","polys","verts","lines","strips"]),oC=nC([]);function aC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Qx;Xx||qx?Gx[e]={build:t,update:n}:delete Gx[e]}const iC={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},sC={vtkAxesActor:{build:Mx.newInstance,update:Qx},vtkRenderWindow:{build:hh.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(Zx).filter((e=>"removeRenderer"===e[0])).forEach((e=>{Kx(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),Qx(e,t,n),kx(e,t,n)}},vtkRenderer:{build:uh.newInstance,update:function(e,t,n){Qx(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=$x(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(Zx).filter((e=>"removeViewProp"===e[0])).forEach((e=>{Kx(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:fl.newInstance,update:Qx},vtkCamera:{build:Ym.newInstance,update:Jx},vtkPolyData:{build:gu.newInstance,update:rC},vtkImageData:{build:Xs.newInstance,update:oC},vtkMapper:{build:Gl.newInstance,update:Qx},vtkGlyph3DMapper:{build:Mb.newInstance,update:Qx},vtkProperty:{build:os.newInstance,update:Qx},vtkActor:{build:ss.newInstance,update:Qx},vtkLight:{build:Jm.newInstance,update:Qx},vtkColorTransferFunction:{build:Sb.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:vu.newInstance,update:Qx},vtkVolume:{build:Hb.newInstance,update:Qx},vtkVolumeMapper:{build:Xb.newInstance,update:Qx},vtkVolumeProperty:{build:Ub.newInstance,update:Qx},vtkImageSlice:{build:nx.newInstance,update:Qx},vtkImageMapper:{build:dx.newInstance,update:Qx},vtkImageProperty:{build:Jb.newInstance,update:Qx},vtkPiecewiseFunction:{build:Lb.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:Lu.newInstance,update:Qx},vtkScalarBarActor:{build:dp.newInstance,update:Qx}};function lC(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&Yx(),Object.keys(sC).forEach((e=>{const t=sC[e];aC(e,t.build,t.update)}))}function cC(){Object.keys(iC).forEach((e=>{iC[e].forEach((t=>{Gx[t]=Gx[e]}))}))}lC(),cC(),Hx.vtkPVLight={};var uC={build:Xx,update:qx,genericUpdater:Qx,oneTimeGenericUpdater:Jx,setTypeMapping:aC,clearTypeMapping:Yx,getSupportedTypes:function(){return Object.keys(Gx)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return void Object.keys(zx).forEach((e=>{delete zx[e]}));let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete zx[e]})),r},updateRenderWindow:function(e,t,n){return qx("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){Hx[e]={key:t,value:n}},setDefaultMapping:lC,applyDefaultAliases:cC,alwaysUpdateCamera:function(){aC("vtkCamera",Ym.newInstance),cC()}};const dC={};function pC(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=$g.toArrayBuffer(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function fC(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function gC(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Rt(t,n,"progressEvent"),Rt(t,n,"progressDone"),t}function mC(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function hC(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=dC[e];return t||(t={...pC(),...fC(),...gC(),...mC()},dC[e]=t),t}function vC(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Dt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),uC.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){uC.clearOneTimeUpdaters(a())}}}const TC={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function yC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TC,n),hh.extend(e,t),Tt(e,t,["synchronizerContext"]),function(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=hC(t.synchronizerContextName));const n=vC(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Et(e[t],n[t]):e[t]=n[t]}))}(e,t)}var bC={newInstance:Mt(yC,"vtkSynchronizableRenderWindow"),extend:yC,getSynchronizerContext:hC,setSynchronizerContext:function(e,t){dC[e]=t},clearSynchronizerContext:function(e){if(e&&dC[e]&&delete dC[e],!e){const e=Object.keys(dC);for(let t=0;t<e.length;t++)delete dC[e[t]]}},decorate:function(e){const t=vC(e,hC(arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default"));return{...t,...e,delete:Et(e.delete,t.delete)}},createInstanceMap:fC,createArrayHandler:pC,createProgressHandler:gC,createSceneMtimeHandler:mC,vtkObjectManager:uC};const{vtkErrorMacro:xC,vtkDebugMacro:CC}=Wt;let SC=0;function AC(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function IC(e){return"/"===e[0]?e.substr(1):e}const wC={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=AC(IC(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=AC(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=IC([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=AC(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=Lm(Em(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array($g.toArrayBuffer(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=Lm(Em(new Uint8Array(n.buffer))):n.buffer=Em(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(Gm!==n.ref.encode&&Gm&&(CC(`Swap bytes of ${n.name}`),Um(n.buffer,ls[n.dataType])),n.values=Wt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&xC(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--SC&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};Xg("html",(e=>wC));const{vtkErrorMacro:OC,vtkDebugMacro:PC}=Wt;function RC(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const MC=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new Zg(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(Vm)return Vm.encode(e);var o=e.length,a=new Zg(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Zg(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return bm(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=_m(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||OC("ERROR!!! zip not ready...");const u=RC([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=Lm(Em(new Uint8Array(e.buffer))):e.buffer=Em(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(Gm!==e.ref.encode&&Gm&&(PC(`Swap bytes of ${e.name}`),Um(e.buffer,ls[e.dataType])),e.values=Wt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&OC(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(Lm(Em(r))):JSON.parse(r),n()}}(i,s.compression,d);e(Lm(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=RC(n);t||OC("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=Lm(Em(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(Lm(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=RC(n);t||OC("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Lm(_m(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(Lm(s))},fetchImage(e,n){const a=RC(n);t||OC("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Kg(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=RC(n);t||OC("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(Em(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};Xg("zip",(e=>MC(e)));var EC=n(911),VC=n.n(EC),DC=n(893),LC=n.n(DC),BC=n(383),NC=n.n(BC),FC=n(884),_C=n.n(FC),kC=n(88),GC=n.n(kC),UC=n(997),zC=n.n(UC),WC=n(96),HC={};HC.styleTagTransform=zC(),HC.setAttributes=_C(),HC.insert=NC().bind(null,"head"),HC.domAPI=LC(),HC.insertStyleElement=GC(),VC()(WC.A,HC);var jC=WC.A&&WC.A.locals?WC.A.locals:void 0;let KC=!0;function $C(e){e.preventDefault(),e.stopPropagation()}function qC(e,t){KC=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=ub.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=bC.getSynchronizerContext(),a=bC.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",jC.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=Wt.formatBytesToProperUnit(e.loaded)};t.fileURL?Km.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Yg.get("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):Km.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Yg.get("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=$g.toArrayBuffer(t.base64Str),n=Yg.get("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function XC(e){KC=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(jC.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${jC.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){$C(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];qC(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",$C)}const YC=Zh();if(YC.url||YC.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(jC.fullScreen),t.style.margin="0",t.style.padding="0"),KC=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>qC(n,YC)))}setTimeout((()=>{KC&&XC()}),100),window.OfflineLocalView={initLocalFileLoader:XC,load:qC}},613:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},336:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},20:function(e){"use strict";e.exports=function(e){return e[1]}},555:function(e,t,n){"use strict";var r=n(382),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},77:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},730:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},979:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},59:function(e,t,n){"use strict";var r=n(555),o=n(979),a=n(920),i=n(482),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},920:function(e,t,n){"use strict";var r=n(979);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},482:function(e,t,n){"use strict";var r=n(555),o=n(920);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},982:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(642),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var T=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),y=0;y<u.length;++y)T&&"constructor"===u[y]||!o.call(e,u[y])||p.push(u[y]);return p}}e.exports=r},382:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(642),a=Object.keys,i=a?function(e){return a(e)}:n(982),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},642:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},318:function(e,t,n){var r=n(767),o=n(698),a=n(744),i=n(402),s=n(576),l=n(886),c=n(262);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},767:function(e,t,n){var r;!function(e,o){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.alea=s}(0,e=n.nmd(e),n.amdD)},886:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.tychei=s}(0,e=n.nmd(e),n.amdD)},698:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor128=s}(0,e=n.nmd(e),n.amdD)},576:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor4096=s}(0,e=n.nmd(e),n.amdD)},402:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorshift7=s}(0,e=n.nmd(e),n.amdD)},744:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorwow=s}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,T(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),T(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,T(a)]}}():e,3),r),f=new g(r),y=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return y.int32=function(){return 0|f.g(4)},y.quick=function(){return f.g(4)/4294967296},y.double=y,v(T(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(y,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return T(t)}function T(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(1)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},292:function(e){e.exports=function(){"use strict";var e=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function t(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function n(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function o(e){var r,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(r=64;r<=c;r+=64)t(u,n(e.substring(r-64,r)));for(o=(e=e.substring(r-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],r=0;r<o;r+=1)a[r>>2]|=e.charCodeAt(r)<<(r%4<<3);if(a[r>>2]|=128<<(r%4<<3),r>55)for(t(u,a),r=0;r<16;r+=1)a[r]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}function a(t){var n,r="";for(n=0;n<4;n+=1)r+=e[t>>8*n+4&15]+e[t>>8*n&15];return r}function i(e){var t;for(t=0;t<e.length;t+=1)e[t]=a(e[t]);return e.join("")}function s(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function l(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function c(){this.reset()}return i(o("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),c.prototype.append=function(e){return this.appendBinary(s(e)),this},c.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var r,o=this._buff.length;for(r=64;r<=o;r+=64)t(this._hash,n(this._buff.substring(r-64,r)));return this._buff=this._buff.substring(r-64),this},c.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},c.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},c.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},c.prototype._finish=function(e,n){var r,o,a,i=n;if(e[i>>2]|=128<<(i%4<<3),i>55)for(t(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,t(this._hash,e)},c.hash=function(e,t){return c.hashBinary(s(e),t)},c.hashBinary=function(e,t){var n=i(o(e));return t?l(n):n},c.ArrayBuffer=function(){this.reset()},c.ArrayBuffer.prototype.append=function(e){var n,o,a,i,s,l=(o=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(o.byteLength+a.byteLength)).set(new Uint8Array(o)),s.set(new Uint8Array(a),o.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,n=64;n<=c;n+=64)t(this._hash,r(l.subarray(n-64,n)));return this._buff=n-64<c?new Uint8Array(l.buffer.slice(n-64)):new Uint8Array(0),this},c.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.ArrayBuffer.prototype.getState=function(){var e,t=c.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},c.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),c.prototype.setState.call(this,e)},c.ArrayBuffer.prototype.destroy=c.prototype.destroy,c.ArrayBuffer.prototype._finish=c.prototype._finish,c.ArrayBuffer.hash=function(e,n){var o=i(function(e){var n,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(n=64;n<=c;n+=64)t(u,r(e.subarray(n-64,n)));for(o=(e=n-64<c?e.subarray(n-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=0;n<o;n+=1)a[n>>2]|=e[n]<<(n%4<<3);if(a[n>>2]|=128<<(n%4<<3),n>55)for(t(u,a),n=0;n<16;n+=1)a[n]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}(new Uint8Array(e)));return n?l(o):o},c}()},96:function(e,t,n){"use strict";var r=n(20),o=n.n(r),a=n(613),i=n.n(a),s=n(336),l=n.n(s),c=new URL(n(183),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.A=u},50:function(e,t,n){var r=n(853),o=n(77);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},911:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},383:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},88:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},884:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},893:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},997:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},183:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},1:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(50)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
